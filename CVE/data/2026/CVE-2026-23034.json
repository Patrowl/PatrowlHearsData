{"publishedDate": "2026-01-31T12:16Z", "lastModifiedDate": "2026-01-31T12:16Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2026-23034", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/amdgpu/userq: Fix fence reference leak on queue teardown v2\n\nThe user mode queue keeps a pointer to the most recent fence in\nuserq->last_fence. This pointer holds an extra dma_fence reference.\n\nWhen the queue is destroyed, we free the fence driver and its xarray,\nbut we forgot to drop the last_fence reference.\n\nBecause of the missing dma_fence_put(), the last fence object can stay\nalive when the driver unloads. This leaves an allocated object in the\namdgpu_userq_fence slab cache and triggers\n\nThis is visible during driver unload as:\n\n  BUG amdgpu_userq_fence: Objects remaining on __kmem_cache_shutdown()\n  kmem_cache_destroy amdgpu_userq_fence: Slab cache still has objects\n  Call Trace:\n    kmem_cache_destroy\n    amdgpu_userq_fence_slab_fini\n    amdgpu_exit\n    __do_sys_delete_module\n\nFix this by putting userq->last_fence and clearing the pointer during\namdgpu_userq_fence_driver_free().\n\nThis makes sure the fence reference is released and the slab cache is\nempty when the module exits.\n\nv2: Update to only release userq->last_fence with dma_fence_put()\n    (Christian)\n\n(cherry picked from commit 8e051e38a8d45caf6a866d4ff842105b577953bb)"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/b2426a211dba6432e32a2e70e9183c6e134475c6", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e1a30e1ab33fc522785d04bbf7e1b13a5c5c9175", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}