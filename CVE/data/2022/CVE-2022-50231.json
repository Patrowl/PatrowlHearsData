{"publishedDate": "2025-06-18T11:15Z", "lastModifiedDate": "2025-06-18T13:47Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-50231", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ncrypto: arm64/poly1305 - fix a read out-of-bound\n\nA kasan error was reported during fuzzing:\n\nBUG: KASAN: slab-out-of-bounds in neon_poly1305_blocks.constprop.0+0x1b4/0x250 [poly1305_neon]\nRead of size 4 at addr ffff0010e293f010 by task syz-executor.5/1646715\nCPU: 4 PID: 1646715 Comm: syz-executor.5 Kdump: loaded Not tainted 5.10.0.aarch64 #1\nHardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.59 01/31/2019\nCall trace:\n dump_backtrace+0x0/0x394\n show_stack+0x34/0x4c arch/arm64/kernel/stacktrace.c:196\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x158/0x1e4 lib/dump_stack.c:118\n print_address_description.constprop.0+0x68/0x204 mm/kasan/report.c:387\n __kasan_report+0xe0/0x140 mm/kasan/report.c:547\n kasan_report+0x44/0xe0 mm/kasan/report.c:564\n check_memory_region_inline mm/kasan/generic.c:187 [inline]\n __asan_load4+0x94/0xd0 mm/kasan/generic.c:252\n neon_poly1305_blocks.constprop.0+0x1b4/0x250 [poly1305_neon]\n neon_poly1305_do_update+0x6c/0x15c [poly1305_neon]\n neon_poly1305_update+0x9c/0x1c4 [poly1305_neon]\n crypto_shash_update crypto/shash.c:131 [inline]\n shash_finup_unaligned+0x84/0x15c crypto/shash.c:179\n crypto_shash_finup+0x8c/0x140 crypto/shash.c:193\n shash_digest_unaligned+0xb8/0xe4 crypto/shash.c:201\n crypto_shash_digest+0xa4/0xfc crypto/shash.c:217\n crypto_shash_tfm_digest+0xb4/0x150 crypto/shash.c:229\n essiv_skcipher_setkey+0x164/0x200 [essiv]\n crypto_skcipher_setkey+0xb0/0x160 crypto/skcipher.c:612\n skcipher_setkey+0x3c/0x50 crypto/algif_skcipher.c:305\n alg_setkey+0x114/0x2a0 crypto/af_alg.c:220\n alg_setsockopt+0x19c/0x210 crypto/af_alg.c:253\n __sys_setsockopt+0x190/0x2e0 net/socket.c:2123\n __do_sys_setsockopt net/socket.c:2134 [inline]\n __se_sys_setsockopt net/socket.c:2131 [inline]\n __arm64_sys_setsockopt+0x78/0x94 net/socket.c:2131\n __invoke_syscall arch/arm64/kernel/syscall.c:36 [inline]\n invoke_syscall+0x64/0x100 arch/arm64/kernel/syscall.c:48\n el0_svc_common.constprop.0+0x220/0x230 arch/arm64/kernel/syscall.c:155\n do_el0_svc+0xb4/0xd4 arch/arm64/kernel/syscall.c:217\n el0_svc+0x24/0x3c arch/arm64/kernel/entry-common.c:353\n el0_sync_handler+0x160/0x164 arch/arm64/kernel/entry-common.c:369\n el0_sync+0x160/0x180 arch/arm64/kernel/entry.S:683\n\nThis error can be reproduced by the following code compiled as ko on a\nsystem with kasan enabled:\n\n#include <linux/module.h>\n#include <linux/crypto.h>\n#include <crypto/hash.h>\n#include <crypto/poly1305.h>\n\nchar test_data[] = \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\"\n                   \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\"\n                   \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\"\n                   \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\";\n\nint init(void)\n{\n        struct crypto_shash *tfm = NULL;\n        char *data = NULL, *out = NULL;\n\n        tfm = crypto_alloc_shash(\"poly1305\", 0, 0);\n        data = kmalloc(POLY1305_KEY_SIZE - 1, GFP_KERNEL);\n        out = kmalloc(POLY1305_DIGEST_SIZE, GFP_KERNEL);\n        memcpy(data, test_data, POLY1305_KEY_SIZE - 1);\n        crypto_shash_tfm_digest(tfm, data, POLY1305_KEY_SIZE - 1, out);\n\n        kfree(data);\n        kfree(out);\n        return 0;\n}\n\nvoid deinit(void)\n{\n}\n\nmodule_init(init)\nmodule_exit(deinit)\nMODULE_LICENSE(\"GPL\");\n\nThe root cause of the bug sits in neon_poly1305_blocks. The logic\nneon_poly1305_blocks() performed is that if it was called with both s[]\nand r[] uninitialized, it will first try to initialize them with the\ndata from the first \"block\" that it believed to be 32 bytes in length.\nFirst 16 bytes are used as the key and the next 16 bytes for s[]. This\nwould lead to the aforementioned read out-of-bound. However, after\ncalling poly1305_init_arch(), only 16 bytes were deducted from the input\nand s[] is initialized yet again with the following 16 bytes. The second\ninitialization of s[] is certainly redundent which indicates that the\nfirst initialization should be for r[] only.\n\nThis patch fixes the issue by calling poly1305_init_arm64() instead o\n---truncated---"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: crypto: arm64/poly1305 - corrige una lectura fuera de los l\u00edmites Se inform\u00f3 un error de kasan durante el fuzzing: BUG: KASAN: slab-out-of-bounds en neon_poly1305_blocks.constprop.0+0x1b4/0x250 [poly1305_neon] Lectura de tama\u00f1o 4 en la direcci\u00f3n ffff0010e293f010 por la tarea syz-executor.5/1646715 CPU: 4 PID: 1646715 Comm: syz-executor.5 Kdump: cargado No contaminado 5.10.0.aarch64 #1 Nombre del hardware: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.59 31/01/2019 Rastreo de llamadas: dump_backtrace+0x0/0x394 show_stack+0x34/0x4c arch/arm64/kernel/stacktrace.c:196 __dump_stack lib/dump_stack.c:77 [en l\u00ednea] dump_stack+0x158/0x1e4 lib/dump_stack.c:118 print_address_description.constprop.0+0x68/0x204 mm/kasan/report.c:387 __kasan_report+0xe0/0x140 mm/kasan/report.c:547 kasan_report+0x44/0xe0 mm/kasan/report.c:564 check_memory_region_inline mm/kasan/generic.c:187 [en l\u00ednea] __asan_load4+0x94/0xd0 mm/kasan/generic.c:252 neon_poly1305_blocks.constprop.0+0x1b4/0x250 [poly1305_neon] neon_poly1305_do_update+0x6c/0x15c [poly1305_neon] neon_poly1305_update+0x9c/0x1c4 [poly1305_neon] crypto_shash_update crypto/shash.c:131 [en l\u00ednea] shash_finup_unaligned+0x84/0x15c crypto/shash.c:179 crypto_shash_finup+0x8c/0x140 crypto/shash.c:193 shash_digest_unaligned+0xb8/0xe4 crypto/shash.c:201 crypto_shash_digest+0xa4/0xfc crypto/shash.c:217 crypto_shash_tfm_digest+0xb4/0x150 crypto/shash.c:229 essiv_skcipher_setkey+0x164/0x200 [essiv] crypto_skcipher_setkey+0xb0/0x160 crypto/skcipher.c:612 skcipher_setkey+0x3c/0x50 crypto/algif_skcipher.c:305 alg_setkey+0x114/0x2a0 crypto/af_alg.c:220 alg_setsockopt+0x19c/0x210 crypto/af_alg.c:253 __sys_setsockopt+0x190/0x2e0 net/socket.c:2123 __do_sys_setsockopt net/socket.c:2134 [en l\u00ednea] __se_sys_setsockopt net/socket.c:2131 [en l\u00ednea] __arm64_sys_setsockopt+0x78/0x94 net/socket.c:2131 __invoke_syscall arch/arm64/kernel/syscall.c:36 [en l\u00ednea] invoke_syscall+0x64/0x100 arch/arm64/kernel/syscall.c:48 el0_svc_common.constprop.0+0x220/0x230 arch/arm64/kernel/syscall.c:155 do_el0_svc+0xb4/0xd4 arch/arm64/kernel/syscall.c:217 el0_svc+0x24/0x3c arch/arm64/kernel/entry-common.c:353 el0_sync_handler+0x160/0x164 arch/arm64/kernel/entry-common.c:369 el0_sync+0x160/0x180 arch/arm64/kernel/entry.S:683 Este error se puede reproducir con el siguiente c\u00f3digo compilado como ko en un sistema con kasan habilitado: #include  #include  #include  #include  char test_data[] = \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\" \"\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\" \"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\" \"\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\"; int init(void) { struct crypto_shash *tfm = NULL; char *data = NULL, *out = NULL; tfm = crypto_alloc_shash(\"poly1305\", 0, 0); datos = kmalloc(POLY1305_KEY_SIZE - 1, GFP_KERNEL); salida = kmalloc(POLY1305_DIGEST_SIZE, GFP_KERNEL); memcpy(datos, datos_de_prueba, POLY1305_KEY_SIZE - 1); crypto_shash_tfm_digest(tfm, datos, POLY1305_KEY_SIZE - 1, salida); kfree(data); kfree(out); return 0; } void deinit(void) { } module_init(init) module_exit(deinit) MODULE_LICENSE(\"GPL\"); La causa ra\u00edz del error reside en neon_poly1305_blocks. La l\u00f3gica de neon_poly1305_blocks() es que, si se invoc\u00f3 con s[] y r[] sin inicializar, primero intentar\u00e1 inicializarlos con los datos del primer \"bloque\", que se cree que tiene una longitud de 32 bytes. Los primeros 16 bytes se utilizan como clave y los siguientes para s[]. Esto provocar\u00eda la lectura fuera de los l\u00edmites mencionada anteriormente. Sin embargo, tras invocar poly1305_init_arch(), solo se restaron 16 bytes de la entrada y s[] se inicializa de nuevo con los siguientes 16 bytes. La segunda inicializaci\u00f3n de s[] es ciertamente redundante, lo que indica que la primera inicializaci\u00f3n deber\u00eda ser solo para r[]. Este parche corrige el problema llamando a poly1305_init_arm64() en lugar de truncated."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/3c77292d52b341831cb09c24ca4112a1e4f9e91f", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/3d4c28475ee352c440b83484b72b1320ff76364a", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/7ae19d422c7da84b5f13bc08b98bd737a08d3a53", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/8d25a08599df7ca3093eb7ca731c7cd41cbfbb51", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/d069dcffef849b8fd10030fd73007a79612803e6", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}