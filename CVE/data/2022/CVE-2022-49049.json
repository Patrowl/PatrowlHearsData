{"publishedDate": "2025-02-26T07:00Z", "lastModifiedDate": "2025-10-14T19:06Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-49049", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/secretmem: fix panic when growing a memfd_secret\n\nWhen one tries to grow an existing memfd_secret with ftruncate, one gets\na panic [1].  For example, doing the following reliably induces the\npanic:\n\n    fd = memfd_secret();\n\n    ftruncate(fd, 10);\n    ptr = mmap(NULL, 10, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    strcpy(ptr, \"123456789\");\n\n    munmap(ptr, 10);\n    ftruncate(fd, 20);\n\nThe basic reason for this is, when we grow with ftruncate, we call down\ninto simple_setattr, and then truncate_inode_pages_range, and eventually\nwe try to zero part of the memory.  The normal truncation code does this\nvia the direct map (i.e., it calls page_address() and hands that to\nmemset()).\n\nFor memfd_secret though, we specifically don't map our pages via the\ndirect map (i.e.  we call set_direct_map_invalid_noflush() on every\nfault).  So the address returned by page_address() isn't useful, and\nwhen we try to memset() with it we panic.\n\nThis patch avoids the panic by implementing a custom setattr for\nmemfd_secret, which detects resizes specifically (setting the size for\nthe first time works just fine, since there are no existing pages to try\nto zero), and rejects them with EINVAL.\n\nOne could argue growing should be supported, but I think that will\nrequire a significantly more lengthy change.  So, I propose a minimal\nfix for the benefit of stable kernels, and then perhaps to extend\nmemfd_secret to support growing in a separate patch.\n\n[1]:\n\n  BUG: unable to handle page fault for address: ffffa0a889277028\n  #PF: supervisor write access in kernel mode\n  #PF: error_code(0x0002) - not-present page\n  PGD afa01067 P4D afa01067 PUD 83f909067 PMD 83f8bf067 PTE 800ffffef6d88060\n  Oops: 0002 [#1] PREEMPT SMP DEBUG_PAGEALLOC PTI\n  CPU: 0 PID: 281 Comm: repro Not tainted 5.17.0-dbg-DEV #1\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n  RIP: 0010:memset_erms+0x9/0x10\n  Code: c1 e9 03 40 0f b6 f6 48 b8 01 01 01 01 01 01 01 01 48 0f af c6 f3 48 ab 89 d1 f3 aa 4c 89 c8 c3 90 49 89 f9 40 88 f0 48 89 d1 <f3> aa 4c 89 c8 c3 90 49 89 fa 40 0f b6 ce 48 b8 01 01 01 01 01 01\n  RSP: 0018:ffffb932c09afbf0 EFLAGS: 00010246\n  RAX: 0000000000000000 RBX: ffffda63c4249dc0 RCX: 0000000000000fd8\n  RDX: 0000000000000fd8 RSI: 0000000000000000 RDI: ffffa0a889277028\n  RBP: ffffb932c09afc00 R08: 0000000000001000 R09: ffffa0a889277028\n  R10: 0000000000020023 R11: 0000000000000000 R12: ffffda63c4249dc0\n  R13: ffffa0a890d70d98 R14: 0000000000000028 R15: 0000000000000fd8\n  FS:  00007f7294899580(0000) GS:ffffa0af9bc00000(0000) knlGS:0000000000000000\n  CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n  CR2: ffffa0a889277028 CR3: 0000000107ef6006 CR4: 0000000000370ef0\n  DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n  DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400\n  Call Trace:\n   ? zero_user_segments+0x82/0x190\n   truncate_inode_partial_folio+0xd4/0x2a0\n   truncate_inode_pages_range+0x380/0x830\n   truncate_setsize+0x63/0x80\n   simple_setattr+0x37/0x60\n   notify_change+0x3d8/0x4d0\n   do_sys_ftruncate+0x162/0x1d0\n   __x64_sys_ftruncate+0x1c/0x20\n   do_syscall_64+0x44/0xa0\n   entry_SYSCALL_64_after_hwframe+0x44/0xae\n  Modules linked in: xhci_pci xhci_hcd virtio_net net_failover failover virtio_blk virtio_balloon uhci_hcd ohci_pci ohci_hcd evdev ehci_pci ehci_hcd 9pnet_virtio 9p netfs 9pnet\n  CR2: ffffa0a889277028\n\n[lkp@intel.com: secretmem_iops can be static]\n[axelrasmussen@google.com: return EINVAL]"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm/secretmem: corregir p\u00e1nico al hacer crecer un memfd_secret Cuando uno intenta hacer crecer un memfd_secret existente con ftruncate, se obtiene un p\u00e1nico [1]. Por ejemplo, hacer lo siguiente induce de manera confiable el p\u00e1nico: fd = memfd_secret(); ftruncate(fd, 10); ptr = mmap(NULL, 10, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0); strcpy(ptr, \"123456789\"); munmap(ptr, 10); ftruncate(fd, 20); La raz\u00f3n b\u00e1sica para esto es que, cuando hacemos crecer con ftruncate, llamamos a simple_setattr, y luego a truncate_inode_pages_range, y eventualmente intentamos poner a cero parte de la memoria. El c\u00f3digo de truncamiento normal hace esto a trav\u00e9s del mapa directo (es decir, llama a page_address() y se la entrega a memset()). Sin embargo, para memfd_secret, espec\u00edficamente no mapeamos nuestras p\u00e1ginas a trav\u00e9s del mapa directo (es decir, llamamos a set_direct_map_invalid_noflush() en cada falla). Por lo tanto, la direcci\u00f3n devuelta por page_address() no es \u00fatil, y cuando intentamos usar memset() con ella, nos asustamos. Este parche evita el p\u00e1nico al implementar un setattr personalizado para memfd_secret, que detecta cambios de tama\u00f1o espec\u00edficamente (establecer el tama\u00f1o por primera vez funciona bien, ya que no hay p\u00e1ginas existentes para intentar poner a cero), y los rechaza con EINVAL. Se podr\u00eda argumentar que se deber\u00eda admitir el crecimiento, pero creo que eso requerir\u00e1 un cambio significativamente m\u00e1s largo. Por lo tanto, propongo una soluci\u00f3n m\u00ednima para el beneficio de los n\u00facleos estables, y luego tal vez extender memfd_secret para admitir el crecimiento en un parche separado. [1]: ERROR: no se puede manejar el error de p\u00e1gina para la direcci\u00f3n: ffffa0a889277028 #PF: acceso de escritura del supervisor en modo kernel #PF: error_code(0x0002) - p\u00e1gina no presente PGD afa01067 P4D afa01067 PUD 83f909067 PMD 83f8bf067 PTE 800ffffef6d88060 Oops: 0002 [#1] PREEMPT SMP DEBUG_PAGEALLOC PTI CPU: 0 PID: 281 Comm: repro No contaminado 5.17.0-dbg-DEV #1 Nombre del hardware: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014 RIP: 0010:memset_erms+0x9/0x10 C\u00f3digo: c1 e9 03 40 0f b6 f6 48 b8 01 01 01 01 01 01 01 01 48 0f af c6 f3 48 ab 89 d1 f3 aa 4c 89 c8 c3 90 49 89 f9 40 88 f0 48 89 d1  aa 4c 89 c8 c3 90 49 89 fa 40 0f b6 ce 48 b8 01 01 01 01 01 01 RSP: 0018:ffffb932c09afbf0 EFLAGS: 00010246 RAX: 0000000000000000 RBX: ffffda63c4249dc0 RCX: 0000000000000fd8 RDX: 0000000000000fd8 RSI: 00000000000000000 RDI: ffffa0a889277028 RBP: ffffb932c09afc00 R08: 0000000000001000 R09: ffffa0a889277028 R10: 0000000000020023 R11: 0000000000000000 R12: ffffda63c4249dc0 R13: ffffa0a890d70d98 R14: 0000000000000028 R15: 0000000000000fd8 FS: 00007f7294899580(0000) GS:ffffa0af9bc00000(0000) knlGS:0000000000000000 CS: 0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: ffffa0a889277028 CR3: 0000000107ef6006 CR4: 0000000000370ef0 DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000 DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400 Rastreo de llamadas: ? zero_user_segments+0x82/0x190 truncate_inode_partial_folio+0xd4/0x2a0 truncate_inode_pages_range+0x380/0x830 truncate_setsize+0x63/0x80 simple_setattr+0x37/0x60 notify_change+0x3d8/0x4d0 do_sys_ftruncate+0x162/0x1d0 __x64_sys_ftruncate+0x1c/0x20 do_syscall_64+0x44/0xa0 entry_SYSCALL_64_after_hwframe+0x44/0xae M\u00f3dulos vinculados en: xhci_pci xhci_hcd virtio_net net_failover failover virtio_blk virtio_balloon uhci_hcd ohci_pci ohci_hcd evdev ehci_pci ehci_hcd 9pnet_virtio 9p netfs 9pnet CR2: ffffa0a889277028 [lkp@intel.com: secretmem_iops puede ser est\u00e1tico] Aprobado por: robot de pruebas del n\u00facleo  [axelrasmussen@google.com: devolver EINVAL]"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/9d3b877daf805fed29be8f61aa3d0ea37df82c7b", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/b6d17c67885a5624e96eb30c4178c65eea8374bf", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/f9b141f93659e09a52e28791ccbaf69c273b8e92", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "1834B447-C046-40BD-BC61-2207ECAB5A66", "cpe_name": [], "versionStartIncluding": "5.14", "versionEndExcluding": "5.15.35"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "E22C86CB-06CD-4D16-AB2A-F21EE8199262", "cpe_name": [], "versionStartIncluding": "5.16", "versionEndExcluding": "5.17.4"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:5.18:rc1:*:*:*:*:*:*", "matchCriteriaId": "6AD94161-84BB-42E6-9882-4FC0C42E9FC1", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:5.18:rc2:*:*:*:*:*:*", "matchCriteriaId": "7AB06DDF-3C2B-416D-B448-E990D8FF67A9", "cpe_name": []}]}]}}