{"publishedDate": "2025-02-26T07:00Z", "lastModifiedDate": "2025-03-25T16:20Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-49093", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nskbuff: fix coalescing for page_pool fragment recycling\n\nFix a use-after-free when using page_pool with page fragments. We\nencountered this problem during normal RX in the hns3 driver:\n\n(1) Initially we have three descriptors in the RX queue. The first one\n    allocates PAGE1 through page_pool, and the other two allocate one\n    half of PAGE2 each. Page references look like this:\n\n                RX_BD1 _______ PAGE1\n                RX_BD2 _______ PAGE2\n                RX_BD3 _________/\n\n(2) Handle RX on the first descriptor. Allocate SKB1, eventually added\n    to the receive queue by tcp_queue_rcv().\n\n(3) Handle RX on the second descriptor. Allocate SKB2 and pass it to\n    netif_receive_skb():\n\n    netif_receive_skb(SKB2)\n      ip_rcv(SKB2)\n        SKB3 = skb_clone(SKB2)\n\n    SKB2 and SKB3 share a reference to PAGE2 through\n    skb_shinfo()->dataref. The other ref to PAGE2 is still held by\n    RX_BD3:\n\n                      SKB2 ---+- PAGE2\n                      SKB3 __/   /\n                RX_BD3 _________/\n\n (3b) Now while handling TCP, coalesce SKB3 with SKB1:\n\n      tcp_v4_rcv(SKB3)\n        tcp_try_coalesce(to=SKB1, from=SKB3)    // succeeds\n        kfree_skb_partial(SKB3)\n          skb_release_data(SKB3)                // drops one dataref\n\n                      SKB1 _____ PAGE1\n                           \\____\n                      SKB2 _____ PAGE2\n                                 /\n                RX_BD3 _________/\n\n    In skb_try_coalesce(), __skb_frag_ref() takes a page reference to\n    PAGE2, where it should instead have increased the page_pool frag\n    reference, pp_frag_count. Without coalescing, when releasing both\n    SKB2 and SKB3, a single reference to PAGE2 would be dropped. Now\n    when releasing SKB1 and SKB2, two references to PAGE2 will be\n    dropped, resulting in underflow.\n\n (3c) Drop SKB2:\n\n      af_packet_rcv(SKB2)\n        consume_skb(SKB2)\n          skb_release_data(SKB2)                // drops second dataref\n            page_pool_return_skb_page(PAGE2)    // drops one pp_frag_count\n\n                      SKB1 _____ PAGE1\n                           \\____\n                                 PAGE2\n                                 /\n                RX_BD3 _________/\n\n(4) Userspace calls recvmsg()\n    Copies SKB1 and releases it. Since SKB3 was coalesced with SKB1, we\n    release the SKB3 page as well:\n\n    tcp_eat_recv_skb(SKB1)\n      skb_release_data(SKB1)\n        page_pool_return_skb_page(PAGE1)\n        page_pool_return_skb_page(PAGE2)        // drops second pp_frag_count\n\n(5) PAGE2 is freed, but the third RX descriptor was still using it!\n    In our case this causes IOMMU faults, but it would silently corrupt\n    memory if the IOMMU was disabled.\n\nChange the logic that checks whether pp_recycle SKBs can be coalesced.\nWe still reject differing pp_recycle between 'from' and 'to' SKBs, but\nin order to avoid the situation described above, we also reject\ncoalescing when both 'from' and 'to' are pp_recycled and 'from' is\ncloned.\n\nThe new logic allows coalescing a cloned pp_recycle SKB into a page\nrefcounted one, because in this case the release (4) will drop the right\nreference, the one taken by skb_try_coalesce()."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: skbuff: correcci\u00f3n de coalescencia para reciclaje de fragmentos de page_pool Corrige un use-after-free al usar page_pool con fragmentos de p\u00e1gina. Encontramos este problema durante RX normal en el controlador hns3: (1) Inicialmente tenemos tres descriptores en la cola RX. El primero asigna PAGE1 a trav\u00e9s de page_pool, y los otros dos asignan la mitad de PAGE2 cada uno. Las referencias de p\u00e1gina se ven as\u00ed: RX_BD1 _______ PAGE1 RX_BD2 _______ PAGE2 RX_BD3 _________/ (2) Manejar RX en el primer descriptor. Asignar SKB1, eventualmente agregado a la cola de recepci\u00f3n por tcp_queue_rcv(). (3) Manejar RX en el segundo descriptor. Asigne SKB2 y p\u00e1selo a netif_receive_skb(): netif_receive_skb(SKB2) ip_rcv(SKB2) SKB3 = skb_clone(SKB2) SKB2 y SKB3 comparten una referencia a PAGE2 a trav\u00e9s de skb_shinfo()-&gt;dataref. La otra referencia a PAGE2 todav\u00eda la mantiene RX_BD3: SKB2 ---+- PAGE2 SKB3 __/ / RX_BD3 _________/ (3b) Ahora, mientras maneja TCP, fusione SKB3 con SKB1: tcp_v4_rcv(SKB3) tcp_try_coalesce(to=SKB1, from=SKB3) // tiene \u00e9xito kfree_skb_partial(SKB3) skb_release_data(SKB3) // elimina una referencia de datos SKB1 _____ PAGE1 \\____ SKB2 _____ PAGE2 / RX_BD3 _________/ En skb_try_coalesce(), __skb_frag_ref() toma una referencia de p\u00e1gina a PAGE2, donde en cambio deber\u00eda haber aumentado la referencia de fragmento de page_pool, pp_frag_count. Sin la fusi\u00f3n, al liberar SKB2 y SKB3, se eliminar\u00eda una \u00fanica referencia a PAGE2. Ahora, al liberar SKB1 y SKB2, se descartar\u00e1n dos referencias a PAGE2, lo que provocar\u00e1 un desbordamiento. (3c) Descartar SKB2: af_packet_rcv(SKB2) consume_skb(SKB2) skb_release_data(SKB2) // descarta la segunda referencia de datos page_pool_return_skb_page(PAGE2) // descarta una pp_frag_count SKB1 _____ PAGE1 \\____ PAGE2 / RX_BD3 _________/ (4) El espacio de usuario llama a recvmsg() Copia SKB1 y lo libera. Dado que SKB3 se fusion\u00f3 con SKB1, tambi\u00e9n liberamos la p\u00e1gina SKB3: tcp_eat_recv_skb(SKB1) skb_release_data(SKB1) page_pool_return_skb_page(PAGE1) page_pool_return_skb_page(PAGE2) // elimina el segundo pp_frag_count (5) PAGE2 se libera, \u00a1pero el tercer descriptor RX todav\u00eda lo estaba usando! En nuestro caso, esto causa fallas de IOMMU, pero corromper\u00eda silenciosamente la memoria si IOMMU estuviera deshabilitado. Cambie la l\u00f3gica que verifica si los SKB pp_recycle se pueden fusionar. A\u00fan rechazamos diferentes pp_recycle entre SKB 'from' y 'to', pero para evitar la situaci\u00f3n descrita anteriormente, tambi\u00e9n rechazamos la fusi\u00f3n cuando tanto 'from' como 'to' son pp_recycled y 'from' es clonado. La nueva l\u00f3gica permite fusionar un SKB pp_recycle clonado en uno con referencia de p\u00e1gina, porque en este caso la versi\u00f3n (4) eliminar\u00e1 la referencia correcta, la tomada por skb_try_coalesce()."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/1effe8ca4e34c34cdd9318436a4232dcb582ebf4", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/72bb856d16e883437023ff2ff77d0c498018728a", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/ba965e8605aee5387cecaa28fcf7ee9f61779a49", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/c4fa19615806a9a7e518c295b39175aa47a685ac", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-416"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 5.9, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "baseScore": 7.8, "baseSeverity": "HIGH", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "918697A2-B45C-4A04-8049-AFAB4BE2444E", "cpe_name": [], "versionStartIncluding": "5.15", "versionEndExcluding": "5.15.34"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "ABBBA66E-0244-4621-966B-9790AF1EEB00", "cpe_name": [], "versionStartIncluding": "5.16", "versionEndExcluding": "5.16.20"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "AE420AC7-1E59-4398-B84F-71F4B4337762", "cpe_name": [], "versionStartIncluding": "5.17", "versionEndExcluding": "5.17.3"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:5.18:rc1:*:*:*:*:*:*", "matchCriteriaId": "6AD94161-84BB-42E6-9882-4FC0C42E9FC1", "cpe_name": []}]}]}}