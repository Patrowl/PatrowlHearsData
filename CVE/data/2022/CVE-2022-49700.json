{"publishedDate": "2025-02-26T07:01Z", "lastModifiedDate": "2025-03-25T13:37Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-49700", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/slub: add missing TID updates on slab deactivation\n\nThe fastpath in slab_alloc_node() assumes that c->slab is stable as long as\nthe TID stays the same. However, two places in __slab_alloc() currently\ndon't update the TID when deactivating the CPU slab.\n\nIf multiple operations race the right way, this could lead to an object\ngetting lost; or, in an even more unlikely situation, it could even lead to\nan object being freed onto the wrong slab's freelist, messing up the\n`inuse` counter and eventually causing a page to be freed to the page\nallocator while it still contains slab objects.\n\n(I haven't actually tested these cases though, this is just based on\nlooking at the code. Writing testcases for this stuff seems like it'd be\na pain...)\n\nThe race leading to state inconsistency is (all operations on the same CPU\nand kmem_cache):\n\n - task A: begin do_slab_free():\n    - read TID\n    - read pcpu freelist (==NULL)\n    - check `slab == c->slab` (true)\n - [PREEMPT A->B]\n - task B: begin slab_alloc_node():\n    - fastpath fails (`c->freelist` is NULL)\n    - enter __slab_alloc()\n    - slub_get_cpu_ptr() (disables preemption)\n    - enter ___slab_alloc()\n    - take local_lock_irqsave()\n    - read c->freelist as NULL\n    - get_freelist() returns NULL\n    - write `c->slab = NULL`\n    - drop local_unlock_irqrestore()\n    - goto new_slab\n    - slub_percpu_partial() is NULL\n    - get_partial() returns NULL\n    - slub_put_cpu_ptr() (enables preemption)\n - [PREEMPT B->A]\n - task A: finish do_slab_free():\n    - this_cpu_cmpxchg_double() succeeds()\n    - [CORRUPT STATE: c->slab==NULL, c->freelist!=NULL]\n\nFrom there, the object on c->freelist will get lost if task B is allowed to\ncontinue from here: It will proceed to the retry_load_slab label,\nset c->slab, then jump to load_freelist, which clobbers c->freelist.\n\nBut if we instead continue as follows, we get worse corruption:\n\n - task A: run __slab_free() on object from other struct slab:\n    - CPU_PARTIAL_FREE case (slab was on no list, is now on pcpu partial)\n - task A: run slab_alloc_node() with NUMA node constraint:\n    - fastpath fails (c->slab is NULL)\n    - call __slab_alloc()\n    - slub_get_cpu_ptr() (disables preemption)\n    - enter ___slab_alloc()\n    - c->slab is NULL: goto new_slab\n    - slub_percpu_partial() is non-NULL\n    - set c->slab to slub_percpu_partial(c)\n    - [CORRUPT STATE: c->slab points to slab-1, c->freelist has objects\n      from slab-2]\n    - goto redo\n    - node_match() fails\n    - goto deactivate_slab\n    - existing c->freelist is passed into deactivate_slab()\n    - inuse count of slab-1 is decremented to account for object from\n      slab-2\n\nAt this point, the inuse count of slab-1 is 1 lower than it should be.\nThis means that if we free all allocated objects in slab-1 except for one,\nSLUB will think that slab-1 is completely unused, and may free its page,\nleading to use-after-free."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm/slub: a\u00f1adir actualizaciones de TID faltantes en la desactivaci\u00f3n de slab La ruta r\u00e1pida en slab_alloc_node() asume que c-&gt;slab es estable siempre que el TID permanezca igual. Sin embargo, dos lugares en __slab_alloc() actualmente no actualizan el TID al desactivar el slab de la CPU. Si varias operaciones se ejecutan en la direcci\u00f3n correcta, esto podr\u00eda provocar que se pierda un objeto; o, en una situaci\u00f3n a\u00fan m\u00e1s improbable, incluso podr\u00eda provocar que se libere un objeto en la lista libre del slab incorrecto, lo que arruina el contador `inuse` y eventualmente provoca que se libere una p\u00e1gina al asignador de p\u00e1ginas mientras a\u00fan contiene objetos slab. (En realidad no he probado estos casos, esto se basa simplemente en mirar el c\u00f3digo. Escribir casos de prueba para estas cosas parece que ser\u00eda una molestia...) La ejecuci\u00f3n que lleva a la inconsistencia de estado es (todas las operaciones en la misma CPU y kmem_cache): - task A: begin do_slab_free(): - read TID - read pcpu freelist (==NULL) - check `slab == c-&gt;slab` (true) - [PREEMPT A-&gt;B] - task B: begin slab_alloc_node(): - fastpath fails (`c-&gt;freelist` is NULL) - enter __slab_alloc() - slub_get_cpu_ptr() (disables preemption) - enter ___slab_alloc() - take local_lock_irqsave() - read c-&gt;freelist as NULL - get_freelist() returns NULL - write `c-&gt;slab = NULL` - drop local_unlock_irqrestore() - goto new_slab - slub_percpu_partial() is NULL - get_partial() returns NULL - slub_put_cpu_ptr() (enables preemption) - [PREEMPT B-&gt;A] - task A: finish do_slab_free(): - this_cpu_cmpxchg_double() succeeds() - [CORRUPT STATE: c-&gt;slab==NULL, c-&gt;freelist!=NULL] From there, the object on c-&gt;freelist will get lost if task B is allowed to continue from here: It will proceed to the retry_load_slab label, set c-&gt;slab, then jump to load_freelist, which clobbers c-&gt;freelist. But if we instead continue as follows, we get worse corruption: - task A: run __slab_free() on object from other struct slab: - CPU_PARTIAL_FREE case (slab was on no list, is now on pcpu partial) - task A: run slab_alloc_node() with NUMA node constraint: - fastpath fails (c-&gt;slab is NULL) - call __slab_alloc() - slub_get_cpu_ptr() (disables preemption) - enter ___slab_alloc() - c-&gt;slab is NULL: goto new_slab - slub_percpu_partial() is non-NULL - set c-&gt;slab to slub_percpu_partial(c) - [CORRUPT STATE: c-&gt;slab points to slab-1, c-&gt;freelist has objects from slab-2] - goto redo - node_match() fails - goto deactivate_slab - existing c-&gt;freelist is passed into deactivate_slab() - inuse count of slab-1 se decrementa para tener en cuenta el objeto de slab-2 En este punto, el conteo de objetos en uso de slab-1 es 1 menos de lo que deber\u00eda ser. Esto significa que si liberamos todos los objetos asignados en slab-1 excepto uno, SLUB pensar\u00e1 que slab-1 est\u00e1 completamente sin usar y puede liberar su p\u00e1gina, lo que lleva a un use-after-free."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/0515cc9b6b24877f59b222ade704bfaa42caa2a6", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/197e257da473c725dfe47759c3ee02f2398d8ea5", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/308c6d0e1f200fd26c71270c6e6bfcf0fc6ff082", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/6c32496964da0dc230cea763a0e934b2e02dabd5", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/d6a597450e686d4c6388bd3cdcb17224b4dae7f0", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/e2b2f0e2e34d71ae6c2a1114fd3c525930e84bc7", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/e7e3e90d671078455a3a08189f89d85b3da2de9e", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/eeaa345e128515135ccb864c04482180c08e3259", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-416"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 5.9, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "baseScore": 7.8, "baseSeverity": "HIGH", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "2B9BA632-0605-4759-8828-79C0E7F757FD", "cpe_name": [], "versionStartIncluding": "3.1", "versionEndExcluding": "4.9.323"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "11E86C4E-715B-4E25-81E9-2FD98431E3FA", "cpe_name": [], "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.288"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "2CC8E927-649A-40AD-AB62-F7EE444BEF0F", "cpe_name": [], "versionStartIncluding": "4.15", "versionEndExcluding": "4.19.252"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "844199C4-DEBE-4DA1-AB77-5A7984F9393B", "cpe_name": [], "versionStartIncluding": "4.20", "versionEndExcluding": "5.4.205"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "8BF24898-7C80-443F-93F3-F82029BBFF72", "cpe_name": [], "versionStartIncluding": "5.5", "versionEndExcluding": "5.10.130"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "B2197EF1-3D9C-4EBA-9F94-6C8668E719B6", "cpe_name": [], "versionStartIncluding": "5.11", "versionEndExcluding": "5.15.54"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "0172D3FA-DDEB-482A-A270-4A1495A8798C", "cpe_name": [], "versionStartIncluding": "5.16", "versionEndExcluding": "5.18.8"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:5.19:rc1:*:*:*:*:*:*", "matchCriteriaId": "A8C30C2D-F82D-4D37-AB48-D76ABFBD5377", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:5.19:rc2:*:*:*:*:*:*", "matchCriteriaId": "BF8547FC-C849-4F1B-804B-A93AE2F04A92", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:5.19:rc3:*:*:*:*:*:*", "matchCriteriaId": "F3068028-F453-4A1C-B80F-3F5609ACEF60", "cpe_name": []}]}]}}