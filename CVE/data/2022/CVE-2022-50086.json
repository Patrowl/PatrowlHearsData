{"publishedDate": "2025-06-18T11:15Z", "lastModifiedDate": "2025-06-18T13:47Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-50086", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nblock: don't allow the same type rq_qos add more than once\n\nIn our test of iocost, we encountered some list add/del corruptions of\ninner_walk list in ioc_timer_fn.\n\nThe reason can be described as follows:\n\ncpu 0\t\t\t\t\tcpu 1\nioc_qos_write\t\t\t\tioc_qos_write\n\nioc = q_to_ioc(queue);\nif (!ioc) {\n        ioc = kzalloc();\n\t\t\t\t\tioc = q_to_ioc(queue);\n\t\t\t\t\tif (!ioc) {\n\t\t\t\t\t\tioc = kzalloc();\n\t\t\t\t\t\t...\n\t\t\t\t\t\trq_qos_add(q, rqos);\n\t\t\t\t\t}\n        ...\n        rq_qos_add(q, rqos);\n        ...\n}\n\nWhen the io.cost.qos file is written by two cpus concurrently, rq_qos may\nbe added to one disk twice. In that case, there will be two iocs enabled\nand running on one disk. They own different iocgs on their active list. In\nthe ioc_timer_fn function, because of the iocgs from two iocs have the\nsame root iocg, the root iocg's walk_list may be overwritten by each other\nand this leads to list add/del corruptions in building or destroying the\ninner_walk list.\n\nAnd so far, the blk-rq-qos framework works in case that one instance for\none type rq_qos per queue by default. This patch make this explicit and\nalso fix the crash above."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bloque: no permitir que el mismo tipo rq_qos se agregue m\u00e1s de una vez En nuestra prueba de iocost, encontramos algunas corrupciones de lista add/del de la lista inner_walk en ioc_timer_fn. La raz\u00f3n puede describirse de la siguiente manera: cpu 0 cpu 1 ioc_qos_write ioc_qos_write ioc = q_to_ioc(queue); if (!ioc) { ioc = kzalloc(); ioc = q_to_ioc(queue); if (!ioc) { ioc = kzalloc(); ... rq_qos_add(q, rqos); } ... rq_qos_add(q, rqos); ... } Cuando dos CPU escriben el archivo io.cost.qos simult\u00e1neamente, es posible que se agregue rq_qos a un disco dos veces. En ese caso, habr\u00e1 dos ioc habilitados y ejecut\u00e1ndose en un disco. Poseen diferentes iocgs en su lista activa. En la funci\u00f3n ioc_timer_fn, dado que los iocgs de dos iocs tienen el mismo iocg ra\u00edz, la lista walk_list de cada iocg ra\u00edz puede sobrescribirse entre s\u00ed, lo que provoca errores al agregar o eliminar listas al crear o destruir la lista inner_walk. Hasta ahora, el framework blk-rq-qos funciona con una instancia de un tipo rq_qos por cola por defecto. Este parche lo aclara y corrige el fallo mencionado."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/08ef66e800a85afc6b54cb95841f6502627eee2e", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/0b7f5d7a4d2a72ad9de04ab8ccba2a31904aa638", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/0c9bb1acd1d103a3070b2126870eb52761d606ce", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/14a6e2eb7df5c7897c15b109cba29ab0c4a791b6", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}