{"publishedDate": "2025-02-26T07:00Z", "lastModifiedDate": "2025-02-26T07:00Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-49075", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix qgroup reserve overflow the qgroup limit\n\nWe use extent_changeset->bytes_changed in qgroup_reserve_data() to record\nhow many bytes we set for EXTENT_QGROUP_RESERVED state. Currently the\nbytes_changed is set as \"unsigned int\", and it will overflow if we try to\nfallocate a range larger than 4GiB. The result is we reserve less bytes\nand eventually break the qgroup limit.\n\nUnlike regular buffered/direct write, which we use one changeset for\neach ordered extent, which can never be larger than 256M.  For\nfallocate, we use one changeset for the whole range, thus it no longer\nrespects the 256M per extent limit, and caused the problem.\n\nThe following example test script reproduces the problem:\n\n  $ cat qgroup-overflow.sh\n  #!/bin/bash\n\n  DEV=/dev/sdj\n  MNT=/mnt/sdj\n\n  mkfs.btrfs -f $DEV\n  mount $DEV $MNT\n\n  # Set qgroup limit to 2GiB.\n  btrfs quota enable $MNT\n  btrfs qgroup limit 2G $MNT\n\n  # Try to fallocate a 3GiB file. This should fail.\n  echo\n  echo \"Try to fallocate a 3GiB file...\"\n  fallocate -l 3G $MNT/3G.file\n\n  # Try to fallocate a 5GiB file.\n  echo\n  echo \"Try to fallocate a 5GiB file...\"\n  fallocate -l 5G $MNT/5G.file\n\n  # See we break the qgroup limit.\n  echo\n  sync\n  btrfs qgroup show -r $MNT\n\n  umount $MNT\n\nWhen running the test:\n\n  $ ./qgroup-overflow.sh\n  (...)\n\n  Try to fallocate a 3GiB file...\n  fallocate: fallocate failed: Disk quota exceeded\n\n  Try to fallocate a 5GiB file...\n\n  qgroupid\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 rfer\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 excl\u00a0\u00a0\u00a0\u00a0 max_rfer\n  --------\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ----\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 ----\u00a0\u00a0\u00a0\u00a0 --------\n  0/5\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 5.00GiB\u00a0\u00a0\u00a0\u00a0\u00a0 5.00GiB\u00a0\u00a0\u00a0\u00a0\u00a0 2.00GiB\n\nSince we have no control of how bytes_changed is used, it's better to\nset it to u64."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: btrfs: corregir el desbordamiento de reserva de qgroup del l\u00edmite de qgroup Usamos extended_changeset-&gt;bytes_changed en qgroup_reserve_data() para registrar cu\u00e1ntos bytes configuramos para el estado EXTENT_QGROUP_RESERVED. Actualmente, bytes_changed est\u00e1 configurado como \"unsigned int\" y se desbordar\u00e1 si intentamos hacer falocaci\u00f3n en un rango mayor a 4 GiB. El resultado es que reservamos menos bytes y eventualmente rompemos el l\u00edmite de qgroup. A diferencia de la escritura directa/en b\u00fafer regular, que utilizamos un conjunto de cambios para cada extensi\u00f3n ordenada, que nunca puede ser mayor a 256M. Para falocaci\u00f3n, utilizamos un conjunto de cambios para todo el rango, por lo tanto, ya no respeta el l\u00edmite de 256M por extensi\u00f3n y caus\u00f3 el problema. El siguiente ejemplo de secuencia de comandos de prueba reproduce el problema: $ cat qgroup-overflow.sh #!/bin/bash DEV=/dev/sdj MNT=/mnt/sdj mkfs.btrfs -f $DEV mount $DEV $MNT # Establezca el l\u00edmite de qgroup en 2 GiB. btrfs quota enable $MNT btrfs qgroup limit 2G $MNT # Intente realizar la operaci\u00f3n de fallocate de un archivo de 3 GiB. Esto deber\u00eda fallar. echo echo \"Intente realizar la operaci\u00f3n de fallocate de un archivo de 3 GiB...\" fallocate -l 3G $MNT/3G.file # Intente realizar la operaci\u00f3n de fallocate de un archivo de 5 GiB. echo echo \"Intente realizar la operaci\u00f3n de fallocate de un archivo de 5 GiB...\" fallocate -l 5G $MNT/5G.file # Vea que rompemos el l\u00edmite de qgroup. echo sync btrfs qgroup show -r $MNT umount $MNT Al ejecutar la prueba: $ ./qgroup-overflow.sh (...) Intenta fallar un archivo de 3 GiB... fallocate: fallocate fall\u00f3: Cuota de disco excedida Intenta fallar un archivo de 5 GiB... qgroupid rfer excl max_rfer -------- ---- ---- -------- 0/5 5.00GiB 5.00GiB 2.00GiB Dado que no tenemos control sobre c\u00f3mo se usa bytes_changed, es mejor configurarlo en u64."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/0355387ea5b02d353c9415613fab908fac5c52a6", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/44277c50fdba5019ca25bfad1b71e2561b0de11b", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/4b98799e181b4326a613108cf37acc1f55d21b45", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/6bfff81286d4491f02dad7814bae5c77c9ad2320", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/7941b74ed49b6db25efbef2256ebef843c11a010", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/82ae73ac963cee877ce34f7c31b2b456b516e96c", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/b642b52d0b50f4d398cb4293f64992d0eed2e2ce", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f3d97b22a708bf9e3f3ac2ba232bcefd0b0c136b", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}