{"publishedDate": "2025-06-18T11:15Z", "lastModifiedDate": "2025-06-18T13:46Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-50000", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: flowtable: fix stuck flows on cleanup due to pending work\n\nTo clear the flow table on flow table free, the following sequence\nnormally happens in order:\n\n  1) gc_step work is stopped to disable any further stats/del requests.\n  2) All flow table entries are set to teardown state.\n  3) Run gc_step which will queue HW del work for each flow table entry.\n  4) Waiting for the above del work to finish (flush).\n  5) Run gc_step again, deleting all entries from the flow table.\n  6) Flow table is freed.\n\nBut if a flow table entry already has pending HW stats or HW add work\nstep 3 will not queue HW del work (it will be skipped), step 4 will wait\nfor the pending add/stats to finish, and step 5 will queue HW del work\nwhich might execute after freeing of the flow table.\n\nTo fix the above, this patch flushes the pending work, then it sets the\nteardown flag to all flows in the flowtable and it forces a garbage\ncollector run to queue work to remove the flows from hardware, then it\nflushes this new pending work and (finally) it forces another garbage\ncollector run to remove the entry from the software flowtable.\n\nStack trace:\n[47773.882335] BUG: KASAN: use-after-free in down_read+0x99/0x460\n[47773.883634] Write of size 8 at addr ffff888103b45aa8 by task kworker/u20:6/543704\n[47773.885634] CPU: 3 PID: 543704 Comm: kworker/u20:6 Not tainted 5.12.0-rc7+ #2\n[47773.886745] Hardware name: QEMU Standard PC (Q35 + ICH9, 2009)\n[47773.888438] Workqueue: nf_ft_offload_del flow_offload_work_handler [nf_flow_table]\n[47773.889727] Call Trace:\n[47773.890214]  dump_stack+0xbb/0x107\n[47773.890818]  print_address_description.constprop.0+0x18/0x140\n[47773.892990]  kasan_report.cold+0x7c/0xd8\n[47773.894459]  kasan_check_range+0x145/0x1a0\n[47773.895174]  down_read+0x99/0x460\n[47773.899706]  nf_flow_offload_tuple+0x24f/0x3c0 [nf_flow_table]\n[47773.907137]  flow_offload_work_handler+0x72d/0xbe0 [nf_flow_table]\n[47773.913372]  process_one_work+0x8ac/0x14e0\n[47773.921325]\n[47773.921325] Allocated by task 592159:\n[47773.922031]  kasan_save_stack+0x1b/0x40\n[47773.922730]  __kasan_kmalloc+0x7a/0x90\n[47773.923411]  tcf_ct_flow_table_get+0x3cb/0x1230 [act_ct]\n[47773.924363]  tcf_ct_init+0x71c/0x1156 [act_ct]\n[47773.925207]  tcf_action_init_1+0x45b/0x700\n[47773.925987]  tcf_action_init+0x453/0x6b0\n[47773.926692]  tcf_exts_validate+0x3d0/0x600\n[47773.927419]  fl_change+0x757/0x4a51 [cls_flower]\n[47773.928227]  tc_new_tfilter+0x89a/0x2070\n[47773.936652]\n[47773.936652] Freed by task 543704:\n[47773.937303]  kasan_save_stack+0x1b/0x40\n[47773.938039]  kasan_set_track+0x1c/0x30\n[47773.938731]  kasan_set_free_info+0x20/0x30\n[47773.939467]  __kasan_slab_free+0xe7/0x120\n[47773.940194]  slab_free_freelist_hook+0x86/0x190\n[47773.941038]  kfree+0xce/0x3a0\n[47773.941644]  tcf_ct_flow_table_cleanup_work\n\nOriginal patch description and stack trace by Paul Blakey."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: netfilter: flowtable: arreglo de flujos atascados en la limpieza debido a trabajo pendiente Para limpiar la tabla de flujo cuando est\u00e1 libre, normalmente ocurre la siguiente secuencia en orden: 1) Se detiene el trabajo de gc_step para deshabilitar cualquier solicitud de estad\u00edsticas/del. 2) Todas las entradas de la tabla de flujo se establecen en estado de desmontaje. 3) Se ejecuta gc_step, que pondr\u00e1 en cola el trabajo de del de HW para cada entrada de la tabla de flujo. 4) Se espera a que finalice el trabajo del del anterior (vaciado). 5) Se vuelve a ejecutar gc_step, eliminando todas las entradas de la tabla de flujo. 6) Se libera la tabla de flujo. Pero si una entrada de la tabla de flujo ya tiene estad\u00edsticas de HW pendientes o trabajo de adici\u00f3n de HW, el paso 3 no pondr\u00e1 en cola el trabajo de del de HW (se omitir\u00e1), el paso 4 esperar\u00e1 a que finalicen las adiciones/estad\u00edsticas pendientes y el paso 5 pondr\u00e1 en cola el trabajo de del de HW que podr\u00eda ejecutarse despu\u00e9s de liberar la tabla de flujo. Para solucionar lo anterior, este parche limpia el trabajo pendiente, luego establece el indicador de desmontaje en todos los flujos en la tabla de flujo y fuerza la ejecuci\u00f3n de un recolector de basura para poner en cola el trabajo para eliminar los flujos del hardware, luego limpia este nuevo trabajo pendiente y (finalmente) fuerza la ejecuci\u00f3n de otro recolector de basura para eliminar la entrada de la tabla de flujo del software. Rastreo de pila: [47773.882335] ERROR: KASAN: Use-After-Free en down_read+0x99/0x460 [47773.883634] Escritura de tama\u00f1o 8 en la direcci\u00f3n ffff888103b45aa8 por la tarea kworker/u20:6/543704 [47773.885634] CPU: 3 PID: 543704 Comm: kworker/u20:6 No contaminado 5.12.0-rc7+ #2 [47773.886745] Nombre del hardware: QEMU Standard PC (Q35 + ICH9, 2009) [47773.888438] Cola de trabajo: nf_ft_offload_del flow_offload_work_handler [nf_flow_table] [47773.889727] Rastreo de llamadas: [47773.890214] dump_stack+0xbb/0x107 [47773.890818] print_address_description.constprop.0+0x18/0x140 [47773.892990] kasan_report.cold+0x7c/0xd8 [47773.894459] kasan_check_range+0x145/0x1a0 [47773.895174] down_read+0x99/0x460 [47773.899706] nf_flow_offload_tuple+0x24f/0x3c0 [nf_flow_table] [47773.907137] flow_offload_work_handler+0x72d/0xbe0 [nf_flow_table] [47773.913372] process_one_work+0x8ac/0x14e0 [47773.921325] [47773.921325] Allocated by task 592159: [47773.922031] kasan_save_stack+0x1b/0x40 [47773.922730] __kasan_kmalloc+0x7a/0x90 [47773.923411] tcf_ct_flow_table_get+0x3cb/0x1230 [act_ct] [47773.924363] tcf_ct_init+0x71c/0x1156 [act_ct] [47773.925207] tcf_action_init_1+0x45b/0x700 [47773.925987] tcf_action_init+0x453/0x6b0 [47773.926692] tcf_exts_validate+0x3d0/0x600 [47773.927419] fl_change+0x757/0x4a51 [cls_flower] [47773.928227] tc_new_tfilter+0x89a/0x2070 [47773.936652] [47773.936652] Freed by task 543704: [47773.937303] kasan_save_stack+0x1b/0x40 [47773.938039] kasan_set_track+0x1c/0x30 [47773.938731] kasan_set_free_info+0x20/0x30 [47773.939467] __kasan_slab_free+0xe7/0x120 [47773.940194] slab_free_freelist_hook+0x86/0x190 [47773.941038] kfree+0xce/0x3a0 [47773.941644] tcf_ct_flow_table_cleanup_work Descripci\u00f3n del parche original y seguimiento de la pila por Paul Blakey."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/89e135a36a9eb81412b5459df94a80995ce62eef", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/8fbdec08dbf7d7ab8e35bdc65eb4394bc82d1e26", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/9afb4b27349a499483ae0134282cefd0c90f480f", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}