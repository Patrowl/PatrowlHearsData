{"publishedDate": "2025-02-26T07:01Z", "lastModifiedDate": "2025-03-25T15:08Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-49236", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix UAF due to race between btf_try_get_module and load_module\n\nWhile working on code to populate kfunc BTF ID sets for module BTF from\nits initcall, I noticed that by the time the initcall is invoked, the\nmodule BTF can already be seen by userspace (and the BPF verifier). The\nexisting btf_try_get_module calls try_module_get which only fails if\nmod->state == MODULE_STATE_GOING, i.e. it can increment module reference\nwhen module initcall is happening in parallel.\n\nCurrently, BTF parsing happens from MODULE_STATE_COMING notifier\ncallback. At this point, the module initcalls have not been invoked.\nThe notifier callback parses and prepares the module BTF, allocates an\nID, which publishes it to userspace, and then adds it to the btf_modules\nlist allowing the kernel to invoke btf_try_get_module for the BTF.\n\nHowever, at this point, the module has not been fully initialized (i.e.\nits initcalls have not finished). The code in module.c can still fail\nand free the module, without caring for other users. However, nothing\nstops btf_try_get_module from succeeding between the state transition\nfrom MODULE_STATE_COMING to MODULE_STATE_LIVE.\n\nThis leads to a use-after-free issue when BPF program loads\nsuccessfully in the state transition, load_module's do_init_module call\nfails and frees the module, and BPF program fd on close calls module_put\nfor the freed module. Future patch has test case to verify we don't\nregress in this area in future.\n\nThere are multiple points after prepare_coming_module (in load_module)\nwhere failure can occur and module loading can return error. We\nillustrate and test for the race using the last point where it can\npractically occur (in module __init function).\n\nAn illustration of the race:\n\nCPU 0                           CPU 1\n\t\t\t  load_module\n\t\t\t    notifier_call(MODULE_STATE_COMING)\n\t\t\t      btf_parse_module\n\t\t\t      btf_alloc_id\t// Published to userspace\n\t\t\t      list_add(&btf_mod->list, btf_modules)\n\t\t\t    mod->init(...)\n...\t\t\t\t^\nbpf_check\t\t        |\ncheck_pseudo_btf_id             |\n  btf_try_get_module            |\n    returns true                |  ...\n...                             |  module __init in progress\nreturn prog_fd                  |  ...\n...                             V\n\t\t\t    if (ret < 0)\n\t\t\t      free_module(mod)\n\t\t\t    ...\nclose(prog_fd)\n ...\n bpf_prog_free_deferred\n  module_put(used_btf.mod) // use-after-free\n\nWe fix this issue by setting a flag BTF_MODULE_F_LIVE, from the notifier\ncallback when MODULE_STATE_LIVE state is reached for the module, so that\nwe return NULL from btf_try_get_module for modules that are not fully\nformed. Since try_module_get already checks that module is not in\nMODULE_STATE_GOING state, and that is the only transition a live module\ncan make before being removed from btf_modules list, this is enough to\nclose the race and prevent the bug.\n\nA later selftest patch crafts the race condition artifically to verify\nthat it has been fixed, and that verifier fails to load program (with\nENXIO).\n\nLastly, a couple of comments:\n\n 1. Even if this race didn't exist, it seems more appropriate to only\n    access resources (ksyms and kfuncs) of a fully formed module which\n    has been initialized completely.\n\n 2. This patch was born out of need for synchronization against module\n    initcall for the next patch, so it is needed for correctness even\n    without the aforementioned race condition. The BTF resources\n    initialized by module initcall are set up once and then only looked\n    up, so just waiting until the initcall has finished ensures correct\n    behavior."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf: Arreglar UAF debido a la ejecuci\u00f3n entre btf_try_get_module y load_module Mientras trabajaba en el c\u00f3digo para rellenar los conjuntos de ID de BTF de kfunc para el m\u00f3dulo BTF desde su initcall, not\u00e9 que para el momento en que se invoca la initcall, el espacio de usuario (y el verificador BPF) ya puede ver el m\u00f3dulo BTF. El btf_try_get_module existente llama a try_module_get, que solo falla si mod-&gt;state == MODULE_STATE_GOING, es decir, puede incrementar la referencia del m\u00f3dulo cuando la initcall del m\u00f3dulo est\u00e1 sucediendo en paralelo. Actualmente, el an\u00e1lisis de BTF ocurre desde la devoluci\u00f3n de llamada del notificador MODULE_STATE_COMING. En este punto, las initcalls del m\u00f3dulo no han sido invocadas. La devoluci\u00f3n de llamada del notificador analiza y prepara el m\u00f3dulo BTF, asigna un ID, que lo publica en el espacio de usuario y luego lo agrega a la lista btf_modules, lo que permite que el n\u00facleo invoque btf_try_get_module para el BTF. Sin embargo, en este punto, el m\u00f3dulo no se ha inicializado por completo (es decir, sus llamadas de inicio no han finalizado). El c\u00f3digo en module.c a\u00fan puede fallar y liberar el m\u00f3dulo, sin preocuparse por otros usuarios. Sin embargo, nada impide que btf_try_get_module tenga \u00e9xito entre la transici\u00f3n de estado de MODULE_STATE_COMING a MODULE_STATE_LIVE. Esto conduce a un problema de use-after-free cuando el programa BPF se carga correctamente en la transici\u00f3n de estado, la llamada do_init_module de load_module falla y libera el m\u00f3dulo, y el programa BPF fd al cerrar llama a module_put para el m\u00f3dulo liberado. El parche futuro tiene un caso de prueba para verificar que no retrocedamos en esta \u00e1rea en el futuro. Hay varios puntos despu\u00e9s de prepare_coming_module (en load_module) donde puede ocurrir un fallo y la carga del m\u00f3dulo puede devolver un error. Ilustramos y probamos la ejecuci\u00f3n usando el \u00faltimo punto donde puede ocurrir pr\u00e1cticamente (en la funci\u00f3n __init del m\u00f3dulo). Una ilustraci\u00f3n de la ejecuci\u00f3n: CPU 0 CPU 1 load_module notifier_call(MODULE_STATE_COMING) btf_parse_module btf_alloc_id // Publicado en el espacio de usuario list_add(&amp;btf_mod-&gt;list, btf_modules) mod-&gt;init(...) ... ^ bpf_check | check_pseudo_btf_id | btf_try_get_module | devuelve verdadero | ... ... | m\u00f3dulo __init en progreso devuelve prog_fd | ... ... V if (ret &lt; 0) free_module(mod) ... close(prog_fd) ... bpf_prog_free_deferred module_put(used_btf.mod) // use-after-free Solucionamos este problema estableciendo un indicador BTF_MODULE_F_LIVE, desde la devoluci\u00f3n de llamada del notificador cuando se alcanza el estado MODULE_STATE_LIVE para el m\u00f3dulo, de modo que devolvamos NULL desde btf_try_get_module para los m\u00f3dulos que no est\u00e1n completamente formados. Dado que try_module_get ya verifica que el m\u00f3dulo no est\u00e9 en el estado MODULE_STATE_GOING, y esa es la \u00fanica transici\u00f3n que un m\u00f3dulo activo puede hacer antes de ser eliminado de la lista btf_modules, esto es suficiente para cerrar la ejecuci\u00f3n y evitar el error. Un parche de autoprueba posterior crea la condici\u00f3n de ejecuci\u00f3n artificialmente para verificar que se ha solucionado, y que el verificador no puede cargar el programa (con ENXIO). Por \u00faltimo, un par de comentarios: 1. Incluso si esta ejecuci\u00f3n no existiera, parece m\u00e1s apropiado acceder solo a los recursos (ksyms y kfuncs) de un m\u00f3dulo completamente formado que se haya inicializado por completo. 2. Este parche naci\u00f3 de la necesidad de sincronizaci\u00f3n con el m\u00f3dulo initcall para el pr\u00f3ximo parche, por lo que es necesario para la correcci\u00f3n incluso sin la condici\u00f3n de ejecuci\u00f3n mencionada anteriormente. Los recursos BTF inicializados por el m\u00f3dulo initcall se configuran una vez y luego solo se buscan, por lo que simplemente esperar hasta que el initcall haya terminado garantiza un comportamiento correcto."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/0481baa2318cb1ab13277715da6cdbb657807b3f", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/18688de203b47e5d8d9d0953385bf30b5949324f", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/51b82141fffa454abf937a8ff0b8af89e4fd0c8f", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/d7fccf264b1a785525b366a5b7f8113c756187ad", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-416"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 5.9, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "baseScore": 7.8, "baseSeverity": "HIGH", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "02AF1052-DC50-47B3-B1DE-638E4BBDCCD1", "cpe_name": [], "versionStartIncluding": "5.12", "versionEndExcluding": "5.15.33"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "20C43679-0439-405A-B97F-685BEE50613B", "cpe_name": [], "versionStartIncluding": "5.16", "versionEndExcluding": "5.16.19"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "210C679C-CF84-44A3-8939-E629C87E54BF", "cpe_name": [], "versionStartIncluding": "5.17", "versionEndExcluding": "5.17.2"}]}]}}