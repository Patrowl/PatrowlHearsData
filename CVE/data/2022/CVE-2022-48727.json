{"cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "4.0", "CVE_data_meta": {"ID": "CVE-2022-48727", "ASSIGNER": "cve@kernel.org"}, "problemtype": {"problemtype_data": [{"description": []}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/1c71dbc8a179d99dd9bb7e7fc1888db613cf85de", "name": "https://git.kernel.org/stable/c/1c71dbc8a179d99dd9bb7e7fc1888db613cf85de", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/1c71dbc8a179d99dd9bb7e7fc1888db613cf85de", "name": "https://git.kernel.org/stable/c/1c71dbc8a179d99dd9bb7e7fc1888db613cf85de", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/57e2986c3b25092691a6e3d6ee9168caf8978932", "name": "https://git.kernel.org/stable/c/57e2986c3b25092691a6e3d6ee9168caf8978932", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/57e2986c3b25092691a6e3d6ee9168caf8978932", "name": "https://git.kernel.org/stable/c/57e2986c3b25092691a6e3d6ee9168caf8978932", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e1e852746997500f1873f60b954da5f02cc2dba3", "name": "https://git.kernel.org/stable/c/e1e852746997500f1873f60b954da5f02cc2dba3", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e1e852746997500f1873f60b954da5f02cc2dba3", "name": "https://git.kernel.org/stable/c/e1e852746997500f1873f60b954da5f02cc2dba3", "refsource": "", "tags": []}]}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: arm64: Avoid consuming a stale esr value when SError occur\n\nWhen any exception other than an IRQ occurs, the CPU updates the ESR_EL2\nregister with the exception syndrome. An SError may also become pending,\nand will be synchronised by KVM. KVM notes the exception type, and whether\nan SError was synchronised in exit_code.\n\nWhen an exception other than an IRQ occurs, fixup_guest_exit() updates\nvcpu->arch.fault.esr_el2 from the hardware register. When an SError was\nsynchronised, the vcpu esr value is used to determine if the exception\nwas due to an HVC. If so, ELR_EL2 is moved back one instruction. This\nis so that KVM can process the SError first, and re-execute the HVC if\nthe guest survives the SError.\n\nBut if an IRQ synchronises an SError, the vcpu's esr value is stale.\nIf the previous non-IRQ exception was an HVC, KVM will corrupt ELR_EL2,\ncausing an unrelated guest instruction to be executed twice.\n\nCheck ARM_EXCEPTION_CODE() before messing with ELR_EL2, IRQs don't\nupdate this register so don't need to check."}]}}, "configurations": {"CVE_data_version": "4.0", "nodes": []}, "impact": {}, "publishedDate": "2024-06-20T12:15Z", "lastModifiedDate": "2024-11-21T07:33Z"}