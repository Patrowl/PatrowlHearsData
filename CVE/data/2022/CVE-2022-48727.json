{"publishedDate": "2024-06-20T12:15Z", "lastModifiedDate": "2024-11-21T07:33Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-48727", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: arm64: Avoid consuming a stale esr value when SError occur\n\nWhen any exception other than an IRQ occurs, the CPU updates the ESR_EL2\nregister with the exception syndrome. An SError may also become pending,\nand will be synchronised by KVM. KVM notes the exception type, and whether\nan SError was synchronised in exit_code.\n\nWhen an exception other than an IRQ occurs, fixup_guest_exit() updates\nvcpu->arch.fault.esr_el2 from the hardware register. When an SError was\nsynchronised, the vcpu esr value is used to determine if the exception\nwas due to an HVC. If so, ELR_EL2 is moved back one instruction. This\nis so that KVM can process the SError first, and re-execute the HVC if\nthe guest survives the SError.\n\nBut if an IRQ synchronises an SError, the vcpu's esr value is stale.\nIf the previous non-IRQ exception was an HVC, KVM will corrupt ELR_EL2,\ncausing an unrelated guest instruction to be executed twice.\n\nCheck ARM_EXCEPTION_CODE() before messing with ELR_EL2, IRQs don't\nupdate this register so don't need to check."}, {"lang": "es", "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: KVM: arm64: Evite consumir un valor esr obsoleto cuando ocurre un SError Cuando ocurre cualquier excepci\u00f3n que no sea una IRQ, la CPU actualiza el registro ESR_EL2 con el s\u00edndrome de excepci\u00f3n. Un SError tambi\u00e9n puede quedar pendiente y KVM lo sincronizar\u00e1. KVM anota el tipo de excepci\u00f3n y si se sincroniz\u00f3 un SError en exit_code. Cuando ocurre una excepci\u00f3n distinta a una IRQ, fixup_guest_exit() actualiza vcpu-&gt;arch.fault.esr_el2 desde el registro de hardware. Cuando se sincroniza un SError, el valor de vcpu esr se utiliza para determinar si la excepci\u00f3n se debi\u00f3 a un HVC. Si es as\u00ed, ELR_EL2 retrocede una instrucci\u00f3n. Esto es para que KVM pueda procesar el SError primero y volver a ejecutar el HVC si el invitado sobrevive al SError. Pero si una IRQ sincroniza un SError, el valor esr de la vcpu est\u00e1 obsoleto. Si la excepci\u00f3n anterior no IRQ era un HVC, KVM da\u00f1ar\u00e1 ELR_EL2, lo que provocar\u00e1 que se ejecute dos veces una instrucci\u00f3n invitada no relacionada. Verifique ARM_EXCEPTION_CODE() antes de jugar con ELR_EL2, las IRQ no actualizan este registro, por lo que no es necesario verificarlo."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/1c71dbc8a179d99dd9bb7e7fc1888db613cf85de", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/57e2986c3b25092691a6e3d6ee9168caf8978932", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e1e852746997500f1873f60b954da5f02cc2dba3", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/1c71dbc8a179d99dd9bb7e7fc1888db613cf85de", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/57e2986c3b25092691a6e3d6ee9168caf8978932", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e1e852746997500f1873f60b954da5f02cc2dba3", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}