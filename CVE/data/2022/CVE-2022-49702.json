{"publishedDate": "2025-02-26T07:01Z", "lastModifiedDate": "2025-10-24T15:54Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-49702", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix hang during unmount when block group reclaim task is running\n\nWhen we start an unmount, at close_ctree(), if we have the reclaim task\nrunning and in the middle of a data block group relocation, we can trigger\na deadlock when stopping an async reclaim task, producing a trace like the\nfollowing:\n\n[629724.498185] task:kworker/u16:7   state:D stack:    0 pid:681170 ppid:     2 flags:0x00004000\n[629724.499760] Workqueue: events_unbound btrfs_async_reclaim_metadata_space [btrfs]\n[629724.501267] Call Trace:\n[629724.501759]  <TASK>\n[629724.502174]  __schedule+0x3cb/0xed0\n[629724.502842]  schedule+0x4e/0xb0\n[629724.503447]  btrfs_wait_on_delayed_iputs+0x7c/0xc0 [btrfs]\n[629724.504534]  ? prepare_to_wait_exclusive+0xc0/0xc0\n[629724.505442]  flush_space+0x423/0x630 [btrfs]\n[629724.506296]  ? rcu_read_unlock_trace_special+0x20/0x50\n[629724.507259]  ? lock_release+0x220/0x4a0\n[629724.507932]  ? btrfs_get_alloc_profile+0xb3/0x290 [btrfs]\n[629724.508940]  ? do_raw_spin_unlock+0x4b/0xa0\n[629724.509688]  btrfs_async_reclaim_metadata_space+0x139/0x320 [btrfs]\n[629724.510922]  process_one_work+0x252/0x5a0\n[629724.511694]  ? process_one_work+0x5a0/0x5a0\n[629724.512508]  worker_thread+0x52/0x3b0\n[629724.513220]  ? process_one_work+0x5a0/0x5a0\n[629724.514021]  kthread+0xf2/0x120\n[629724.514627]  ? kthread_complete_and_exit+0x20/0x20\n[629724.515526]  ret_from_fork+0x22/0x30\n[629724.516236]  </TASK>\n[629724.516694] task:umount          state:D stack:    0 pid:719055 ppid:695412 flags:0x00004000\n[629724.518269] Call Trace:\n[629724.518746]  <TASK>\n[629724.519160]  __schedule+0x3cb/0xed0\n[629724.519835]  schedule+0x4e/0xb0\n[629724.520467]  schedule_timeout+0xed/0x130\n[629724.521221]  ? lock_release+0x220/0x4a0\n[629724.521946]  ? lock_acquired+0x19c/0x420\n[629724.522662]  ? trace_hardirqs_on+0x1b/0xe0\n[629724.523411]  __wait_for_common+0xaf/0x1f0\n[629724.524189]  ? usleep_range_state+0xb0/0xb0\n[629724.524997]  __flush_work+0x26d/0x530\n[629724.525698]  ? flush_workqueue_prep_pwqs+0x140/0x140\n[629724.526580]  ? lock_acquire+0x1a0/0x310\n[629724.527324]  __cancel_work_timer+0x137/0x1c0\n[629724.528190]  close_ctree+0xfd/0x531 [btrfs]\n[629724.529000]  ? evict_inodes+0x166/0x1c0\n[629724.529510]  generic_shutdown_super+0x74/0x120\n[629724.530103]  kill_anon_super+0x14/0x30\n[629724.530611]  btrfs_kill_super+0x12/0x20 [btrfs]\n[629724.531246]  deactivate_locked_super+0x31/0xa0\n[629724.531817]  cleanup_mnt+0x147/0x1c0\n[629724.532319]  task_work_run+0x5c/0xa0\n[629724.532984]  exit_to_user_mode_prepare+0x1a6/0x1b0\n[629724.533598]  syscall_exit_to_user_mode+0x16/0x40\n[629724.534200]  do_syscall_64+0x48/0x90\n[629724.534667]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[629724.535318] RIP: 0033:0x7fa2b90437a7\n[629724.535804] RSP: 002b:00007ffe0b7e4458 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6\n[629724.536912] RAX: 0000000000000000 RBX: 00007fa2b9182264 RCX: 00007fa2b90437a7\n[629724.538156] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000555d6cf20dd0\n[629724.539053] RBP: 0000555d6cf20ba0 R08: 0000000000000000 R09: 00007ffe0b7e3200\n[629724.539956] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\n[629724.540883] R13: 0000555d6cf20dd0 R14: 0000555d6cf20cb0 R15: 0000000000000000\n[629724.541796]  </TASK>\n\nThis happens because:\n\n1) Before entering close_ctree() we have the async block group reclaim\n   task running and relocating a data block group;\n\n2) There's an async metadata (or data) space reclaim task running;\n\n3) We enter close_ctree() and park the cleaner kthread;\n\n4) The async space reclaim task is at flush_space() and runs all the\n   existing delayed iputs;\n\n5) Before the async space reclaim task calls\n   btrfs_wait_on_delayed_iputs(), the block group reclaim task which is\n   doing the data block group relocation, creates a delayed iput at\n   replace_file_extents() (called when COWing leaves that have file extent\n   items pointing to relocated data exten\n---truncated---"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: btrfs: se corrige un bloqueo durante el desmontaje cuando se est\u00e1 ejecutando la tarea de recuperaci\u00f3n del grupo de bloques Cuando iniciamos un desmontaje, en close_ctree(), si tenemos la tarea de recuperaci\u00f3n en ejecuci\u00f3n y estamos en medio de una reubicaci\u00f3n del grupo de bloques de datos, podemos provocar un bloqueo al detener una tarea de recuperaci\u00f3n as\u00edncrona, lo que produce un seguimiento como el siguiente: [629724.498185] task:kworker/u16:7 state:D stack: 0 pid:681170 ppid: 2 flags:0x00004000 [629724.499760] Workqueue: events_unbound btrfs_async_reclaim_metadata_space [btrfs] [629724.501267] Call Trace: [629724.501759]  [629724.502174] __schedule+0x3cb/0xed0 [629724.502842] schedule+0x4e/0xb0 [629724.503447] btrfs_wait_on_delayed_iputs+0x7c/0xc0 [btrfs] [629724.504534] ? prepare_to_wait_exclusive+0xc0/0xc0 [629724.505442] flush_space+0x423/0x630 [btrfs] [629724.506296] ? rcu_read_unlock_trace_special+0x20/0x50 [629724.507259] ? lock_release+0x220/0x4a0 [629724.507932] ? btrfs_get_alloc_profile+0xb3/0x290 [btrfs] [629724.508940] ? do_raw_spin_unlock+0x4b/0xa0 [629724.509688] btrfs_async_reclaim_metadata_space+0x139/0x320 [btrfs] [629724.510922] process_one_work+0x252/0x5a0 [629724.511694] ? process_one_work+0x5a0/0x5a0 [629724.512508] worker_thread+0x52/0x3b0 [629724.513220] ? process_one_work+0x5a0/0x5a0 [629724.514021] kthread+0xf2/0x120 [629724.514627] ? kthread_complete_and_exit+0x20/0x20 [629724.515526] ret_from_fork+0x22/0x30 [629724.516236]  [629724.516694] task:umount state:D stack: 0 pid:719055 ppid:695412 flags:0x00004000 [629724.518269] Call Trace: [629724.518746]  [629724.519160] __schedule+0x3cb/0xed0 [629724.519835] schedule+0x4e/0xb0 [629724.520467] schedule_timeout+0xed/0x130 [629724.521221] ? lock_release+0x220/0x4a0 [629724.521946] ? lock_acquired+0x19c/0x420 [629724.522662] ? trace_hardirqs_on+0x1b/0xe0 [629724.523411] __wait_for_common+0xaf/0x1f0 [629724.524189] ? usleep_range_state+0xb0/0xb0 [629724.524997] __flush_work+0x26d/0x530 [629724.525698] ? flush_workqueue_prep_pwqs+0x140/0x140 [629724.526580] ? lock_acquire+0x1a0/0x310 [629724.527324] __cancel_work_timer+0x137/0x1c0 [629724.528190] close_ctree+0xfd/0x531 [btrfs] [629724.529000] ? evict_inodes+0x166/0x1c0 [629724.529510] generic_shutdown_super+0x74/0x120 [629724.530103] kill_anon_super+0x14/0x30 [629724.530611] btrfs_kill_super+0x12/0x20 [btrfs] [629724.531246] deactivate_locked_super+0x31/0xa0 [629724.531817] cleanup_mnt+0x147/0x1c0 [629724.532319] task_work_run+0x5c/0xa0 [629724.532984] exit_to_user_mode_prepare+0x1a6/0x1b0 [629724.533598] syscall_exit_to_user_mode+0x16/0x40 [629724.534200] do_syscall_64+0x48/0x90 [629724.534667] entry_SYSCALL_64_after_hwframe+0x44/0xae [629724.535318] RIP: 0033:0x7fa2b90437a7 [629724.535804] RSP: 002b:00007ffe0b7e4458 EFLAGS: 00000246 ORIG_RAX: 00000000000000a6 [629724.536912] RAX: 0000000000000000 RBX: 00007fa2b9182264 RCX: 00007fa2b90437a7 [629724.538156] RDX: 0000000000000000 RSI: 0000000000000000 RDI: 0000555d6cf20dd0 [629724.539053] RBP: 0000555d6cf20ba0 R08: 0000000000000000 R09: 00007ffe0b7e3200 [629724.539956] R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000 [629724.540883] R13: 0000555d6cf20dd0 R14: 0000555d6cf20cb0 R15: 0000000000000000 [629724.541796]  Esto sucede porque: 1) Antes de ingresar a close_ctree() tenemos la tarea de recuperaci\u00f3n de grupo de bloques as\u00edncronos ejecut\u00e1ndose y reubicando un grupo de bloques de datos; 2) Hay una tarea de recuperaci\u00f3n de espacio de metadatos (o datos) as\u00edncronos ejecut\u00e1ndose; 3) Ingresamos a close_ctree() y estacionamos el kthread m\u00e1s limpio; 4) La tarea de recuperaci\u00f3n de espacio as\u00edncrona est\u00e1 en flush_space() y ejecuta todas las entradas retrasadas existentes; 5) Antes de que la tarea de recuperaci\u00f3n de espacio as\u00edncrona llame a btrfs_wait_on_delayed_iputs(), la tarea de recuperaci\u00f3n de grupo de bloques que est\u00e1 realizando la reubicaci\u00f3n del grupo de bloques de datos, crea una entrada  ---truncada---"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/31e70e527806c546a72262f2fc3d982ee23c42d3", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/341d33128a940c6634175dcb6ca92dc454cfa7d2", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/9fadb11f1295289e0da4d3342ecb6b92c1c99540", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-667"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "AA59AD4A-9F0B-4A17-9F76-4D464C6F1DDD", "cpe_name": [], "versionStartIncluding": "5.13", "versionEndExcluding": "5.15.51"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "0172D3FA-DDEB-482A-A270-4A1495A8798C", "cpe_name": [], "versionStartIncluding": "5.16", "versionEndExcluding": "5.18.8"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:5.19:rc1:*:*:*:*:*:*", "matchCriteriaId": "A8C30C2D-F82D-4D37-AB48-D76ABFBD5377", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:5.19:rc2:*:*:*:*:*:*", "matchCriteriaId": "BF8547FC-C849-4F1B-804B-A93AE2F04A92", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:5.19:rc3:*:*:*:*:*:*", "matchCriteriaId": "F3068028-F453-4A1C-B80F-3F5609ACEF60", "cpe_name": []}]}]}}