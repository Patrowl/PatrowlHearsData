{"publishedDate": "2025-06-18T11:15Z", "lastModifiedDate": "2025-06-18T13:47Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-50174", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: hinic: avoid kernel hung in hinic_get_stats64()\n\nWhen using hinic device as a bond slave device, and reading device stats\nof master bond device, the kernel may hung.\n\nThe kernel panic calltrace as follows:\nKernel panic - not syncing: softlockup: hung tasks\nCall trace:\n  native_queued_spin_lock_slowpath+0x1ec/0x31c\n  dev_get_stats+0x60/0xcc\n  dev_seq_printf_stats+0x40/0x120\n  dev_seq_show+0x1c/0x40\n  seq_read_iter+0x3c8/0x4dc\n  seq_read+0xe0/0x130\n  proc_reg_read+0xa8/0xe0\n  vfs_read+0xb0/0x1d4\n  ksys_read+0x70/0xfc\n  __arm64_sys_read+0x20/0x30\n  el0_svc_common+0x88/0x234\n  do_el0_svc+0x2c/0x90\n  el0_svc+0x1c/0x30\n  el0_sync_handler+0xa8/0xb0\n  el0_sync+0x148/0x180\n\nAnd the calltrace of task that actually caused kernel hungs as follows:\n  __switch_to+124\n  __schedule+548\n  schedule+72\n  schedule_timeout+348\n  __down_common+188\n  __down+24\n  down+104\n  hinic_get_stats64+44 [hinic]\n  dev_get_stats+92\n  bond_get_stats+172 [bonding]\n  dev_get_stats+92\n  dev_seq_printf_stats+60\n  dev_seq_show+24\n  seq_read_iter+964\n  seq_read+220\n  proc_reg_read+164\n  vfs_read+172\n  ksys_read+108\n  __arm64_sys_read+28\n  el0_svc_common+132\n  do_el0_svc+40\n  el0_svc+24\n  el0_sync_handler+164\n  el0_sync+324\n\nWhen getting device stats from bond, kernel will call bond_get_stats().\nIt first holds the spinlock bond->stats_lock, and then call\nhinic_get_stats64() to collect hinic device's stats.\nHowever, hinic_get_stats64() calls `down(&nic_dev->mgmt_lock)` to\nprotect its critical section, which may schedule current task out.\nAnd if system is under high pressure, the task cannot be woken up\nimmediately, which eventually triggers kernel hung panic.\n\nSince previous patch has replaced hinic_dev.tx_stats/rx_stats with local\nvariable in hinic_get_stats64(), there is nothing need to be protected\nby lock, so just removing down()/up() is ok."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net: hinic: evitar que el kernel se cuelgue en hinic_get_stats64(). Al usar un dispositivo hinic como un dispositivo esclavo de enlace y leer las estad\u00edsticas del dispositivo de enlace maestro, el kernel puede colgarse. El seguimiento de llamadas de p\u00e1nico del kernel es el siguiente: P\u00e1nico del kernel - no sincroniza: softlockup: tareas colgadas Seguimiento de llamadas: native_queued_spin_lock_slowpath+0x1ec/0x31c dev_get_stats+0x60/0xcc dev_seq_printf_stats+0x40/0x120 dev_seq_show+0x1c/0x40 seq_read_iter+0x3c8/0x4dc seq_read+0xe0/0x130 proc_reg_read+0xa8/0xe0 vfs_read+0xb0/0x1d4 ksys_read+0x70/0xfc __arm64_sys_read+0x20/0x30 el0_svc_common+0x88/0x234 do_el0_svc+0x2c/0x90 el0_svc+0x1c/0x30 el0_sync_handler+0xa8/0xb0 el0_sync+0x148/0x180 Y el seguimiento de llamadas de la tarea que realmente caus\u00f3 los bloqueos del kernel de la siguiente manera: __switch_to+124 __schedule+548 schedule+72 schedule_timeout+348 __down_common+188 __down+24 down+104 hinic_get_stats64+44 [hinic] dev_get_stats+92 bond_get_stats+172 [bonding] dev_get_stats+92 dev_seq_printf_stats+60 dev_seq_show+24 seq_read_iter+964 seq_read+220 proc_reg_read+164 vfs_read+172 ksys_read+108 __arm64_sys_read+28 el0_svc_common+132 do_el0_svc+40 el0_svc+24 el0_sync_handler+164 el0_sync+324 Al obtener las estad\u00edsticas del dispositivo desde Bond, el kernel llama a bond_get_stats(). Primero mantiene el bloqueo de giro bond-&gt;stats_lock y luego llama a hinic_get_stats64() para recopilar las estad\u00edsticas del dispositivo Hinic. Sin embargo, hinic_get_stats64() llama a `down(&amp;nic_dev-&gt;mgmt_lock)` para proteger su secci\u00f3n cr\u00edtica, que podr\u00eda programar la tarea actual. Si el sistema est\u00e1 bajo alta presi\u00f3n, la tarea no se puede reactivar inmediatamente, lo que eventualmente desencadena un p\u00e1nico de bloqueo del kernel. Dado que el parche anterior reemplaz\u00f3 hinic_dev.tx_stats/rx_stats con una variable local en hinic_get_stats64(), no es necesario proteger nada con bloqueo, por lo que simplemente eliminar down()/up() est\u00e1 bien."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/3ba59bbe4f306bb6ee15753db0a40564c0eb7909", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/693f31dc91568e61047fd2980a8235e856cd9ce8", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/98f9fcdee35add80505b6c73f72de5f750d5c03c", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e74f3097a9c713ce855cda07713393bcc23a005d", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/fced5bce712122654ec8a20356342698cce104d2", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}