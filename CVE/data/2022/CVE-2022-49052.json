{"publishedDate": "2025-02-26T07:00Z", "lastModifiedDate": "2025-02-26T07:00Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-49052", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm: fix unexpected zeroed page mapping with zram swap\n\nTwo processes under CLONE_VM cloning, user process can be corrupted by\nseeing zeroed page unexpectedly.\n\n      CPU A                        CPU B\n\n  do_swap_page                do_swap_page\n  SWP_SYNCHRONOUS_IO path     SWP_SYNCHRONOUS_IO path\n  swap_readpage valid data\n    swap_slot_free_notify\n      delete zram entry\n                              swap_readpage zeroed(invalid) data\n                              pte_lock\n                              map the *zero data* to userspace\n                              pte_unlock\n  pte_lock\n  if (!pte_same)\n    goto out_nomap;\n  pte_unlock\n  return and next refault will\n  read zeroed data\n\nThe swap_slot_free_notify is bogus for CLONE_VM case since it doesn't\nincrease the refcount of swap slot at copy_mm so it couldn't catch up\nwhether it's safe or not to discard data from backing device.  In the\ncase, only the lock it could rely on to synchronize swap slot freeing is\npage table lock.  Thus, this patch gets rid of the swap_slot_free_notify\nfunction.  With this patch, CPU A will see correct data.\n\n      CPU A                        CPU B\n\n  do_swap_page                do_swap_page\n  SWP_SYNCHRONOUS_IO path     SWP_SYNCHRONOUS_IO path\n                              swap_readpage original data\n                              pte_lock\n                              map the original data\n                              swap_free\n                                swap_range_free\n                                  bd_disk->fops->swap_slot_free_notify\n  swap_readpage read zeroed data\n                              pte_unlock\n  pte_lock\n  if (!pte_same)\n    goto out_nomap;\n  pte_unlock\n  return\n  on next refault will see mapped data by CPU B\n\nThe concern of the patch would increase memory consumption since it\ncould keep wasted memory with compressed form in zram as well as\nuncompressed form in address space.  However, most of cases of zram uses\nno readahead and do_swap_page is followed by swap_free so it will free\nthe compressed form from in zram quickly."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm: corregir la asignaci\u00f3n inesperada de p\u00e1ginas en cero con intercambio de zram Dos procesos bajo la clonaci\u00f3n CLONE_VM, el proceso del usuario puede corromperse al ver una p\u00e1gina en cero inesperadamente. CPU A CPU B do_swap_page do_swap_page SWP_SYNCHRONOUS_IO ruta SWP_SYNCHRONOUS_IO ruta swap_readpage datos v\u00e1lidos swap_slot_free_notify eliminar entrada zram swap_readpage datos cero (inv\u00e1lidos) pte_lock asigna los *datos cero* al espacio de usuario pte_unlock pte_lock if (!pte_same) goto out_nomap; pte_unlock return y el siguiente refault leer\u00e1 los datos en cero swap_slot_free_notify es falso para el caso de CLONE_VM ya que no aumenta el recuento de referencias de la ranura de intercambio en copy_mm, por lo que no podr\u00eda ponerse al d\u00eda si es seguro o no descartar datos del dispositivo de respaldo. En este caso, el \u00fanico bloqueo en el que podr\u00eda confiar para sincronizar la liberaci\u00f3n de la ranura de intercambio es el bloqueo de la tabla de p\u00e1ginas. Por lo tanto, este parche elimina la funci\u00f3n swap_slot_free_notify. Con este parche, la CPU A ver\u00e1 los datos correctos. CPU A CPU B do_swap_page do_swap_page SWP_SYNCHRONOUS_IO path SWP_SYNCHRONOUS_IO path swap_readpage original data pte_lock map the original data swap_free swap_range_free bd_disk-&gt;fops-&gt;swap_slot_free_notify swap_readpage read zeroed data pte_unlock pte_lock if (!pte_same) goto out_nomap; pte_unlock return on next refault ver\u00e1 los datos mapeados por la CPU B La preocupaci\u00f3n del parche aumentar\u00eda el consumo de memoria ya que podr\u00eda mantener la memoria desperdiciada con forma comprimida en zram as\u00ed como forma sin comprimir en el espacio de direcciones. Sin embargo, la mayor\u00eda de los casos de zram no utilizan lectura anticipada y do_swap_page es seguido por swap_free por lo que liberar\u00e1 el formato comprimido de zram r\u00e1pidamente."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/12ba1d38115a101c45d8e0ca3aa1181fd148e57f", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/20ed94f8181a25212e7404e44958e234f407624b", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/afac4b88699a06c8b9369f9d759a1ec3c254b788", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e914d8f00391520ecc4495dd0ca0124538ab7119", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f098f8b9820fe3f2e41aefc4329dfe8a3859d1c1", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f86d55cf616199404c05f5b0c5c41b17351baa02", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}