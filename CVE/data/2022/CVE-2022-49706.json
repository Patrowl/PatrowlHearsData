{"publishedDate": "2025-02-26T07:01Z", "lastModifiedDate": "2025-10-24T15:54Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2022-49706", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nzonefs: fix zonefs_iomap_begin() for reads\n\nIf a readahead is issued to a sequential zone file with an offset\nexactly equal to the current file size, the iomap type is set to\nIOMAP_UNWRITTEN, which will prevent an IO, but the iomap length is\ncalculated as 0. This causes a WARN_ON() in iomap_iter():\n\n[17309.548939] WARNING: CPU: 3 PID: 2137 at fs/iomap/iter.c:34 iomap_iter+0x9cf/0xe80\n[...]\n[17309.650907] RIP: 0010:iomap_iter+0x9cf/0xe80\n[...]\n[17309.754560] Call Trace:\n[17309.757078]  <TASK>\n[17309.759240]  ? lock_is_held_type+0xd8/0x130\n[17309.763531]  iomap_readahead+0x1a8/0x870\n[17309.767550]  ? iomap_read_folio+0x4c0/0x4c0\n[17309.771817]  ? lockdep_hardirqs_on_prepare+0x400/0x400\n[17309.778848]  ? lock_release+0x370/0x750\n[17309.784462]  ? folio_add_lru+0x217/0x3f0\n[17309.790220]  ? reacquire_held_locks+0x4e0/0x4e0\n[17309.796543]  read_pages+0x17d/0xb60\n[17309.801854]  ? folio_add_lru+0x238/0x3f0\n[17309.807573]  ? readahead_expand+0x5f0/0x5f0\n[17309.813554]  ? policy_node+0xb5/0x140\n[17309.819018]  page_cache_ra_unbounded+0x27d/0x450\n[17309.825439]  filemap_get_pages+0x500/0x1450\n[17309.831444]  ? filemap_add_folio+0x140/0x140\n[17309.837519]  ? lock_is_held_type+0xd8/0x130\n[17309.843509]  filemap_read+0x28c/0x9f0\n[17309.848953]  ? zonefs_file_read_iter+0x1ea/0x4d0 [zonefs]\n[17309.856162]  ? trace_contention_end+0xd6/0x130\n[17309.862416]  ? __mutex_lock+0x221/0x1480\n[17309.868151]  ? zonefs_file_read_iter+0x166/0x4d0 [zonefs]\n[17309.875364]  ? filemap_get_pages+0x1450/0x1450\n[17309.881647]  ? __mutex_unlock_slowpath+0x15e/0x620\n[17309.888248]  ? wait_for_completion_io_timeout+0x20/0x20\n[17309.895231]  ? lock_is_held_type+0xd8/0x130\n[17309.901115]  ? lock_is_held_type+0xd8/0x130\n[17309.906934]  zonefs_file_read_iter+0x356/0x4d0 [zonefs]\n[17309.913750]  new_sync_read+0x2d8/0x520\n[17309.919035]  ? __x64_sys_lseek+0x1d0/0x1d0\n\nFurthermore, this causes iomap_readahead() to loop forever as\niomap_readahead_iter() always returns 0, making no progress.\n\nFix this by treating reads after the file size as access to holes,\nsetting the iomap type to IOMAP_HOLE, the iomap addr to IOMAP_NULL_ADDR\nand using the length argument as is for the iomap length. To simplify\nthe code with this change, zonefs_iomap_begin() is split into the read\nvariant, zonefs_read_iomap_begin() and zonefs_read_iomap_ops, and the\nwrite variant, zonefs_write_iomap_begin() and zonefs_write_iomap_ops."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: zonefs: correcci\u00f3n de zonefs_iomap_begin() para lecturas Si se emite una lectura anticipada a un archivo de zona secuencial con un desplazamiento exactamente igual al tama\u00f1o de archivo actual, el tipo de iomap se establece en IOMAP_UNWRITTEN, lo que evitar\u00e1 una IO, pero la longitud de iomap se calcula como 0. Esto provoca un WARN_ON() in iomap_iter(): [17309.548939] WARNING: CPU: 3 PID: 2137 at fs/iomap/iter.c:34 iomap_iter+0x9cf/0xe80 [...] [17309.650907] RIP: 0010:iomap_iter+0x9cf/0xe80 [...] [17309.754560] Call Trace: [17309.757078]  [17309.759240] ? lock_is_held_type+0xd8/0x130 [17309.763531] iomap_readahead+0x1a8/0x870 [17309.767550] ? iomap_read_folio+0x4c0/0x4c0 [17309.771817] ? lockdep_hardirqs_on_prepare+0x400/0x400 [17309.778848] ? lock_release+0x370/0x750 [17309.784462] ? folio_add_lru+0x217/0x3f0 [17309.790220] ? reacquire_held_locks+0x4e0/0x4e0 [17309.796543] read_pages+0x17d/0xb60 [17309.801854] ? folio_add_lru+0x238/0x3f0 [17309.807573] ? readahead_expand+0x5f0/0x5f0 [17309.813554] ? policy_node+0xb5/0x140 [17309.819018] page_cache_ra_unbounded+0x27d/0x450 [17309.825439] filemap_get_pages+0x500/0x1450 [17309.831444] ? filemap_add_folio+0x140/0x140 [17309.837519] ? lock_is_held_type+0xd8/0x130 [17309.843509] filemap_read+0x28c/0x9f0 [17309.848953] ? zonefs_file_read_iter+0x1ea/0x4d0 [zonefs] [17309.856162] ? trace_contention_end+0xd6/0x130 [17309.862416] ? __mutex_lock+0x221/0x1480 [17309.868151] ? zonefs_file_read_iter+0x166/0x4d0 [zonefs] [17309.875364] ? filemap_get_pages+0x1450/0x1450 [17309.881647] ? __mutex_unlock_slowpath+0x15e/0x620 [17309.888248] ? wait_for_completion_io_timeout+0x20/0x20 [17309.895231] ? lock_is_held_type+0xd8/0x130 [17309.901115] ? lock_is_held_type+0xd8/0x130 [17309.906934] zonefs_file_read_iter+0x356/0x4d0 [zonefs] [17309.913750] new_sync_read+0x2d8/0x520 [17309.919035] ? __x64_sys_lseek+0x1d0/0x1d0 Furthermore, this causes iomap_readahead() se repita eternamente, ya que iomap_readahead_iter() siempre devuelve 0, sin realizar ning\u00fan progreso. Solucione esto tratando las lecturas posteriores al tama\u00f1o del archivo como accesos a agujeros, configurando el tipo de iomap en IOMAP_HOLE, la direcci\u00f3n de iomap en IOMAP_NULL_ADDR y utilizando el argumento length tal como est\u00e1 para la longitud de iomap. Para simplificar el c\u00f3digo con este cambio, zonefs_iomap_begin() se divide en la variante de lectura, zonefs_read_iomap_begin() y zonefs_read_iomap_ops, y la variante de escritura, zonefs_write_iomap_begin() y zonefs_write_iomap_ops."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/355be6131164c5bacf2e810763835aecb6e01fcb", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/3a7f05f104347b407e865c10be2675cd833a4e48", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/c1c1204c0d0c1dccc1310b9277fb2bd8b663d8fe", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/c2f71b9bb398e2e573bdc2574149f42b45efe410", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-125"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 5.2, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "baseScore": 7.1, "baseSeverity": "HIGH", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "7092FE15-7FCF-4C94-B887-B5E7A340C8B6", "cpe_name": [], "versionStartIncluding": "5.6", "versionEndExcluding": "5.10.125"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "43559D01-D3F1-48ED-BC00-E40BB8685772", "cpe_name": [], "versionStartIncluding": "5.11", "versionEndExcluding": "5.15.50"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "8C5E811A-2D6D-4B65-9BD9-C9F7F5C07F92", "cpe_name": [], "versionStartIncluding": "5.16", "versionEndExcluding": "5.18.7"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:5.19:rc1:*:*:*:*:*:*", "matchCriteriaId": "A8C30C2D-F82D-4D37-AB48-D76ABFBD5377", "cpe_name": []}]}]}}