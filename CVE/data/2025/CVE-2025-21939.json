{"publishedDate": "2025-04-01T16:15Z", "lastModifiedDate": "2025-04-01T20:26Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-21939", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ndrm/xe/hmm: Don't dereference struct page pointers without notifier lock\n\nThe pnfs that we obtain from hmm_range_fault() point to pages that\nwe don't have a reference on, and the guarantee that they are still\nin the cpu page-tables is that the notifier lock must be held and the\nnotifier seqno is still valid.\n\nSo while building the sg table and marking the pages accesses / dirty\nwe need to hold this lock with a validated seqno.\n\nHowever, the lock is reclaim tainted which makes\nsg_alloc_table_from_pages_segment() unusable, since it internally\nallocates memory.\n\nInstead build the sg-table manually. For the non-iommu case\nthis might lead to fewer coalesces, but if that's a problem it can\nbe fixed up later in the resource cursor code. For the iommu case,\nthe whole sg-table may still be coalesced to a single contigous\ndevice va region.\n\nThis avoids marking pages that we don't own dirty and accessed, and\nit also avoid dereferencing struct pages that we don't own.\n\nv2:\n- Use assert to check whether hmm pfns are valid (Matthew Auld)\n- Take into account that large pages may cross range boundaries\n  (Matthew Auld)\n\nv3:\n- Don't unnecessarily check for a non-freed sg-table. (Matthew Auld)\n- Add a missing up_read() in an error path. (Matthew Auld)\n\n(cherry picked from commit ea3e66d280ce2576664a862693d1da8fd324c317)"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: drm/xe/hmm: No desreferenciar punteros de p\u00e1gina de estructura sin bloqueo de notificador Los pnfs que obtenemos de hmm_range_fault() apuntan a p\u00e1ginas en las que no tenemos una referencia, y la garant\u00eda de que a\u00fan est\u00e1n en las tablas de p\u00e1ginas de la CPU es que el bloqueo del notificador debe mantenerse y el seqno del notificador a\u00fan es v\u00e1lido. Entonces, mientras construimos la tabla sg y marcamos las p\u00e1ginas como accedidas/sucias, necesitamos mantener este bloqueo con un seqno validado. Sin embargo, el bloqueo est\u00e1 contaminado por recuperaci\u00f3n, lo que hace que sg_alloc_table_from_pages_segment() sea inutilizable, ya que asigna memoria internamente. En su lugar, construya la tabla sg manualmente. Para el caso que no es iommu, esto podr\u00eda llevar a menos coalescencias, pero si eso es un problema, se puede arreglar m\u00e1s adelante en el c\u00f3digo del cursor de recursos. En el caso de iommu, toda la tabla sg puede fusionarse en una \u00fanica regi\u00f3n va de dispositivo contiguo. Esto evita marcar p\u00e1ginas que no son de nuestra propiedad como sucias y accedidas, y tambi\u00e9n evita desreferenciar p\u00e1ginas de estructura que no son de nuestra propiedad. v2: - Usar assert para comprobar si las funciones de funci\u00f3n de enlace de hmm son v\u00e1lidas (Matthew Auld). - Tener en cuenta que las p\u00e1ginas grandes pueden cruzar los l\u00edmites de rango (Matthew Auld). v3: - No comprobar innecesariamente si hay una tabla sg no liberada (Matthew Auld). - A\u00f1adir una funci\u00f3n up_read() faltante en una ruta de error (Matthew Auld). (Seleccionado de el commit ea3e66d280ce2576664a862693d1da8fd324c317)."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/0a98219bcc961edd3388960576e4353e123b4a51", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/2a24c98f0e4cc994334598d4f3a851972064809d", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f9326f529da7298a95643c3267f1c0fdb0db55eb", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}