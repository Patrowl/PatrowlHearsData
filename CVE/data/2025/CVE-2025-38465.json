{"publishedDate": "2025-07-25T16:15Z", "lastModifiedDate": "2025-07-29T14:14Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-38465", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetlink: Fix wraparounds of sk->sk_rmem_alloc.\n\nNetlink has this pattern in some places\n\n  if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)\n  \tatomic_add(skb->truesize, &sk->sk_rmem_alloc);\n\n, which has the same problem fixed by commit 5a465a0da13e (\"udp:\nFix multiple wraparounds of sk->sk_rmem_alloc.\").\n\nFor example, if we set INT_MAX to SO_RCVBUFFORCE, the condition\nis always false as the two operands are of int.\n\nThen, a single socket can eat as many skb as possible until OOM\nhappens, and we can see multiple wraparounds of sk->sk_rmem_alloc.\n\nLet's fix it by using atomic_add_return() and comparing the two\nvariables as unsigned int.\n\nBefore:\n  [root@fedora ~]# ss -f netlink\n  Recv-Q      Send-Q Local Address:Port                Peer Address:Port\n  -1668710080 0               rtnl:nl_wraparound/293               *\n\nAfter:\n  [root@fedora ~]# ss -f netlink\n  Recv-Q     Send-Q Local Address:Port                Peer Address:Port\n  2147483072 0               rtnl:nl_wraparound/290               *\n  ^\n  `--- INT_MAX - 576"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: netlink: Se corrigen los wraparounds de sk-&gt;sk_rmem_alloc. Netlink presenta este patr\u00f3n en algunos lugares if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf) atomic_add(skb-&gt;truesize, &amp;sk-&gt;sk_rmem_alloc); , que presenta el mismo problema corregido por el commit 5a465a0da13e (\"udp: Se corrigen m\u00faltiples wraparounds de sk-&gt;sk_rmem_alloc.\"). Por ejemplo, si establecemos INT_MAX en SO_RCVBUFFORCE, la condici\u00f3n siempre es falsa, ya que los dos operandos son de tipo int. En ese caso, un solo socket puede consumir tantos skb como sea posible hasta que se produzca un OOM, y podemos observar m\u00faltiples wraparounds de sk-&gt;sk_rmem_alloc. Para solucionarlo, usemos atomic_add_return() y comparemos las dos variables como enteros sin signo. Antes: [root@fedora ~]# ss -f netlink Recv-Q Send-Q Direcci\u00f3n local: Puerto Direcci\u00f3n del par: Puerto -1668710080 0 rtnl:nl_wraparound/293 * Despu\u00e9s: [root@fedora ~]# ss -f netlink Recv-Q Send-Q Direcci\u00f3n local: Puerto Direcci\u00f3n del par: Puerto 2147483072 0 rtnl:nl_wraparound/290 * ^ `--- INT_MAX - 576"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/4b8e18af7bea92f8b7fb92d40aeae729209db250", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/55baecb9eb90238f60a8350660d6762046ebd3bd", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/76602d8e13864524382b0687dc32cd8f19164d5a", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/9da025150b7c14a8390fc06aea314c0a4011e82c", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/ae8f160e7eb24240a2a79fc4c815c6a0d4ee16cc", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/c4ceaac5c5ba0b992ee1dc88e2a02421549e5c98", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/cd7ff61bfffd7000143c42bbffb85eeb792466d6", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/fd69af06101090eaa60b3d216ae715f9c0a58e5b", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}