{"publishedDate": "2025-04-01T16:15Z", "lastModifiedDate": "2025-10-01T18:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-21951", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbus: mhi: host: pci_generic: Use pci_try_reset_function() to avoid deadlock\n\nThere are multiple places from where the recovery work gets scheduled\nasynchronously. Also, there are multiple places where the caller waits\nsynchronously for the recovery to be completed. One such place is during\nthe PM shutdown() callback.\n\nIf the device is not alive during recovery_work, it will try to reset the\ndevice using pci_reset_function(). This function internally will take the\ndevice_lock() first before resetting the device. By this time, if the lock\nhas already been acquired, then recovery_work will get stalled while\nwaiting for the lock. And if the lock was already acquired by the caller\nwhich waits for the recovery_work to be completed, it will lead to\ndeadlock.\n\nThis is what happened on the X1E80100 CRD device when the device died\nbefore shutdown() callback. Driver core calls the driver's shutdown()\ncallback while holding the device_lock() leading to deadlock.\n\nAnd this deadlock scenario can occur on other paths as well, like during\nthe PM suspend() callback, where the driver core would hold the\ndevice_lock() before calling driver's suspend() callback. And if the\nrecovery_work was already started, it could lead to deadlock. This is also\nobserved on the X1E80100 CRD.\n\nSo to fix both issues, use pci_try_reset_function() in recovery_work. This\nfunction first checks for the availability of the device_lock() before\ntrying to reset the device. If the lock is available, it will acquire it\nand reset the device. Otherwise, it will return -EAGAIN. If that happens,\nrecovery_work will fail with the error message \"Recovery failed\" as not\nmuch could be done."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bus: mhi: host: pci_generic: Use pci_try_reset_function() para evitar el interbloqueo Hay varios lugares desde donde el trabajo de recuperaci\u00f3n se programa de forma as\u00edncrona. Adem\u00e1s, hay varios lugares donde el llamador espera de forma s\u00edncrona a que se complete la recuperaci\u00f3n. Uno de esos lugares es durante la devoluci\u00f3n de llamada de PM shutdown(). Si el dispositivo no est\u00e1 activo durante recovery_work, intentar\u00e1 reiniciar el dispositivo utilizando pci_reset_function(). Esta funci\u00f3n tomar\u00e1 internamente primero device_lock() antes de reiniciar el dispositivo. En este momento, si el bloqueo ya se ha adquirido, entonces recovery_work se detendr\u00e1 mientras espera el bloqueo. Y si el bloqueo ya fue adquirido por el llamador que espera a que se complete recovery_work, provocar\u00e1 un interbloqueo. Esto es lo que ocurri\u00f3 en el dispositivo X1E80100 CRD cuando el dispositivo muri\u00f3 antes de la devoluci\u00f3n de llamada de shutdown(). El n\u00facleo del controlador llama a la devoluci\u00f3n de llamada de apagado () del controlador mientras mantiene el device_lock(), lo que provoca un interbloqueo. Este bloqueo tambi\u00e9n puede ocurrir en otras rutas, como durante la devoluci\u00f3n de llamada suspend() de PM, donde el n\u00facleo del controlador mantendr\u00eda el bloqueo_de_dispositivo() antes de llamar a la devoluci\u00f3n de llamada suspend() del controlador. Si el trabajo de recuperaci\u00f3n ya se hab\u00eda iniciado, podr\u00eda provocar un bloqueo. Esto tambi\u00e9n se observa en el CRD X1E80100. Para solucionar ambos problemas, utilice pci_try_reset_function() en el trabajo de recuperaci\u00f3n. Esta funci\u00f3n primero comprueba la disponibilidad del bloqueo_de_dispositivo() antes de intentar reiniciar el dispositivo. Si el bloqueo est\u00e1 disponible, lo adquirir\u00e1 y reiniciar\u00e1 el dispositivo. De lo contrario, devolver\u00e1 -EAGAIN. En este caso, el trabajo de recuperaci\u00f3n fallar\u00e1 con el mensaje de error \"Error de recuperaci\u00f3n\", ya que no se pudo hacer mucho."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/1f9eb7078bc6b5fb5cbfbcb37c4bc01685332b95", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/62505657475c245c9cd46e42ac01026d1e61f027", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/7746f3bb8917fccb4571a576f3837d80fc513054", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/7a5ffadd54fe2662f5c99cdccf30144d060376f7", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/985d3cf56d8745ca637deee273929e01df449f85", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/a321d163de3d8aa38a6449ab2becf4b1581aed96", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-667"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "F8D59378-B1BE-4F89-B688-A1FCE28B723F", "cpe_name": [], "versionStartIncluding": "5.12", "versionEndExcluding": "5.15.179"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "BA9C2DE3-D37C-46C6-8DCD-2EE509456E0B", "cpe_name": [], "versionStartIncluding": "5.16", "versionEndExcluding": "6.1.131"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "7D9F642F-6E05-4926-B0FE-62F95B7266BC", "cpe_name": [], "versionStartIncluding": "6.2", "versionEndExcluding": "6.6.83"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "32865E5C-8AE1-4D3D-A64D-299039694A88", "cpe_name": [], "versionStartIncluding": "6.7", "versionEndExcluding": "6.12.19"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "842F5A44-3E71-4546-B4FD-43B0ACE3F32B", "cpe_name": [], "versionStartIncluding": "6.13", "versionEndExcluding": "6.13.7"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*", "matchCriteriaId": "186716B6-2B66-4BD0-852E-D48E71C0C85F", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*", "matchCriteriaId": "0D3E781C-403A-498F-9DA9-ECEE50F41E75", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*", "matchCriteriaId": "66619FB8-0AAF-4166-B2CF-67B24143261D", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.14:rc4:*:*:*:*:*:*", "matchCriteriaId": "D3D6550E-6679-4560-902D-AF52DCFE905B", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.14:rc5:*:*:*:*:*:*", "matchCriteriaId": "45B90F6B-BEC7-4D4E-883A-9DBADE021750", "cpe_name": []}]}]}}