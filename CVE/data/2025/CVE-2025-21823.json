{"publishedDate": "2025-02-27T20:16Z", "lastModifiedDate": "2025-03-13T13:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-21823", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbatman-adv: Drop unmanaged ELP metric worker\n\nThe ELP worker needs to calculate new metric values for all neighbors\n\"reachable\" over an interface. Some of the used metric sources require\nlocks which might need to sleep. This sleep is incompatible with the RCU\nlist iterator used for the recorded neighbors. The initial approach to work\naround of this problem was to queue another work item per neighbor and then\nrun this in a new context.\n\nEven when this solved the RCU vs might_sleep() conflict, it has a major\nproblems: Nothing was stopping the work item in case it is not needed\nanymore - for example because one of the related interfaces was removed or\nthe batman-adv module was unloaded - resulting in potential invalid memory\naccesses.\n\nDirectly canceling the metric worker also has various problems:\n\n* cancel_work_sync for a to-be-deactivated interface is called with\n  rtnl_lock held. But the code in the ELP metric worker also tries to use\n  rtnl_lock() - which will never return in this case. This also means that\n  cancel_work_sync would never return because it is waiting for the worker\n  to finish.\n* iterating over the neighbor list for the to-be-deactivated interface is\n  currently done using the RCU specific methods. Which means that it is\n  possible to miss items when iterating over it without the associated\n  spinlock - a behaviour which is acceptable for a periodic metric check\n  but not for a cleanup routine (which must \"stop\" all still running\n  workers)\n\nThe better approch is to get rid of the per interface neighbor metric\nworker and handle everything in the interface worker. The original problems\nare solved by:\n\n* creating a list of neighbors which require new metric information inside\n  the RCU protected context, gathering the metric according to the new list\n  outside the RCU protected context\n* only use rcu_trylock inside metric gathering code to avoid a deadlock\n  when the cancel_delayed_work_sync is called in the interface removal code\n  (which is called with the rtnl_lock held)"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: batman-adv: eliminar un trabajador de m\u00e9tricas ELP no administrado El trabajador ELP necesita calcular nuevos valores de m\u00e9tricas para todos los vecinos \"alcanzables\" a trav\u00e9s de una interfaz. Algunas de las fuentes de m\u00e9tricas utilizadas requieren bloqueos que podr\u00edan necesitar dormir. Esta suspensi\u00f3n es incompatible con el iterador de lista RCU utilizado para los vecinos registrados. El enfoque inicial para solucionar este problema fue poner en cola otro elemento de trabajo por vecino y luego ejecutarlo en un nuevo contexto. Incluso cuando esto resolvi\u00f3 el conflicto RCU vs might_sleep(), tiene un problema importante: nada deten\u00eda el elemento de trabajo en caso de que ya no fuera necesario, por ejemplo, porque se elimin\u00f3 una de las interfaces relacionadas o se descarg\u00f3 el m\u00f3dulo batman-adv, lo que result\u00f3 en posibles accesos de memoria no v\u00e1lidos. Cancelar directamente el trabajador de m\u00e9tricas tambi\u00e9n tiene varios problemas: * cancel_work_sync para una interfaz que se desactivar\u00e1 se llama con rtnl_lock retenido. Pero el c\u00f3digo en el trabajador de m\u00e9tricas ELP tambi\u00e9n intenta usar rtnl_lock() - que nunca regresar\u00e1 en este caso. Esto tambi\u00e9n significa que cancel_work_sync nunca regresar\u00eda porque est\u00e1 esperando que el trabajador termine. * iterar sobre la lista de vecinos para la interfaz que se va a desactivar se realiza actualmente utilizando los m\u00e9todos espec\u00edficos de RCU. Lo que significa que es posible omitir elementos al iterarla sin el spinlock asociado - un comportamiento que es aceptable para una verificaci\u00f3n peri\u00f3dica de m\u00e9tricas pero no para una rutina de limpieza (que debe \"detener\" todos los trabajadores que a\u00fan se est\u00e1n ejecutando) El mejor enfoque es deshacerse del trabajador de m\u00e9tricas de vecinos por interfaz y manejar todo en el trabajador de interfaz. Los problemas originales se resuelven: * creando una lista de vecinos que requieren nueva informaci\u00f3n m\u00e9trica dentro del contexto protegido de RCU, recopilando la m\u00e9trica de acuerdo con la nueva lista fuera del contexto protegido de RCU * solo use rcu_trylock dentro del c\u00f3digo de recopilaci\u00f3n de m\u00e9tricas para evitar un bloqueo cuando se llama a cancel_delayed_work_sync en el c\u00f3digo de eliminaci\u00f3n de interfaz (que se llama con rtnl_lock retenido)"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/0fdc3c166ac17b26014313fa2b93696354511b24", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/1c334629176c2d644befc31a20d4bf75542f7631", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/3c0e0aecb78cb2a2ca1dc701982d08fedb088dc6", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/781a06fd265a8151f7601122d9c2e985663828ff", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/8c8ecc98f5c65947b0070a24bac11e12e47cc65d", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/a0019971f340ae02ba54cf1861f72da7e03e6b66", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/a7aa2317285806640c844acd4cd2cd768e395264", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/af264c2a9adc37f4bdf88ca7f3affa15d8c7de9e", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}