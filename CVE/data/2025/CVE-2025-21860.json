{"publishedDate": "2025-03-12T10:15Z", "lastModifiedDate": "2025-04-16T19:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-21860", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/zswap: fix inconsistency when zswap_store_page() fails\n\nCommit b7c0ccdfbafd (\"mm: zswap: support large folios in zswap_store()\")\nskips charging any zswap entries when it failed to zswap the entire folio.\n\nHowever, when some base pages are zswapped but it failed to zswap the\nentire folio, the zswap operation is rolled back.  When freeing zswap\nentries for those pages, zswap_entry_free() uncharges the zswap entries\nthat were not previously charged, causing zswap charging to become\ninconsistent.\n\nThis inconsistency triggers two warnings with following steps:\n  # On a machine with 64GiB of RAM and 36GiB of zswap\n  $ stress-ng --bigheap 2 # wait until the OOM-killer kills stress-ng\n  $ sudo reboot\n\n  The two warnings are:\n    in mm/memcontrol.c:163, function obj_cgroup_release():\n      WARN_ON_ONCE(nr_bytes & (PAGE_SIZE - 1));\n\n    in mm/page_counter.c:60, function page_counter_cancel():\n      if (WARN_ONCE(new < 0, \"page_counter underflow: %ld nr_pages=%lu\\n\",\n\t  new, nr_pages))\n\nzswap_stored_pages also becomes inconsistent in the same way.\n\nAs suggested by Kanchana, increment zswap_stored_pages and charge zswap\nentries within zswap_store_page() when it succeeds.  This way,\nzswap_entry_free() will decrement the counter and uncharge the entries\nwhen it failed to zswap the entire folio.\n\nWhile this could potentially be optimized by batching objcg charging and\nincrementing the counter, let's focus on fixing the bug this time and\nleave the optimization for later after some evaluation.\n\nAfter resolving the inconsistency, the warnings disappear.\n\n[42.hyeyoo@gmail.com: refactor zswap_store_page()]"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm/zswap: se corrige una inconsistencia al fallar zswap_store_page(). El commit b7c0ccdfbafd (\"mm: zswap: admite folios grandes en zswap_store()\") omite el cobro de las entradas zswap cuando no se logra el cobro de todo el folio. Sin embargo, cuando se realizan cobros de algunas p\u00e1ginas base, pero no se logra el cobro de todo el folio, la operaci\u00f3n de cobro se revierte. Al liberar las entradas zswap de esas p\u00e1ginas, zswap_entry_free() descarga las entradas zswap que no se hab\u00edan cargado previamente, lo que provoca que el cobro de zswap se vuelva inconsistente. Esta inconsistencia activa dos advertencias con los siguientes pasos: # En una m\u00e1quina con 64 GiB de RAM y 36 GiB de zswap $ stress-ng --bigheap 2 # esperar hasta que OOM-killer elimine stress-ng $ sudo reboot Las dos advertencias son: en mm/memcontrol.c:163, funci\u00f3n obj_cgroup_release(): WARN_ON_ONCE(nr_bytes &amp; (PAGE_SIZE - 1)); en mm/page_counter.c:60, funci\u00f3n page_counter_cancel(): if (WARN_ONCE(new &lt; 0, \"page_counter underflow: %ld nr_pages=%lu\\n\", new, nr_pages)) zswap_stored_pages tambi\u00e9n se vuelve inconsistente de la misma manera. Como sugiri\u00f3 Kanchana, incremente zswap_stored_pages y cargue las entradas zswap dentro de zswap_store_page() cuando tenga \u00e9xito. De esta forma, zswap_entry_free() decrementar\u00e1 el contador y descargar\u00e1 las entradas cuando no pueda intercambiar todo el folio con zswap. Si bien esto podr\u00eda optimizarse agrupando la carga de objcg e incrementando el contador, centr\u00e9monos en corregir el error esta vez y dejemos la optimizaci\u00f3n para m\u00e1s adelante, tras una evaluaci\u00f3n. Tras resolver la inconsistencia, las advertencias desaparecen. [42.hyeyoo@gmail.com: refactorizar zswap_store_page()] Enlace: https://lkml.kernel.org/r/20250131082037.2426-1-42.hyeyoo@gmail.com"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/63895d20d63b446f5049a963983489319c2ea3e2", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/a3652f5552b20903315612da487a7be2b95394d5", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 1.4, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:L", "baseScore": 3.3, "baseSeverity": "LOW", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "72E69ABB-9015-43A6-87E1-5150383CFFD9", "cpe_name": [], "versionStartIncluding": "6.13", "versionEndExcluding": "6.13.5"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.14:rc1:*:*:*:*:*:*", "matchCriteriaId": "186716B6-2B66-4BD0-852E-D48E71C0C85F", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.14:rc2:*:*:*:*:*:*", "matchCriteriaId": "0D3E781C-403A-498F-9DA9-ECEE50F41E75", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.14:rc3:*:*:*:*:*:*", "matchCriteriaId": "66619FB8-0AAF-4166-B2CF-67B24143261D", "cpe_name": []}]}]}}