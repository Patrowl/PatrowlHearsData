{"publishedDate": "2025-05-09T07:16Z", "lastModifiedDate": "2025-05-12T17:32Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-37882", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: xhci: Fix isochronous Ring Underrun/Overrun event handling\n\nThe TRB pointer of these events points at enqueue at the time of error\noccurrence on xHCI 1.1+ HCs or it's NULL on older ones. By the time we\nare handling the event, a new TD may be queued at this ring position.\n\nI can trigger this race by rising interrupt moderation to increase IRQ\nhandling delay. Similar delay may occur naturally due to system load.\n\nIf this ever happens after a Missed Service Error, missed TDs will be\nskipped and the new TD processed as if it matched the event. It could\nbe given back prematurely, risking data loss or buffer UAF by the xHC.\n\nDon't complete TDs on xrun events and don't warn if queued TDs don't\nmatch the event's TRB pointer, which can be NULL or a link/no-op TRB.\nDon't warn if there are no queued TDs at all.\n\nNow that it's safe, also handle xrun events if the skip flag is clear.\nThis ensures completion of any TD stuck in 'error mid TD' state right\nbefore the xrun event, which could happen if a driver submits a finite\nnumber of URBs to a buggy HC and then an error occurs on the last TD."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: xhci: Arreglar el manejo de eventos is\u00f3cronos de Infraeje/Desbordamiento de Anillo El puntero TRB de estos eventos apunta a enqueue en el momento de ocurrencia del error en HCs xHCI 1.1+ o es NULL en los m\u00e1s antiguos. En el momento en que manejamos el evento, un nuevo TD puede estar en cola en esta posici\u00f3n de anillo. Puedo desencadenar esta ejecuci\u00f3n aumentando la moderaci\u00f3n de interrupciones para aumentar el retraso en el manejo de IRQ. Un retraso similar puede ocurrir naturalmente debido a la carga del sistema. Si esto sucede alguna vez despu\u00e9s de un Error de Servicio Perdido, los TD perdidos se omitir\u00e1n y el nuevo TD se procesar\u00e1 como si coincidiera con el evento. Podr\u00eda devolverse prematuramente, con el riesgo de p\u00e9rdida de datos o UAF de b\u00fafer por parte del xHC. No complete los TD en eventos xrun y no advierta si los TD en cola no coinciden con el puntero TRB del evento, que puede ser NULL o un TRB de enlace/no operaci\u00f3n. No avisar si no hay ning\u00fan TD en cola. Ahora que es seguro, tambi\u00e9n se gestionan los eventos xrun si el indicador de omisi\u00f3n est\u00e1 desactivado. Esto garantiza la finalizaci\u00f3n de cualquier TD bloqueado en estado de \"error a mitad de TD\" justo antes del evento xrun, lo que podr\u00eda ocurrir si un controlador env\u00eda un n\u00famero finito de URB a un HC con errores y luego se produce un error en el \u00faltimo TD."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/16a7a8e6c47fea5c847beb696c8c21a7a44c1915", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/39a080a2925c81b0f1da0add44722ef2b78e5454", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/906dec15b9b321b546fd31a3c99ffc13724c7af4", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}