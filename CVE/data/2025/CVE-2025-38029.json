{"publishedDate": "2025-06-18T10:15Z", "lastModifiedDate": "2025-06-18T13:46Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-38029", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nkasan: avoid sleepable page allocation from atomic context\n\napply_to_pte_range() enters the lazy MMU mode and then invokes\nkasan_populate_vmalloc_pte() callback on each page table walk iteration. \nHowever, the callback can go into sleep when trying to allocate a single\npage, e.g.  if an architecutre disables preemption on lazy MMU mode enter.\n\nOn s390 if make arch_enter_lazy_mmu_mode() -> preempt_enable() and\narch_leave_lazy_mmu_mode() -> preempt_disable(), such crash occurs:\n\n[    0.663336] BUG: sleeping function called from invalid context at ./include/linux/sched/mm.h:321\n[    0.663348] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 2, name: kthreadd\n[    0.663358] preempt_count: 1, expected: 0\n[    0.663366] RCU nest depth: 0, expected: 0\n[    0.663375] no locks held by kthreadd/2.\n[    0.663383] Preemption disabled at:\n[    0.663386] [<0002f3284cbb4eda>] apply_to_pte_range+0xfa/0x4a0\n[    0.663405] CPU: 0 UID: 0 PID: 2 Comm: kthreadd Not tainted 6.15.0-rc5-gcc-kasan-00043-gd76bb1ebb558-dirty #162 PREEMPT\n[    0.663408] Hardware name: IBM 3931 A01 701 (KVM/Linux)\n[    0.663409] Call Trace:\n[    0.663410]  [<0002f3284c385f58>] dump_stack_lvl+0xe8/0x140\n[    0.663413]  [<0002f3284c507b9e>] __might_resched+0x66e/0x700\n[    0.663415]  [<0002f3284cc4f6c0>] __alloc_frozen_pages_noprof+0x370/0x4b0\n[    0.663419]  [<0002f3284ccc73c0>] alloc_pages_mpol+0x1a0/0x4a0\n[    0.663421]  [<0002f3284ccc8518>] alloc_frozen_pages_noprof+0x88/0xc0\n[    0.663424]  [<0002f3284ccc8572>] alloc_pages_noprof+0x22/0x120\n[    0.663427]  [<0002f3284cc341ac>] get_free_pages_noprof+0x2c/0xc0\n[    0.663429]  [<0002f3284cceba70>] kasan_populate_vmalloc_pte+0x50/0x120\n[    0.663433]  [<0002f3284cbb4ef8>] apply_to_pte_range+0x118/0x4a0\n[    0.663435]  [<0002f3284cbc7c14>] apply_to_pmd_range+0x194/0x3e0\n[    0.663437]  [<0002f3284cbc99be>] __apply_to_page_range+0x2fe/0x7a0\n[    0.663440]  [<0002f3284cbc9e88>] apply_to_page_range+0x28/0x40\n[    0.663442]  [<0002f3284ccebf12>] kasan_populate_vmalloc+0x82/0xa0\n[    0.663445]  [<0002f3284cc1578c>] alloc_vmap_area+0x34c/0xc10\n[    0.663448]  [<0002f3284cc1c2a6>] __get_vm_area_node+0x186/0x2a0\n[    0.663451]  [<0002f3284cc1e696>] __vmalloc_node_range_noprof+0x116/0x310\n[    0.663454]  [<0002f3284cc1d950>] __vmalloc_node_noprof+0xd0/0x110\n[    0.663457]  [<0002f3284c454b88>] alloc_thread_stack_node+0xf8/0x330\n[    0.663460]  [<0002f3284c458d56>] dup_task_struct+0x66/0x4d0\n[    0.663463]  [<0002f3284c45be90>] copy_process+0x280/0x4b90\n[    0.663465]  [<0002f3284c460940>] kernel_clone+0xd0/0x4b0\n[    0.663467]  [<0002f3284c46115e>] kernel_thread+0xbe/0xe0\n[    0.663469]  [<0002f3284c4e440e>] kthreadd+0x50e/0x7f0\n[    0.663472]  [<0002f3284c38c04a>] __ret_from_fork+0x8a/0xf0\n[    0.663475]  [<0002f3284ed57ff2>] ret_from_fork+0xa/0x38\n\nInstead of allocating single pages per-PTE, bulk-allocate the shadow\nmemory prior to applying kasan_populate_vmalloc_pte() callback on a page\nrange."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: kasan: evitar la asignaci\u00f3n de p\u00e1ginas inactivas desde un contexto at\u00f3mico. apply_to_pte_range() entra en el modo MMU perezoso e invoca la devoluci\u00f3n de llamada kasan_populate_vmalloc_pte() en cada iteraci\u00f3n del recorrido de la tabla de p\u00e1ginas. Sin embargo, la devoluci\u00f3n de llamada puede entrar en modo inactivo al intentar asignar una sola p\u00e1gina, por ejemplo, si una arquitectura deshabilita la preempci\u00f3n al entrar en el modo MMU perezoso. En s390, si se hace arch_enter_lazy_mmu_mode() -&gt; preempt_enable() y arch_leave_lazy_mmu_mode() -&gt; preempt_disable(), se produce el siguiente fallo: [0.663336] ERROR: funci\u00f3n inactiva llamada desde un contexto no v\u00e1lido en ./include/linux/sched/mm.h:321 [0.663348] in_atomic(): 1, irqs_disabled(): 0, non_block: 0, pid: 2, name: kthreadd [0.663358] preempt_count: 1, esperado: 0 [0.663366] Profundidad de anidamiento de RCU: 0, esperado: 0 [0.663375] kthreadd/2 no mantiene bloqueos. [ 0.663383] Preempci\u00f3n deshabilitada en: [ 0.663386] [&lt;0002f3284cbb4eda&gt;] apply_to_pte_range+0xfa/0x4a0 [ 0.663405] CPU: 0 UID: 0 PID: 2 Comm: kthreadd No contaminado 6.15.0-rc5-gcc-kasan-00043-gd76bb1ebb558-dirty #162 PREEMPT [ 0.663408] Nombre del hardware: IBM 3931 A01 701 (KVM/Linux) [ 0.663409] Rastreo de llamadas: [ 0.663410] [&lt;0002f3284c385f58&gt;] dump_stack_lvl+0xe8/0x140 [ 0.663413] [&lt;0002f3284c507b9e&gt;] __might_resched+0x66e/0x700 [ 0.663415] [&lt;0002f3284cc4f6c0&gt;] __alloc_frozen_pages_noprof+0x370/0x4b0 [ 0.663419] [&lt;0002f3284ccc73c0&gt;] alloc_pages_mpol+0x1a0/0x4a0 [ 0.663421] [&lt;0002f3284ccc8518&gt;] alloc_frozen_pages_noprof+0x88/0xc0 [ 0.663424] [&lt;0002f3284ccc8572&gt;] alloc_pages_noprof+0x22/0x120 [ 0.663427] [&lt;0002f3284cc341ac&gt;] get_free_pages_noprof+0x2c/0xc0 [ 0.663429] [&lt;0002f3284cceba70&gt;] kasan_populate_vmalloc_pte+0x50/0x120 [ 0.663433] [&lt;0002f3284cbb4ef8&gt;] apply_to_pte_range+0x118/0x4a0 [ 0.663435] [&lt;0002f3284cbc7c14&gt;] apply_to_pmd_range+0x194/0x3e0 [ 0.663437] [&lt;0002f3284cbc99be&gt;] __apply_to_page_range+0x2fe/0x7a0 [ 0.663440] [&lt;0002f3284cbc9e88&gt;] apply_to_page_range+0x28/0x40 [ 0.663442] [&lt;0002f3284ccebf12&gt;] kasan_populate_vmalloc+0x82/0xa0 [ 0.663445] [&lt;0002f3284cc1578c&gt;] alloc_vmap_area+0x34c/0xc10 [ 0.663448] [&lt;0002f3284cc1c2a6&gt;] __get_vm_area_node+0x186/0x2a0 [ 0.663451] [&lt;0002f3284cc1e696&gt;] __vmalloc_node_range_noprof+0x116/0x310 [ 0.663454] [&lt;0002f3284cc1d950&gt;] __vmalloc_node_noprof+0xd0/0x110 [ 0.663457] [&lt;0002f3284c454b88&gt;] alloc_thread_stack_node+0xf8/0x330 [ 0.663460] [&lt;0002f3284c458d56&gt;] dup_task_struct+0x66/0x4d0 [ 0.663463] [&lt;0002f3284c45be90&gt;] copy_process+0x280/0x4b90 [ 0.663465] [&lt;0002f3284c460940&gt;] kernel_clone+0xd0/0x4b0 [ 0.663467] [&lt;0002f3284c46115e&gt;] kernel_thread+0xbe/0xe0 [ 0.663469] [&lt;0002f3284c4e440e&gt;] kthreadd+0x50e/0x7f0 [ 0.663472] [&lt;0002f3284c38c04a&gt;] __ret_from_fork+0x8a/0xf0 [ 0.663475] [&lt;0002f3284ed57ff2&gt;] ret_from_fork+0xa/0x38 En su lugar de asignar p\u00e1ginas individuales por PTE, asigne en masa la memoria de sombra antes de aplicar la devoluci\u00f3n de llamada kasan_populate_vmalloc_pte() en un rango de p\u00e1ginas."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/6748dd09196248b985cca39eaf651d5317271977", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/b6ea95a34cbd014ab6ade4248107b86b0aaf2d6c", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}