{"publishedDate": "2025-07-25T15:15Z", "lastModifiedDate": "2025-07-25T15:29Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-38433", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nriscv: fix runtime constant support for nommu kernels\n\nthe `__runtime_fixup_32` function does not handle the case where `val` is\nzero correctly (as might occur when patching a nommu kernel and referring\nto a physical address below the 4GiB boundary whose upper 32 bits are all\nzero) because nothing in the existing logic prevents the code from taking\nthe `else` branch of both nop-checks and emitting two `nop` instructions.\n\nThis leaves random garbage in the register that is supposed to receive the\nupper 32 bits of the pointer instead of zero that when combined with the\nvalue for the lower 32 bits yields an invalid pointer and causes a kernel\npanic when that pointer is eventually accessed.\n\nThe author clearly considered the fact that if the `lui` is converted into\na `nop` that the second instruction needs to be adjusted to become an `li`\ninstead of an `addi`, hence introducing the `addi_insn_mask` variable, but\ndidn't follow that logic through fully to the case where the `else` branch\nexecutes. To fix it just adjust the logic to ensure that the second `else`\nbranch is not taken if the first instruction will be patched to a `nop`."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: riscv: se corrige el soporte de constantes de tiempo de ejecuci\u00f3n para kernels nommu la funci\u00f3n `__runtime_fixup_32` no maneja el caso donde `val` es cero correctamente (como podr\u00eda ocurrir al parchar un kernel nommu y hacer referencia a una direcci\u00f3n f\u00edsica por debajo del l\u00edmite de 4GiB cuyos 32 bits superiores son todos cero) porque nada en la l\u00f3gica existente evita que el c\u00f3digo tome la rama `else` de ambos nop-checks y emita dos instrucciones `nop`. Esto deja basura aleatoria en el registro que se supone que recibe los 32 bits superiores del puntero en lugar de cero que, cuando se combina con el valor de los 32 bits inferiores, produce un puntero no v\u00e1lido y causa un p\u00e1nico del kernel cuando finalmente se accede a ese puntero. El autor consider\u00f3 claramente que si la instrucci\u00f3n `lui` se convierte en `nop`, la segunda instrucci\u00f3n debe ajustarse para que se convierta en `li` en lugar de `addi`, introduciendo as\u00ed la variable `addi_insn_mask`. Sin embargo, no sigui\u00f3 esta l\u00f3gica completamente hasta el caso en que se ejecuta la rama `else`. Para solucionarlo, simplemente ajuste la l\u00f3gica para garantizar que la segunda rama `else` no se ejecute si la primera instrucci\u00f3n se convierte en `nop`."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/0a24b00dcde83934a3cc13e4c6b775522903496b", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/8d90d9872edae7e78c3a12b98e239bfaa66f3639", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}