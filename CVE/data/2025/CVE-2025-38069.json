{"publishedDate": "2025-06-18T10:15Z", "lastModifiedDate": "2025-06-18T13:46Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-38069", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: endpoint: pci-epf-test: Fix double free that causes kernel to oops\n\nFix a kernel oops found while testing the stm32_pcie Endpoint driver\nwith handling of PERST# deassertion:\n\nDuring EP initialization, pci_epf_test_alloc_space() allocates all BARs,\nwhich are further freed if epc_set_bar() fails (for instance, due to no\nfree inbound window).\n\nHowever, when pci_epc_set_bar() fails, the error path:\n\n  pci_epc_set_bar() ->\n    pci_epf_free_space()\n\ndoes not clear the previous assignment to epf_test->reg[bar].\n\nThen, if the host reboots, the PERST# deassertion restarts the BAR\nallocation sequence with the same allocation failure (no free inbound\nwindow), creating a double free situation since epf_test->reg[bar] was\ndeallocated and is still non-NULL.\n\nThus, make sure that pci_epf_alloc_space() and pci_epf_free_space()\ninvocations are symmetric, and as such, set epf_test->reg[bar] to NULL\nwhen memory is freed.\n\n[kwilczynski: commit log]"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: PCI: endpoint: pci-epf-test: Se corrige la doble liberaci\u00f3n que provoca un error en el kernel. Se corrige un error en el kernel detectado al probar el controlador de endpoint stm32_pcie con el manejo de la deaserci\u00f3n PERST#: Durante la inicializaci\u00f3n de EP, pci_epf_test_alloc_space() asigna todos los BAR, que se liberan a\u00fan m\u00e1s si epc_set_bar() falla (por ejemplo, debido a que no hay una ventana de entrada libre). Sin embargo, cuando pci_epc_set_bar() falla, la ruta de error: pci_epc_set_bar() -&gt; pci_epf_free_space() no borra la asignaci\u00f3n previa a epf_test-&gt;reg[bar]. Luego, si el host se reinicia, la desasignaci\u00f3n PERST# reinicia la secuencia de asignaci\u00f3n de BAR con el mismo fallo de asignaci\u00f3n (sin ventana de entrada libre), lo que crea una situaci\u00f3n de doble liberaci\u00f3n, ya que epf_test-&gt;reg[bar] se desasign\u00f3 y sigue siendo distinto de NULL. Por lo tanto, aseg\u00farese de que las invocaciones de pci_epf_alloc_space() y pci_epf_free_space() sean sim\u00e9tricas y, por lo tanto, establezca epf_test-&gt;reg[bar] en NULL cuando se libere memoria. [kwilczynski: registro de confirmaciones]"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/8b83893d1f6c6061a7d58169ecdf9d5ee9f306ee", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/934e9d137d937706004c325fa1474f9e3f1ba10a", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/fe2329eff5bee461ebcafadb6ca1df0cbf5945fd", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}