{"publishedDate": "2025-07-10T09:15Z", "lastModifiedDate": "2025-07-10T13:17Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-38334", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/sgx: Prevent attempts to reclaim poisoned pages\n\nTL;DR: SGX page reclaim touches the page to copy its contents to\nsecondary storage. SGX instructions do not gracefully handle machine\nchecks. Despite this, the existing SGX code will try to reclaim pages\nthat it _knows_ are poisoned. Avoid even trying to reclaim poisoned pages.\n\nThe longer story:\n\nPages used by an enclave only get epc_page->poison set in\narch_memory_failure() but they currently stay on sgx_active_page_list until\nsgx_encl_release(), with the SGX_EPC_PAGE_RECLAIMER_TRACKED flag untouched.\n\nepc_page->poison is not checked in the reclaimer logic meaning that, if other\nconditions are met, an attempt will be made to reclaim an EPC page that was\npoisoned.  This is bad because 1. we don't want that page to end up added\nto another enclave and 2. it is likely to cause one core to shut down\nand the kernel to panic.\n\nSpecifically, reclaiming uses microcode operations including \"EWB\" which\naccesses the EPC page contents to encrypt and write them out to non-SGX\nmemory.  Those operations cannot handle MCEs in their accesses other than\nby putting the executing core into a special shutdown state (affecting\nboth threads with HT.)  The kernel will subsequently panic on the\nremaining cores seeing the core didn't enter MCE handler(s) in time.\n\nCall sgx_unmark_page_reclaimable() to remove the affected EPC page from\nsgx_active_page_list on memory error to stop it being considered for\nreclaiming.\n\nTesting epc_page->poison in sgx_reclaim_pages() would also work but I assume\nit's better to add code in the less likely paths.\n\nThe affected EPC page is not added to &node->sgx_poison_page_list until\nlater in sgx_encl_release()->sgx_free_epc_page() when it is EREMOVEd.\nMembership on other lists doesn't change to avoid changing any of the\nlists' semantics except for sgx_active_page_list.  There's a \"TBD\" comment\nin arch_memory_failure() about pre-emptive actions, the goal here is not\nto address everything that it may imply.\n\nThis also doesn't completely close the time window when a memory error\nnotification will be fatal (for a not previously poisoned EPC page) --\nthe MCE can happen after sgx_reclaim_pages() has selected its candidates\nor even *inside* a microcode operation (actually easy to trigger due to\nthe amount of time spent in them.)\n\nThe spinlock in sgx_unmark_page_reclaimable() is safe because\nmemory_failure() runs in process context and no spinlocks are held,\nexplicitly noted in a mm/memory-failure.c comment."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: x86/sgx: Evitar intentos de recuperar p\u00e1ginas envenenadas TL;DR: La recuperaci\u00f3n de p\u00e1gina SGX toca la p\u00e1gina para copiar su contenido al almacenamiento secundario. Las instrucciones SGX no manejan correctamente las comprobaciones de la m\u00e1quina. A pesar de esto, el c\u00f3digo SGX existente intentar\u00e1 recuperar las p\u00e1ginas que _sabe_ que est\u00e1n envenenadas. Evite incluso intentar recuperar p\u00e1ginas envenenadas. En resumen: Las p\u00e1ginas utilizadas por un enclave solo obtienen epc_page-&gt;poison establecida en arch_memory_failure(), pero actualmente permanecen en sgx_active_page_list hasta sgx_encl_release(), con el indicador SGX_EPC_PAGE_RECLAIMER_TRACKED intacto. epc_page-&gt;poison no se comprueba en la l\u00f3gica del recuperador, lo que significa que, si se cumplen otras condiciones, se intentar\u00e1 recuperar una p\u00e1gina EPC que fue envenenada. Esto es perjudicial porque 1. no queremos que esa p\u00e1gina se a\u00f1ada a otro enclave y 2. es probable que provoque el apagado de un n\u00facleo y el p\u00e1nico del kernel. En concreto, la recuperaci\u00f3n utiliza operaciones de microc\u00f3digo, como \"EWB\", que accede al contenido de la p\u00e1gina EPC para cifrarlo y escribirlo en memoria no SGX. Estas operaciones no pueden gestionar MCE en sus accesos, salvo que pongan el n\u00facleo en ejecuci\u00f3n en un estado de apagado especial (lo que afecta a ambos hilos con HT). El kernel posteriormente entrar\u00e1 en p\u00e1nico en los n\u00facleos restantes, al ver que el n\u00facleo no accedi\u00f3 a los controladores de MCE a tiempo. Llama a sgx_unmark_page_reclaimable() para eliminar la p\u00e1gina EPC afectada de sgx_active_page_list en caso de error de memoria y as\u00ed evitar que se considere su recuperaci\u00f3n. Probar epc_page-&gt;poison en sgx_reclaim_pages() tambi\u00e9n funcionar\u00eda, pero supongo que es mejor a\u00f1adir c\u00f3digo en las rutas menos probables. La p\u00e1gina EPC afectada no se a\u00f1ade a &amp;node-&gt;sgx_poison_page_list hasta m\u00e1s adelante en sgx_encl_release()-&gt;sgx_free_epc_page(), cuando se elimina. La membres\u00eda en otras listas no cambia para evitar modificar la sem\u00e1ntica de las listas, excepto la de sgx_active_page_list. Hay un comentario \"TBD\" en arch_memory_failure() sobre acciones preventivas; el objetivo no es abordar todo lo que pueda implicar. Esto tampoco cierra completamente la ventana de tiempo cuando una notificaci\u00f3n de error de memoria ser\u00e1 fatal (para una p\u00e1gina EPC que no haya sido envenenada previamente) - el MCE puede ocurrir despu\u00e9s de que sgx_reclaim_pages() haya seleccionado sus candidatos o incluso *dentro* de una operaci\u00f3n de microc\u00f3digo (en realidad, f\u00e1cil de activar debido a la cantidad de tiempo empleado en ellas). El bloqueo de giro en sgx_unmark_page_reclaimable() es seguro porque memory_failure() se ejecuta en el contexto del proceso y no se mantienen bloqueos de giro, lo que se se\u00f1ala expl\u00edcitamente en un comentario mm/memory-failure.c."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/00a88e9ea1b170d579c56327c38f7e8cf689df87", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/31dcbac94bfeabb86bf85b0c36803fdd6536437b", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/62b62a2a6dc51ed6e8e334861f04220c9cf8106a", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/dc5de5bd6deabd327ced2b2b1d0b4f14cd146afe", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/ed16618c380c32c68c06186d0ccbb0d5e0586e59", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}