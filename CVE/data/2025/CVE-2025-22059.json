{"publishedDate": "2025-04-16T15:15Z", "lastModifiedDate": "2025-05-06T16:41Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-22059", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nudp: Fix multiple wraparounds of sk->sk_rmem_alloc.\n\n__udp_enqueue_schedule_skb() has the following condition:\n\n  if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf)\n          goto drop;\n\nsk->sk_rcvbuf is initialised by net.core.rmem_default and later can\nbe configured by SO_RCVBUF, which is limited by net.core.rmem_max,\nor SO_RCVBUFFORCE.\n\nIf we set INT_MAX to sk->sk_rcvbuf, the condition is always false\nas sk->sk_rmem_alloc is also signed int.\n\nThen, the size of the incoming skb is added to sk->sk_rmem_alloc\nunconditionally.\n\nThis results in integer overflow (possibly multiple times) on\nsk->sk_rmem_alloc and allows a single socket to have skb up to\nnet.core.udp_mem[1].\n\nFor example, if we set a large value to udp_mem[1] and INT_MAX to\nsk->sk_rcvbuf and flood packets to the socket, we can see multiple\noverflows:\n\n  # cat /proc/net/sockstat | grep UDP:\n  UDP: inuse 3 mem 7956736  <-- (7956736 << 12) bytes > INT_MAX * 15\n                                             ^- PAGE_SHIFT\n  # ss -uam\n  State  Recv-Q      ...\n  UNCONN -1757018048 ...    <-- flipping the sign repeatedly\n         skmem:(r2537949248,rb2147483646,t0,tb212992,f1984,w0,o0,bl0,d0)\n\nPreviously, we had a boundary check for INT_MAX, which was removed by\ncommit 6a1f12dd85a8 (\"udp: relax atomic operation on sk->sk_rmem_alloc\").\n\nA complete fix would be to revert it and cap the right operand by\nINT_MAX:\n\n  rmem = atomic_add_return(size, &sk->sk_rmem_alloc);\n  if (rmem > min(size + (unsigned int)sk->sk_rcvbuf, INT_MAX))\n          goto uncharge_drop;\n\nbut we do not want to add the expensive atomic_add_return() back just\nfor the corner case.\n\nCasting rmem to unsigned int prevents multiple wraparounds, but we still\nallow a single wraparound.\n\n  # cat /proc/net/sockstat | grep UDP:\n  UDP: inuse 3 mem 524288  <-- (INT_MAX + 1) >> 12\n\n  # ss -uam\n  State  Recv-Q      ...\n  UNCONN -2147482816 ...   <-- INT_MAX + 831 bytes\n         skmem:(r2147484480,rb2147483646,t0,tb212992,f3264,w0,o0,bl0,d14468947)\n\nSo, let's define rmem and rcvbuf as unsigned int and check skb->truesize\nonly when rcvbuf is large enough to lower the overflow possibility.\n\nNote that we still have a small chance to see overflow if multiple skbs\nto the same socket are processed on different core at the same time and\neach size does not exceed the limit but the total size does.\n\nNote also that we must ignore skb->truesize for a small buffer as\nexplained in commit 363dc73acacb (\"udp: be less conservative with\nsock rmem accounting\")."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: udp: Se corrigen m\u00faltiples encapsulamientos de sk-&gt;sk_rmem_alloc. __udp_enqueue_schedule_skb() tiene la siguiente condici\u00f3n: if (atomic_read(&amp;sk-&gt;sk_rmem_alloc) &gt; sk-&gt;sk_rcvbuf) goto drop; sk-&gt;sk_rcvbuf se inicializa con net.core.rmem_default y posteriormente se puede configurar con SO_RCVBUF, que est\u00e1 limitado por net.core.rmem_max o SO_RCVBUFFORCE. Si se establece INT_MAX en sk-&gt;sk_rcvbuf, la condici\u00f3n siempre es falsa, ya que sk-&gt;sk_rmem_alloc tambi\u00e9n es un entero con signo. En ese caso, el tama\u00f1o del skb entrante se a\u00f1ade a sk-&gt;sk_rmem_alloc incondicionalmente. Esto provoca un desbordamiento de enteros (posiblemente varias veces) en sk-&gt;sk_rmem_alloc y permite que un \u00fanico socket tenga skb hasta net.core.udp_mem[1]. Por ejemplo, si establecemos un valor grande en udp_mem[1] e INT_MAX en sk-&gt;sk_rcvbuf e inundamos el socket con paquetes, podemos ver m\u00faltiples desbordamientos: # cat /proc/net/sockstat | grep UDP: UDP: inuse 3 mem 7956736 &lt;-- (7956736 &lt;&lt; 12) bytes &gt; INT_MAX * 15 ^- PAGE_SHIFT # ss -uam State Recv-Q ... UNCONN -1757018048 ... &lt;-- invirtiendo el signo repetidamente skmem:(r2537949248,rb2147483646,t0,tb212992,f1984,w0,o0,bl0,d0) Anteriormente, ten\u00edamos una verificaci\u00f3n de l\u00edmite para INT_MAX, que se elimin\u00f3 mediante el commit 6a1f12dd85a8 (\"udp: relajar la operaci\u00f3n at\u00f3mica en sk-&gt;sk_rmem_alloc\"). Una soluci\u00f3n completa ser\u00eda revertirlo y limitar el operando derecho con INT_MAX: rmem = atomic_add_return(size, &amp;sk-&gt;sk_rmem_alloc); if (rmem &gt; min(size + (unsigned int)sk-&gt;sk_rcvbuf, INT_MAX)) goto uncharge_drop; pero no queremos a\u00f1adir el costoso atomic_add_return() solo para casos excepcionales. Convertir rmem a unsigned int evita m\u00faltiples encapsulamientos, pero a\u00fan permite un \u00fanico encapsulamiento. # cat /proc/net/sockstat | grep UDP: UDP: inuse 3 mem 524288 &lt;-- (INT_MAX + 1) &gt;&gt; 12 # ss -uam State Recv-Q ... UNCONN -2147482816 ... &lt;-- INT_MAX + 831 bytes skmem:(r2147484480,rb2147483646,t0,tb212992,f3264,w0,o0,bl0,d14468947) Por lo tanto, definamos rmem y rcvbuf como unsigned int y verifiquemos skb-&gt;truesize solo cuando rcvbuf sea lo suficientemente grande como para reducir la posibilidad de desbordamiento. Tenga en cuenta que a\u00fan existe una peque\u00f1a probabilidad de ver un desbordamiento si se procesan m\u00faltiples skbs al mismo socket en diferentes n\u00facleos al mismo tiempo y cada tama\u00f1o no excede el l\u00edmite, pero el tama\u00f1o total s\u00ed. Tenga en cuenta tambi\u00e9n que debemos ignorar skb-&gt;truesize para un buffer peque\u00f1o como se explica en el commit 363dc73acacb (\"udp: sea menos conservador con la contabilidad de sock rmem\")."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/1f529988efe9870db802cb79d01d8f473099b4d7", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/5a465a0da13ee9fbd7d3cd0b2893309b0fe4b7e3", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/7571aadd20289e9ea10ebfed0986f39ed8b3c16b", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/94d5ad7b41122be33ebc2a6830fe710cba1ecd75", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-190"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "CD08468B-6C62-4470-90F6-7F16F10CF3B4", "cpe_name": [], "versionStartIncluding": "6.10", "versionEndExcluding": "6.12.23"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "E7E864B0-8C00-4679-BA55-659B4C9C3AD3", "cpe_name": [], "versionStartIncluding": "6.13", "versionEndExcluding": "6.13.11"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "FADAE5D8-4808-442C-B218-77B2CE8780A0", "cpe_name": [], "versionStartIncluding": "6.14", "versionEndExcluding": "6.14.2"}]}]}}