{"publishedDate": "2025-01-31T12:15Z", "lastModifiedDate": "2025-05-02T07:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-21681", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nopenvswitch: fix lockup on tx to unregistering netdev with carrier\n\nCommit in a fixes tag attempted to fix the issue in the following\nsequence of calls:\n\n    do_output\n    -> ovs_vport_send\n       -> dev_queue_xmit\n          -> __dev_queue_xmit\n             -> netdev_core_pick_tx\n                -> skb_tx_hash\n\nWhen device is unregistering, the 'dev->real_num_tx_queues' goes to\nzero and the 'while (unlikely(hash >= qcount))' loop inside the\n'skb_tx_hash' becomes infinite, locking up the core forever.\n\nBut unfortunately, checking just the carrier status is not enough to\nfix the issue, because some devices may still be in unregistering\nstate while reporting carrier status OK.\n\nOne example of such device is a net/dummy.  It sets carrier ON\non start, but it doesn't implement .ndo_stop to set the carrier off.\nAnd it makes sense, because dummy doesn't really have a carrier.\nTherefore, while this device is unregistering, it's still easy to hit\nthe infinite loop in the skb_tx_hash() from the OVS datapath.  There\nmight be other drivers that do the same, but dummy by itself is\nimportant for the OVS ecosystem, because it is frequently used as a\npacket sink for tcpdump while debugging OVS deployments.  And when the\nissue is hit, the only way to recover is to reboot.\n\nFix that by also checking if the device is running.  The running\nstate is handled by the net core during unregistering, so it covers\nunregistering case better, and we don't really need to send packets\nto devices that are not running anyway.\n\nWhile only checking the running state might be enough, the carrier\ncheck is preserved.  The running and the carrier states seem disjoined\nthroughout the code and different drivers.  And other core functions\nlike __dev_direct_xmit() check both before attempting to transmit\na packet.  So, it seems safer to check both flags in OVS as well."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: openvswitch: fix lockup on tx to unregistering netdev with carrier Commit en una etiqueta fixes intent\u00f3 solucionar el problema en la siguiente secuencia de llamadas: do_output -&gt; ovs_vport_send -&gt; dev_queue_xmit -&gt; __dev_queue_xmit -&gt; netdev_core_pick_tx -&gt; skb_tx_hash Cuando el dispositivo est\u00e1 anulando el registro, 'dev-&gt;real_num_tx_queues' va a cero y el bucle 'while (unlikely(hash &gt;= qcount))' dentro de 'skb_tx_hash' se vuelve infinito, bloqueando el n\u00facleo para siempre. Pero desafortunadamente, verificar solo el estado del operador no es suficiente para solucionar el problema, porque algunos dispositivos a\u00fan pueden estar en estado de anulaci\u00f3n de registro mientras informan que el estado del operador es correcto. Un ejemplo de dicho dispositivo es un net/dummy. Activa el operador al iniciar, pero no implementa .ndo_stop para desactivarlo. Y tiene sentido, porque dummy en realidad no tiene un operador. Por lo tanto, mientras este dispositivo se est\u00e1 anulando el registro, sigue siendo f\u00e1cil alcanzar el bucle infinito en skb_tx_hash() desde la ruta de datos de OVS. Puede haber otros controladores que hagan lo mismo, pero dummy por s\u00ed solo es importante para el ecosistema OVS, porque se usa con frecuencia como un receptor de paquetes para tcpdump mientras se depuran las implementaciones de OVS. Y cuando se produce el problema, la \u00fanica forma de recuperarse es reiniciar. Solucione eso comprobando tambi\u00e9n si el dispositivo est\u00e1 en ejecuci\u00f3n. El estado de ejecuci\u00f3n controla el n\u00facleo de red durante la anulaci\u00f3n del registro, por lo que cubre mejor el caso de anulaci\u00f3n del registro y realmente no necesitamos enviar paquetes a dispositivos que no se est\u00e1n ejecutando de todos modos. Si bien solo comprobar el estado de ejecuci\u00f3n puede ser suficiente, la comprobaci\u00f3n del operador se conserva. Los estados de ejecuci\u00f3n y del operador parecen estar separados en todo el c\u00f3digo y en los diferentes controladores. Y otras funciones b\u00e1sicas como __dev_direct_xmit() comprueban ambos antes de intentar transmitir un paquete. Por lo tanto, parece m\u00e1s seguro comprobar tambi\u00e9n ambos indicadores en OVS."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/47e55e4b410f7d552e43011baa5be1aab4093990", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/82f433e8dd0629e16681edf6039d094b5518d8ed", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/87fcf0d137c770e6040ebfdb0abd8e7dd481b504", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/930268823f6bccb697aa5d2047aeffd4a497308c", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/b5c73fc92f8d15c16e5dc87b5c17d2abf1e6d092", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/ea966b6698785fb9cd0fdb867acd91b222e4723f", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/ea9e990356b7bee95440ba0e6e83cc4d701afaca", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-835"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "D40EAF88-F300-4CBF-8C2F-CD9CCE985D18", "cpe_name": [], "versionStartIncluding": "6.1.25", "versionEndExcluding": "6.1.127"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "66EDD4B5-2C3A-4A8E-AE60-49C429BCB3E7", "cpe_name": [], "versionStartIncluding": "6.2.12", "versionEndExcluding": "6.6.74"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "B7D0DBC3-F63C-4396-8A47-6F3D4FA0556E", "cpe_name": [], "versionStartIncluding": "6.7", "versionEndExcluding": "6.12.11"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.13:rc1:*:*:*:*:*:*", "matchCriteriaId": "62567B3C-6CEE-46D0-BC2E-B3717FBF7D13", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.13:rc2:*:*:*:*:*:*", "matchCriteriaId": "5A073481-106D-4B15-B4C7-FB0213B8E1D4", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.13:rc3:*:*:*:*:*:*", "matchCriteriaId": "DE491969-75AE-4A6B-9A58-8FC5AF98798F", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.13:rc4:*:*:*:*:*:*", "matchCriteriaId": "93C0660D-7FB8-4FBA-892A-B064BA71E49E", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.13:rc5:*:*:*:*:*:*", "matchCriteriaId": "034C36A6-C481-41F3-AE9A-D116E5BE6895", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.13:rc6:*:*:*:*:*:*", "matchCriteriaId": "8AF9DC49-2085-4FFB-A7E3-73DFAFECC7F2", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.13:rc7:*:*:*:*:*:*", "matchCriteriaId": "5DFCDFB8-4FD0-465A-9076-D813D78FE51B", "cpe_name": []}]}]}}