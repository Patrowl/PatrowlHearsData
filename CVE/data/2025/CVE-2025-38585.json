{"publishedDate": "2025-08-19T17:15Z", "lastModifiedDate": "2025-08-20T14:40Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-38585", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nstaging: media: atomisp: Fix stack buffer overflow in gmin_get_var_int()\n\nWhen gmin_get_config_var() calls efi.get_variable() and the EFI variable\nis larger than the expected buffer size, two behaviors combine to create\na stack buffer overflow:\n\n1. gmin_get_config_var() does not return the proper error code when\n   efi.get_variable() fails. It returns the stale 'ret' value from\n   earlier operations instead of indicating the EFI failure.\n\n2. When efi.get_variable() returns EFI_BUFFER_TOO_SMALL, it updates\n   *out_len to the required buffer size but writes no data to the output\n   buffer. However, due to bug #1, gmin_get_var_int() believes the call\n   succeeded.\n\nThe caller gmin_get_var_int() then performs:\n- Allocates val[CFG_VAR_NAME_MAX + 1] (65 bytes) on stack\n- Calls gmin_get_config_var(dev, is_gmin, var, val, &len) with len=64\n- If EFI variable is >64 bytes, efi.get_variable() sets len=required_size\n- Due to bug #1, thinks call succeeded with len=required_size\n- Executes val[len] = 0, writing past end of 65-byte stack buffer\n\nThis creates a stack buffer overflow when EFI variables are larger than\n64 bytes. Since EFI variables can be controlled by firmware or system\nconfiguration, this could potentially be exploited for code execution.\n\nFix the bug by returning proper error codes from gmin_get_config_var()\nbased on EFI status instead of stale 'ret' value.\n\nThe gmin_get_var_int() function is called during device initialization\nfor camera sensor configuration on Intel Bay Trail and Cherry Trail\nplatforms using the atomisp camera stack."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: staging: media: atomisp: Correcci\u00f3n del desbordamiento del b\u00fafer de pila en gmin_get_var_int() Cuando gmin_get_config_var() llama a efi.get_variable() y la variable EFI es mayor que el tama\u00f1o de b\u00fafer esperado, se combinan dos comportamientos para crear un desbordamiento del b\u00fafer de pila: 1. gmin_get_config_var() no devuelve el c\u00f3digo de error correcto cuando efi.get_variable() falla. Devuelve el valor 'ret' obsoleto de operaciones anteriores en lugar de indicar el fallo de EFI. 2. Cuando efi.get_variable() devuelve EFI_BUFFER_TOO_SMALL, actualiza *out_len al tama\u00f1o de b\u00fafer requerido, pero no escribe datos en el b\u00fafer de salida. Sin embargo, debido al error n.\u00ba 1, gmin_get_var_int() cree que la llamada tuvo \u00e9xito. El llamador gmin_get_var_int() realiza entonces: - Asigna val[CFG_VAR_NAME_MAX + 1] (65 bytes) en la pila - Llama a gmin_get_config_var(dev, is_gmin, var, val, &amp;len) con len=64 - Si la variable EFI es &gt;64 bytes, efi.get_variable() establece len=required_size - Debido al error #1, piensa que la llamada tuvo \u00e9xito con len=required_size - Ejecuta val[len] = 0, escribiendo m\u00e1s all\u00e1 del final del b\u00fafer de pila de 65 bytes Esto crea un desbordamiento del b\u00fafer de pila cuando las variables EFI son mayores de 64 bytes. Dado que las variables EFI pueden ser controladas por el firmware o la configuraci\u00f3n del sistema, esto podr\u00eda ser potencialmente explotado para la ejecuci\u00f3n de c\u00f3digo. Corrija el error devolviendo los c\u00f3digos de error adecuados de gmin_get_config_var() basados en el estado de EFI en lugar del valor 'ret' obsoleto. La funci\u00f3n gmin_get_var_int() se llama durante la inicializaci\u00f3n del dispositivo para la configuraci\u00f3n del sensor de la c\u00e1mara en las plataformas Intel Bay Trail y Cherry Trail utilizando la pila de c\u00e1mara atomisp."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/1a7a2f59fb2eb0718a0cff1e5822500cefe50ed9", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/3d672fe065aa00f4d66f42e3c9720f69a3ed43e7", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e6d3453a002e89537e6136f6c774659b297a549b", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/ee4cf798202d285dcbe85e4467a094c44f5ed8e6", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}