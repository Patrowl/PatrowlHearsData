{"publishedDate": "2025-05-09T07:16Z", "lastModifiedDate": "2025-05-12T17:32Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-37856", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: harden block_group::bg_list against list_del() races\n\nAs far as I can tell, these calls of list_del_init() on bg_list cannot\nrun concurrently with btrfs_mark_bg_unused() or btrfs_mark_bg_to_reclaim(),\nas they are in transaction error paths and situations where the block\ngroup is readonly.\n\nHowever, if there is any chance at all of racing with mark_bg_unused(),\nor a different future user of bg_list, better to be safe than sorry.\n\nOtherwise we risk the following interleaving (bg_list refcount in parens)\n\nT1 (some random op)                       T2 (btrfs_mark_bg_unused)\n                                        !list_empty(&bg->bg_list); (1)\nlist_del_init(&bg->bg_list); (1)\n                                        list_move_tail (1)\nbtrfs_put_block_group (0)\n                                        btrfs_delete_unused_bgs\n                                             bg = list_first_entry\n                                             list_del_init(&bg->bg_list);\n                                             btrfs_put_block_group(bg); (-1)\n\nUltimately, this results in a broken ref count that hits zero one deref\nearly and the real final deref underflows the refcount, resulting in a WARNING."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: btrfs: endurecer block_group::bg_list contra ejecuciones list_del() Hasta donde puedo decir, estas llamadas de list_del_init() en bg_list no se pueden ejecutar simult\u00e1neamente con btrfs_mark_bg_unused() o btrfs_mark_bg_to_reclaim(), ya que est\u00e1n en rutas de error de transacci\u00f3n y situaciones en las que el grupo de bloques es de solo lectura. Sin embargo, si hay alguna posibilidad de competir con mark_bg_unused(), o con un futuro usuario diferente de bg_list, m\u00e1s vale prevenir que curar. De lo contrario, nos arriesgamos al siguiente intercalado (bg_list refcount entre par\u00e9ntesis) T1 (alguna operaci\u00f3n aleatoria) T2 (btrfs_mark_bg_unused) !list_empty(&amp;bg-&gt;bg_list); (1) list_del_init(&amp;bg-&gt;bg_list); (1) list_move_tail (1) btrfs_put_block_group (0) btrfs_delete_unused_bgs bg = list_first_entry list_del_init(&amp;bg-&gt;bg_list); btrfs_put_block_group(bg); (-1) En \u00faltima instancia, esto da como resultado un recuento de referencias roto que llega a cero un deref antes y el deref final real desborda el recuento de referencias, lo que genera una ADVERTENCIA."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/185fd73e5ac06027c4be9a129e59193f6a3ef202", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/7511e29cf1355b2c47d0effb39e463119913e2f6", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/909e60fb469d4101c6b08cf6e622efb062bb24a1", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/bf089c4d1141b27332c092b1dcca5022c415a3b6", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}