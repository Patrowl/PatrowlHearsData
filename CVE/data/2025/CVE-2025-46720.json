{"publishedDate": "2025-05-05T19:15Z", "lastModifiedDate": "2025-05-05T20:54Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-46720", "ASSIGNER": "security-advisories@github.com"}, "description": {"description_data": [{"lang": "en", "value": "Keystone is a content management system for Node.js. Prior to version 6.5.0, `{field}.isFilterable` access control can be bypassed in `update` and `delete` mutations by adding additional unique filters. These filters can be used as an oracle to probe the existence or value of otherwise unreadable fields. Specifically, when a mutation includes a `where` clause with multiple unique filters (e.g. `id` and `email`), Keystone will attempt to match records even if filtering by the latter fields would normally be rejected by `field.isFilterable` or `list.defaultIsFilterable`. This can allow malicious actors to infer the presence of a particular field value when a filter is successful in returning a result. This affects any project relying on the default or dynamic `isFilterable` behavior (at the list or field level) to prevent external users from using the filtering of fields as a discovery mechanism. While this access control is respected during `findMany` operations, it was not completely enforced during `update` and `delete` mutations when accepting more than one unique `where` values in filters. This has no impact on projects using `isFilterable: false` or `defaultIsFilterable: false` for sensitive fields, or for those who have otherwise omitted filtering by these fields from their GraphQL schema. This issue has been patched in `@keystone-6/core` version 6.5.0. To mitigate this issue in older versions where patching is not a viable pathway, set `isFilterable: false` statically for relevant fields to prevent filtering by them earlier in the access control pipeline (that is, don't use functions); set `{field}.graphql.omit.read: true` for relevant fields, which implicitly removes filtering by these fields from the GraphQL schema; and/or deny `update` and `delete` operations for the relevant lists completely."}, {"lang": "es", "value": "Keystone es un sistema de gesti\u00f3n de contenido para Node.js. Antes de la versi\u00f3n 6.5.0, el control de acceso `{field}.isFilterable` se pod\u00eda omitir en las mutaciones `update` y `delete` a\u00f1adiendo filtros \u00fanicos adicionales. Estos filtros se pueden usar como un or\u00e1culo para sondear la existencia o el valor de campos que de otro modo ser\u00edan ilegibles. Espec\u00edficamente, cuando una mutaci\u00f3n incluye una cl\u00e1usula `where` con m\u00faltiples filtros \u00fanicos (p. ej., `id` y `email`), Keystone intentar\u00e1 encontrar coincidencias en los registros incluso si el filtrado por estos \u00faltimos campos normalmente ser\u00eda rechazado por `field.isFilterable` o `list.defaultIsFilterable`. Esto puede permitir que actores maliciosos infieran la presencia de un valor de campo espec\u00edfico cuando un filtro devuelve un resultado correctamente. Esto afecta a cualquier proyecto que dependa del comportamiento predeterminado o din\u00e1mico de `isFilterable` (a nivel de lista o campo) para evitar que usuarios externos utilicen el filtrado de campos como mecanismo de descubrimiento. Aunque este control de acceso se respeta durante las operaciones `findMany`, no se aplic\u00f3 completamente durante las mutaciones `update` y `delete` al aceptar m\u00e1s de un valor `where` \u00fanico en los filtros. Esto no tiene impacto en los proyectos que usan `isFilterable: false` o `defaultIsFilterable: false` para campos sensibles, o para aquellos que de otra manera han omitido el filtrado por estos campos de su esquema GraphQL. Este problema se ha corregido en `@keystone-6/core` versi\u00f3n 6.5.0. Para mitigar este problema en versiones anteriores donde la aplicaci\u00f3n de parches no es una ruta viable, configure `isFilterable: false` est\u00e1ticamente para los campos relevantes para evitar el filtrado por ellos anteriormente en el flujo de trabajo de control de acceso (es decir, no use funciones); configure `{field}.graphql.omit.read: true` para los campos relevantes, lo que impl\u00edcitamente elimina el filtrado por estos campos del esquema GraphQL; y/o deniegue las operaciones `update` y `delete` para las listas relevantes por completo."}]}, "references": {"reference_data": [{"url": "https://github.com/keystonejs/keystone/security/advisories/GHSA-hg9m-67mm-7pg3", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-200"}, {"lang": "en", "value": "CWE-203"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.6, "impactScore": 1.4, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:N/A:N", "baseScore": 3.1, "baseSeverity": "LOW", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}