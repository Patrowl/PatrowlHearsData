{"publishedDate": "2025-08-19T17:15Z", "lastModifiedDate": "2025-10-10T16:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-38563", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nperf/core: Prevent VMA split of buffer mappings\n\nThe perf mmap code is careful about mmap()'ing the user page with the\nringbuffer and additionally the auxiliary buffer, when the event supports\nit. Once the first mapping is established, subsequent mapping have to use\nthe same offset and the same size in both cases. The reference counting for\nthe ringbuffer and the auxiliary buffer depends on this being correct.\n\nThough perf does not prevent that a related mapping is split via mmap(2),\nmunmap(2) or mremap(2). A split of a VMA results in perf_mmap_open() calls,\nwhich take reference counts, but then the subsequent perf_mmap_close()\ncalls are not longer fulfilling the offset and size checks. This leads to\nreference count leaks.\n\nAs perf already has the requirement for subsequent mappings to match the\ninitial mapping, the obvious consequence is that VMA splits, caused by\nresizing of a mapping or partial unmapping, have to be prevented.\n\nImplement the vm_operations_struct::may_split() callback and return\nunconditionally -EINVAL.\n\nThat ensures that the mapping offsets and sizes cannot be changed after the\nfact. Remapping to a different fixed address with the same size is still\npossible as it takes the references for the new mapping and drops those of\nthe old mapping."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: perf/core: Prevenir la divisi\u00f3n de VMA de las asignaciones de b\u00fafer El c\u00f3digo perf mmap es cuidadoso al realizar mmap() en la p\u00e1gina de usuario con el b\u00fafer de anillo y, adicionalmente, el b\u00fafer auxiliar, cuando el evento lo admite. Una vez que se establece la primera asignaci\u00f3n, las asignaciones posteriores deben usar el mismo desplazamiento y el mismo tama\u00f1o en ambos casos. El recuento de referencias para el b\u00fafer de anillo y el b\u00fafer auxiliar depende de que esto sea correcto. Aunque perf no impide que una asignaci\u00f3n relacionada se divida mediante mmap(2), munmap(2) o mremap(2). Una divisi\u00f3n de una VMA da como resultado llamadas a perf_mmap_open(), que toman recuentos de referencias, pero luego las llamadas perf_mmap_close() posteriores ya no cumplen con las comprobaciones de desplazamiento y tama\u00f1o. Esto conduce a fugas de recuento de referencias. Como perf ya tiene el requisito de que las asignaciones posteriores coincidan con la asignaci\u00f3n inicial, la consecuencia obvia es que se deben evitar las divisiones de VMA, causadas por el cambio de tama\u00f1o de una asignaci\u00f3n o la desasignaci\u00f3n parcial. Implemente la funci\u00f3n de retorno vm_operations_struct::may_split() y devuelva incondicionalmente -EINVAL. Esto garantiza que los desplazamientos y tama\u00f1os de la asignaci\u00f3n no se puedan modificar posteriormente. La reasignaci\u00f3n a una direcci\u00f3n fija diferente con el mismo tama\u00f1o sigue siendo posible, ya que toma las referencias de la nueva asignaci\u00f3n y descarta las de la asignaci\u00f3n anterior."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/3bd518cc7ea61076bcd725e36ff0e690754977c0", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/65311aad4c808bedad0c05d9bb8b06c47dae73eb", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/6757a31a8e295ae4f01717a954afda173f25a121", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/7b84cb58d1f0aa07656802eae24689566e5f5b1b", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/b024d7b56c77191cde544f838debb7f8451cd0d6", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/d52451a9210f2e5a079ba052918c93563518a9ff", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e4346ffec2c44d6b0be834d59b20632b5bb5729e", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e529888b7e8092912dd8789bdfc76685ccd2ff5f", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/ff668930871e0198c7f4e325058b8b7c286787bd", "name": "", "refsource": "", "tags": []}, {"url": "https://www.zerodayinitiative.com/advisories/ZDI-25-873/", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}