{"publishedDate": "2025-08-16T12:15Z", "lastModifiedDate": "2025-08-18T20:16Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-38524", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nrxrpc: Fix recv-recv race of completed call\n\nIf a call receives an event (such as incoming data), the call gets placed\non the socket's queue and a thread in recvmsg can be awakened to go and\nprocess it.  Once the thread has picked up the call off of the queue,\nfurther events will cause it to be requeued, and once the socket lock is\ndropped (recvmsg uses call->user_mutex to allow the socket to be used in\nparallel), a second thread can come in and its recvmsg can pop the call off\nthe socket queue again.\n\nIn such a case, the first thread will be receiving stuff from the call and\nthe second thread will be blocked on call->user_mutex.  The first thread\ncan, at this point, process both the event that it picked call for and the\nevent that the second thread picked the call for and may see the call\nterminate - in which case the call will be \"released\", decoupling the call\nfrom the user call ID assigned to it (RXRPC_USER_CALL_ID in the control\nmessage).\n\nThe first thread will return okay, but then the second thread will wake up\nholding the user_mutex and, if it sees that the call has been released by\nthe first thread, it will BUG thusly:\n\n\tkernel BUG at net/rxrpc/recvmsg.c:474!\n\nFix this by just dequeuing the call and ignoring it if it is seen to be\nalready released.  We can't tell userspace about it anyway as the user call\nID has become stale."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: rxrpc: Corregir la ejecuci\u00f3n recv-recv de la llamada completada. Si una llamada recibe un evento (como datos entrantes), la llamada se coloca en la cola del socket y se puede despertar un hilo en recvmsg para que la procese. Una vez que el hilo ha recogido la llamada de la cola, eventos posteriores har\u00e1n que se vuelva a poner en cola, y una vez que se libera el bloqueo del socket (recvmsg usa call-&gt;user_mutex para permitir que el socket se use en paralelo), un segundo hilo puede entrar y su recvmsg puede sacar la llamada de la cola del socket nuevamente. En tal caso, el primer hilo recibir\u00e1 cosas de la llamada y el segundo hilo se bloquear\u00e1 en call-&gt;user_mutex. En este punto, el primer hilo puede procesar tanto el evento para el que seleccion\u00f3 la llamada como el evento para el que el segundo hilo la seleccion\u00f3, y podr\u00eda ver que la llamada termina. En ese caso, la llamada se \"liberar\u00e1\", desvincul\u00e1ndola del ID de llamada de usuario que se le asign\u00f3 (RXRPC_USER_CALL_ID en el mensaje de control). El primer hilo retornar\u00e1 correctamente, pero el segundo hilo se reactivar\u00e1 con el user_mutex y, si detecta que el primer hilo ha liberado la llamada, generar\u00e1 el siguiente error: \u00a1error del kernel en net/rxrpc/recvmsg.c:474! Para solucionar esto, simplemente retire la llamada de la cola e ignore si ya est\u00e1 liberada. De todos modos, no podemos informar al espacio de usuario, ya que el ID de llamada de usuario ha quedado obsoleto."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/6c75a97a32a5fa2060c3dd30207e63b6914b606d", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/7692bde890061797f3dece0148d7859e85c55778", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/839fe96c15209dc2255c064bb44b636efe04f032", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/962fb1f651c2cf2083e0c3ef53ba69e3b96d3fbc", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}