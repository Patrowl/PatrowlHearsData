{"publishedDate": "2025-08-16T12:15Z", "lastModifiedDate": "2025-08-18T20:16Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-38544", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nrxrpc: Fix bug due to prealloc collision\n\nWhen userspace is using AF_RXRPC to provide a server, it has to preallocate\nincoming calls and assign to them call IDs that will be used to thread\nrelated recvmsg() and sendmsg() together.  The preallocated call IDs will\nautomatically be attached to calls as they come in until the pool is empty.\n\nTo the kernel, the call IDs are just arbitrary numbers, but userspace can\nuse the call ID to hold a pointer to prepared structs.  In any case, the\nuser isn't permitted to create two calls with the same call ID (call IDs\nbecome available again when the call ends) and EBADSLT should result from\nsendmsg() if an attempt is made to preallocate a call with an in-use call\nID.\n\nHowever, the cleanup in the error handling will trigger both assertions in\nrxrpc_cleanup_call() because the call isn't marked complete and isn't\nmarked as having been released.\n\nFix this by setting the call state in rxrpc_service_prealloc_one() and then\nmarking it as being released before calling the cleanup function."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: rxrpc: Correcci\u00f3n de error debido a la colisi\u00f3n de preasignaci\u00f3n Cuando el espacio de usuario usa AF_RXRPC para proporcionar un servidor, tiene que preasignar las llamadas entrantes y asignarles identificadores de llamada que se usar\u00e1n para enhebrar recvmsg() y sendmsg() relacionados. Los identificadores de llamada preasignados se adjuntar\u00e1n autom\u00e1ticamente a las llamadas a medida que entran hasta que el grupo est\u00e9 vac\u00edo. Para el kernel, los identificadores de llamada son solo n\u00fameros arbitrarios, pero el espacio de usuario puede usar el identificador de llamada para contener un puntero a estructuras preparadas. En cualquier caso, el usuario no tiene permitido crear dos llamadas con el mismo identificador de llamada (los identificadores de llamada vuelven a estar disponibles cuando la llamada finaliza) y EBADSLT deber\u00eda ser el resultado de sendmsg() si se intenta preasignar una llamada con un identificador de llamada en uso. Sin embargo, la limpieza en el manejo de errores activar\u00e1 ambas aserciones en rxrpc_cleanup_call() porque la llamada no est\u00e1 marcada como completa ni como liberada. Solucione esto configurando el estado de la llamada en rxrpc_service_prealloc_one() y luego marc\u00e1ndolo como liberado antes de llamar a la funci\u00f3n de limpieza."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/432c5363cd6fe5a928bbc94524d28b05515684dd", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/5385ad53793de2ab11e396bdcdaa65bb04b4dad6", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/69e4186773c6445b258fb45b6e1df18df831ec45", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/d8ffb47a443919277cb093c3db1ec6c0a06880b1", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}