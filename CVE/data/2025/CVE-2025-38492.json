{"publishedDate": "2025-07-28T12:15Z", "lastModifiedDate": "2025-11-19T17:46Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-38492", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfs: Fix race between cache write completion and ALL_QUEUED being set\n\nWhen netfslib is issuing subrequests, the subrequests start processing\nimmediately and may complete before we reach the end of the issuing\nfunction.  At the end of the issuing function we set NETFS_RREQ_ALL_QUEUED\nto indicate to the collector that we aren't going to issue any more subreqs\nand that it can do the final notifications and cleanup.\n\nNow, this isn't a problem if the request is synchronous\n(NETFS_RREQ_OFFLOAD_COLLECTION is unset) as the result collection will be\ndone in-thread and we're guaranteed an opportunity to run the collector.\n\nHowever, if the request is asynchronous, collection is primarily triggered\nby the termination of subrequests queuing it on a workqueue.  Now, a race\ncan occur here if the app thread sets ALL_QUEUED after the last subrequest\nterminates.\n\nThis can happen most easily with the copy2cache code (as used by Ceph)\nwhere, in the collection routine of a read request, an asynchronous write\nrequest is spawned to copy data to the cache.  Folios are added to the\nwrite request as they're unlocked, but there may be a delay before\nALL_QUEUED is set as the write subrequests may complete before we get\nthere.\n\nIf all the write subreqs have finished by the ALL_QUEUED point, no further\nevents happen and the collection never happens, leaving the request\nhanging.\n\nFix this by queuing the collector after setting ALL_QUEUED.  This is a bit\nheavy-handed and it may be sufficient to do it only if there are no extant\nsubreqs.\n\nAlso add a tracepoint to cross-reference both requests in a copy-to-request\noperation and add a trace to the netfs_rreq tracepoint to indicate the\nsetting of ALL_QUEUED."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: netfs: Corregir la ejecuci\u00f3n entre la finalizaci\u00f3n de la escritura en cach\u00e9 y el establecimiento de ALL_QUEUED Cuando netfslib emite subsolicitudes, estas empiezan a procesarse inmediatamente y pueden completarse antes de que lleguemos al final de la funci\u00f3n de emisi\u00f3n. Al final de la funci\u00f3n de emisi\u00f3n, establecemos NETFS_RREQ_ALL_QUEUED para indicar al recolector que no vamos a emitir m\u00e1s subsolicitudes y que puede realizar las notificaciones finales y la limpieza. Ahora bien, esto no es un problema si la solicitud es sincr\u00f3nica (NETFS_RREQ_OFFLOAD_COLLECTION no est\u00e1 establecido), ya que la recopilaci\u00f3n de resultados se realizar\u00e1 en el subproceso y se nos garantiza una oportunidad para ejecutar el recolector. Sin embargo, si la solicitud es asincr\u00f3nica, la recopilaci\u00f3n se activa principalmente al finalizar las subsolicitudes que la ponen en cola en una cola de trabajo. Ahora bien, aqu\u00ed puede producirse una ejecuci\u00f3n si el subproceso de la aplicaci\u00f3n establece ALL_QUEUED despu\u00e9s de que finalice la \u00faltima subsolicitud. Esto se puede lograr m\u00e1s f\u00e1cilmente con el c\u00f3digo copy2cache (usado por Ceph), donde, en la rutina de recopilaci\u00f3n de una solicitud de lectura, se genera una solicitud de escritura as\u00edncrona para copiar datos a la cach\u00e9. Los folios se agregan a la solicitud de escritura a medida que se desbloquean, pero puede haber un retraso antes de que se configure ALL_QUEUED, ya que las subsolicitudes de escritura pueden completarse antes de que lleguemos a ese punto. Si todas las subsolicitudes de escritura han finalizado para el punto ALL_QUEUED, no ocurren m\u00e1s eventos y la recopilaci\u00f3n nunca se realiza, dejando la solicitud colgada. Para solucionar esto, ponga en cola el recopilador despu\u00e9s de configurar ALL_QUEUED. Esto es un poco forzado y podr\u00eda ser suficiente si no existen subsolicitudes. Tambi\u00e9n agregue un punto de seguimiento para realizar una referencia cruzada de ambas solicitudes en una operaci\u00f3n de copia a solicitud y agregue un seguimiento al punto de seguimiento netfs_rreq para indicar la configuraci\u00f3n de ALL_QUEUED."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/110188a13c4853bd4c342e600ced4dfd26c3feb5", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/89635eae076cd8eaa5cb752f66538c9dc6c9fdc3", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-362"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.0, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 4.7, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "3B1D6837-C0C8-4CC6-9D70-85B362FFE711", "cpe_name": [], "versionStartIncluding": "6.14", "versionEndExcluding": "6.15.8"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.16:rc1:*:*:*:*:*:*", "matchCriteriaId": "6D4894DB-CCFE-4602-B1BF-3960B2E19A01", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.16:rc2:*:*:*:*:*:*", "matchCriteriaId": "09709862-E348-4378-8632-5A7813EDDC86", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.16:rc3:*:*:*:*:*:*", "matchCriteriaId": "415BF58A-8197-43F5-B3D7-D1D63057A26E", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.16:rc4:*:*:*:*:*:*", "matchCriteriaId": "A0517869-312D-4429-80C2-561086E1421C", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.16:rc5:*:*:*:*:*:*", "matchCriteriaId": "85421F4E-C863-4ABF-B4B4-E887CC2F7F92", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.16:rc6:*:*:*:*:*:*", "matchCriteriaId": "3827F0D4-5FEE-4181-B267-5A45E7CA11FC", "cpe_name": []}]}]}}