{"publishedDate": "2025-04-01T16:15Z", "lastModifiedDate": "2025-04-01T20:26Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-21902", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nacpi: typec: ucsi: Introduce a ->poll_cci method\n\nFor the ACPI backend of UCSI the UCSI \"registers\" are just a memory copy\nof the register values in an opregion. The ACPI implementation in the\nBIOS ensures that the opregion contents are synced to the embedded\ncontroller and it ensures that the registers (in particular CCI) are\nsynced back to the opregion on notifications. While there is an ACPI call\nthat syncs the actual registers to the opregion there is rarely a need to\ndo this and on some ACPI implementations it actually breaks in various\ninteresting ways.\n\nThe only reason to force a sync from the embedded controller is to poll\nCCI while notifications are disabled. Only the ucsi core knows if this\nis the case and guessing based on the current command is suboptimal, i.e.\nleading to the following spurious assertion splat:\n\nWARNING: CPU: 3 PID: 76 at drivers/usb/typec/ucsi/ucsi.c:1388 ucsi_reset_ppm+0x1b4/0x1c0 [typec_ucsi]\nCPU: 3 UID: 0 PID: 76 Comm: kworker/3:0 Not tainted 6.12.11-200.fc41.x86_64 #1\nHardware name: LENOVO 21D0/LNVNB161216, BIOS J6CN45WW 03/17/2023\nWorkqueue: events_long ucsi_init_work [typec_ucsi]\nRIP: 0010:ucsi_reset_ppm+0x1b4/0x1c0 [typec_ucsi]\nCall Trace:\n <TASK>\n ucsi_init_work+0x3c/0xac0 [typec_ucsi]\n process_one_work+0x179/0x330\n worker_thread+0x252/0x390\n kthread+0xd2/0x100\n ret_from_fork+0x34/0x50\n ret_from_fork_asm+0x1a/0x30\n </TASK>\n\nThus introduce a ->poll_cci() method that works like ->read_cci() with an\nadditional forced sync and document that this should be used when polling\nwith notifications disabled. For all other backends that presumably don't\nhave this issue use the same implementation for both methods."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: acpi: typec: ucsi: Introducir un m\u00e9todo -&gt;poll_cci. Para el backend ACPI de UCSI, los \"registros\" UCSI son simplemente una copia en memoria de los valores de registro en una regi\u00f3n operativa. La implementaci\u00f3n de ACPI en la BIOS garantiza que el contenido de la regi\u00f3n operativa se sincronice con el controlador integrado y que los registros (en particular, CCI) se sincronicen con la regi\u00f3n operativa en las notificaciones. Si bien existe una llamada ACPI que sincroniza los registros con la regi\u00f3n operativa, rara vez es necesario hacerlo y, en algunas implementaciones de ACPI, falla de diversas maneras interesantes. La \u00fanica raz\u00f3n para forzar una sincronizaci\u00f3n desde el controlador integrado es sondear CCI mientras las notificaciones est\u00e1n deshabilitadas. Solo el n\u00facleo ucsi sabe si este es el caso y las suposiciones basadas en el comando actual no son \u00f3ptimas, es decir, conducen al siguiente mensaje de afirmaci\u00f3n falsa: ADVERTENCIA: CPU: 3 PID: 76 en drivers/usb/typec/ucsi/ucsi.c:1388 ucsi_reset_ppm+0x1b4/0x1c0 [typec_ucsi] CPU: 3 UID: 0 PID: 76 Comm: kworker/3:0 No contaminado 6.12.11-200.fc41.x86_64 #1 Nombre del hardware: LENOVO 21D0/LNVNB161216, BIOS J6CN45WW 17/03/2023 Cola de trabajo: events_long ucsi_init_work [typec_ucsi] RIP: 0010:ucsi_reset_ppm+0x1b4/0x1c0 [typec_ucsi] Seguimiento de llamadas:  ucsi_init_work+0x3c/0xac0 [typec_ucsi] process_one_work+0x179/0x330 workers_thread+0x252/0x390 kthread+0xd2/0x100 ret_from_fork+0x34/0x50 ret_from_fork_asm+0x1a/0x30  Por lo tanto, introduzca un m\u00e9todo -&gt;poll_cci() que funcione como -&gt;read_cci() con una sincronizaci\u00f3n forzada adicional y documente que debe usarse al sondear con las notificaciones deshabilitadas. Para todos los dem\u00e1s backends que presumiblemente no presenten este problema, utilice la misma implementaci\u00f3n para ambos m\u00e9todos."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/012b98cdb54c7d47743ee7fc402fa23f2d90529a", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/1aec5c9066965ac0984e385bbc31455ae31cbffc", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/976e7e9bdc7719a023a4ecccd2e3daec9ab20a40", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}