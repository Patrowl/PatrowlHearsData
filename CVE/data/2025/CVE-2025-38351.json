{"publishedDate": "2025-07-19T12:15Z", "lastModifiedDate": "2025-08-28T15:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-38351", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86/hyper-v: Skip non-canonical addresses during PV TLB flush\n\nIn KVM guests with Hyper-V hypercalls enabled, the hypercalls\nHVCALL_FLUSH_VIRTUAL_ADDRESS_LIST and HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX\nallow a guest to request invalidation of portions of a virtual TLB.\nFor this, the hypercall parameter includes a list of GVAs that are supposed\nto be invalidated.\n\nHowever, when non-canonical GVAs are passed, there is currently no\nfiltering in place and they are eventually passed to checked invocations of\nINVVPID on Intel / INVLPGA on AMD.  While AMD's INVLPGA silently ignores\nnon-canonical addresses (effectively a no-op), Intel's INVVPID explicitly\nsignals VM-Fail and ultimately triggers the WARN_ONCE in invvpid_error():\n\n  invvpid failed: ext=0x0 vpid=1 gva=0xaaaaaaaaaaaaa000\n  WARNING: CPU: 6 PID: 326 at arch/x86/kvm/vmx/vmx.c:482\n  invvpid_error+0x91/0xa0 [kvm_intel]\n  Modules linked in: kvm_intel kvm 9pnet_virtio irqbypass fuse\n  CPU: 6 UID: 0 PID: 326 Comm: kvm-vm Not tainted 6.15.0 #14 PREEMPT(voluntary)\n  RIP: 0010:invvpid_error+0x91/0xa0 [kvm_intel]\n  Call Trace:\n    vmx_flush_tlb_gva+0x320/0x490 [kvm_intel]\n    kvm_hv_vcpu_flush_tlb+0x24f/0x4f0 [kvm]\n    kvm_arch_vcpu_ioctl_run+0x3013/0x5810 [kvm]\n\nHyper-V documents that invalid GVAs (those that are beyond a partition's\nGVA space) are to be ignored.  While not completely clear whether this\nruling also applies to non-canonical GVAs, it is likely fine to make that\nassumption, and manual testing on Azure confirms \"real\" Hyper-V interprets\nthe specification in the same way.\n\nSkip non-canonical GVAs when processing the list of address to avoid\ntripping the INVVPID failure.  Alternatively, KVM could filter out \"bad\"\nGVAs before inserting into the FIFO, but practically speaking the only\ndownside of pushing validation to the final processing is that doing so\nis suboptimal for the guest, and no well-behaved guest will request TLB\nflushes for non-canonical addresses."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM: x86/Hyper-V: Omisi\u00f3n de direcciones no can\u00f3nicas durante el vaciado de TLB de PV. En invitados KVM con hiperllamadas de Hyper-V habilitadas, las hiperllamadas HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST y HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX permiten que un invitado solicite la invalidaci\u00f3n de partes de una TLB virtual. Para ello, el par\u00e1metro hypercall incluye una lista de GVA que se supone que deben invalidarse. Sin embargo, cuando se pasan GVA no can\u00f3nicos, actualmente no hay ning\u00fan filtrado implementado y finalmente se pasan a invocaciones comprobadas de INVVPID en Intel / INVLPGA en AMD. Mientras que el INVLPGA de AMD ignora silenciosamente las direcciones no can\u00f3nicas (efectivamente, una operaci\u00f3n nula), el INVVPID de Intel se\u00f1ala expl\u00edcitamente VM-Fail y, en \u00faltima instancia, activa WARN_ONCE en invvpid_error(): invvpid failed: ext=0x0 vpid=1 gva=0xaaaaaaaaaaaaa000 WARNING: CPU: 6 PID: 326 at arch/x86/kvm/vmx/vmx.c:482 invvpid_error+0x91/0xa0 [kvm_intel] Modules linked in: kvm_intel kvm 9pnet_virtio irqbypass fuse CPU: 6 UID: 0 PID: 326 Comm: kvm-vm Not tainted 6.15.0 #14 PREEMPT(voluntary) RIP: 0010:invvpid_error+0x91/0xa0 [kvm_intel] Seguimiento de llamadas: vmx_flush_tlb_gva+0x320/0x490 [kvm_intel] kvm_hv_vcpu_flush_tlb+0x24f/0x4f0 [kvm] kvm_arch_vcpu_ioctl_run+0x3013/0x5810 [kvm] Hyper-V informa que las GVA no v\u00e1lidas (aquellas que superan el espacio de GVA de una partici\u00f3n) deben ignorarse. Aunque no est\u00e1 del todo claro si esta regla tambi\u00e9n se aplica a las GVA no can\u00f3nicas, es probable que sea correcto asumirlo, y las pruebas manuales en Azure confirman que Hyper-V \"real\" interpreta la especificaci\u00f3n de la misma manera. Omita las GVA no can\u00f3nicas al procesar la lista de direcciones para evitar el error INVVPID. Como alternativa, KVM podr\u00eda filtrar los GVA \"malos\" antes de insertarlos en el FIFO, pero en t\u00e9rminos pr\u00e1cticos, la \u00fanica desventaja de trasladar la validaci\u00f3n al procesamiento final es que hacerlo no es \u00f3ptimo para el invitado y ning\u00fan invitado que se comporte bien solicitar\u00e1 vaciados de TLB para direcciones no can\u00f3nicas."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/2d4dea3f76510c0afe3f18c910f647b816f7d566", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/d5784ea45663330eaa868c518ea40e7a9f06aa2d", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f1b3ad11ec11c88ba9f79a73d27d4cda3f80fb24", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/fa787ac07b3ceb56dd88a62d1866038498e96230", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}