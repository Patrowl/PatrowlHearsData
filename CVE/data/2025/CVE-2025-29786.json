{"publishedDate": "2025-03-17T14:15Z", "lastModifiedDate": "2025-03-17T14:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-29786", "ASSIGNER": "security-advisories@github.com"}, "description": {"description_data": [{"lang": "en", "value": "Expr is an expression language and expression evaluation for Go. Prior to version 1.17.0, if the Expr expression parser is given an unbounded input string, it will attempt to compile the entire string and generate an Abstract Syntax Tree (AST) node for each part of the expression. In scenarios where input size isn\u2019t limited, a malicious or inadvertent extremely large expression can consume excessive memory as the parser builds a huge AST. This can ultimately lead to*excessive memory usage and an Out-Of-Memory (OOM) crash of the process. This issue is relatively uncommon and will only manifest when there are no restrictions on the input size, i.e. the expression length is allowed to grow arbitrarily large. In typical use cases where inputs are bounded or validated, this problem would not occur. The problem has been patched in the latest versions of the Expr library. The fix introduces compile-time limits on the number of AST nodes and memory usage during parsing, preventing any single expression from exhausting resources. Users should upgrade to Expr version 1.17.0 or later, as this release includes the new node budget and memory limit safeguards. Upgrading to v1.17.0 ensures that extremely deep or large expressions are detected and safely aborted during compilation, avoiding the OOM condition. For users who cannot immediately upgrade, the recommended workaround is to impose an input size restriction before parsing. In practice, this means validating or limiting the length of expression strings that your application will accept. For example, set a maximum allowable number of characters (or nodes) for any expression and reject or truncate inputs that exceed this limit. By ensuring no unbounded-length expression is ever fed into the parser, one can prevent the parser from constructing a pathologically large AST and avoid potential memory exhaustion. In short, pre-validate and cap input size as a safeguard in the absence of the patch."}, {"lang": "es", "value": "Expr es un lenguaje de expresiones y un sistema de evaluaci\u00f3n de expresiones para Go. Antes de la versi\u00f3n 1.17.0, si el analizador de expresiones Expr recib\u00eda una cadena de entrada ilimitada, intentaba compilarla completa y generar un nodo de \u00c1rbol de Sintaxis Abstracta (AST) para cada parte de la expresi\u00f3n. En escenarios donde el tama\u00f1o de entrada no est\u00e1 limitado, una expresi\u00f3n extremadamente grande, maliciosa o inadvertida, puede consumir demasiada memoria mientras el analizador construye un AST enorme. Esto puede provocar un uso excesivo de memoria y un fallo del proceso por falta de memoria (OOM). Este problema es relativamente poco com\u00fan y solo se manifiesta cuando no hay restricciones en el tama\u00f1o de entrada, es decir, cuando se permite que la longitud de la expresi\u00f3n crezca arbitrariamente. En casos de uso t\u00edpicos donde las entradas est\u00e1n limitadas o validadas, este problema no se produc\u00eda. El problema se ha corregido en las \u00faltimas versiones de la librer\u00eda Expr. La correcci\u00f3n introduce l\u00edmites en tiempo de compilaci\u00f3n en el n\u00famero de nodos AST y el uso de memoria durante el an\u00e1lisis, lo que evita que una sola expresi\u00f3n agote los recursos. Los usuarios deben actualizar a la versi\u00f3n 1.17.0 de Expr o posterior, ya que esta versi\u00f3n incluye las nuevas protecciones de presupuesto de nodos y l\u00edmite de memoria. Actualizar a la versi\u00f3n 1.17.0 garantiza la detecci\u00f3n y cancelaci\u00f3n segura de expresiones extremadamente profundas o grandes durante la compilaci\u00f3n, evitando as\u00ed la condici\u00f3n OOM. Para los usuarios que no puedan actualizar inmediatamente, el workaround recomendada es imponer una restricci\u00f3n de tama\u00f1o de entrada antes del an\u00e1lisis. En la pr\u00e1ctica, esto significa validar o limitar la longitud de las cadenas de expresi\u00f3n que acepta la aplicaci\u00f3n. Por ejemplo, establezca un n\u00famero m\u00e1ximo permitido de caracteres (o nodos) para cualquier expresi\u00f3n y rechace o trunque las entradas que superen este l\u00edmite. Al garantizar que nunca se introduzca ninguna expresi\u00f3n de longitud ilimitada en el analizador, se puede evitar que el analizador construya un AST patol\u00f3gicamente grande y evitar el posible agotamiento de la memoria. En resumen, valide previamente y limite el tama\u00f1o de entrada como medida de seguridad en ausencia del parche."}]}, "references": {"reference_data": [{"url": "https://github.com/expr-lang/expr/pull/762", "name": "", "refsource": "", "tags": []}, {"url": "https://github.com/expr-lang/expr/security/advisories/GHSA-93mq-9ffx-83m2", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-770"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 3.9, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "baseScore": 7.5, "baseSeverity": "HIGH", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}