{"publishedDate": "2025-07-03T09:15Z", "lastModifiedDate": "2025-07-03T15:13Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-38097", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nespintcp: remove encap socket caching to avoid reference leak\n\nThe current scheme for caching the encap socket can lead to reference\nleaks when we try to delete the netns.\n\nThe reference chain is: xfrm_state -> enacp_sk -> netns\n\nSince the encap socket is a userspace socket, it holds a reference on\nthe netns. If we delete the espintcp state (through flush or\nindividual delete) before removing the netns, the reference on the\nsocket is dropped and the netns is correctly deleted. Otherwise, the\nnetns may not be reachable anymore (if all processes within the ns\nhave terminated), so we cannot delete the xfrm state to drop its\nreference on the socket.\n\nThis patch results in a small (~2% in my tests) performance\nregression.\n\nA GC-type mechanism could be added for the socket cache, to clear\nreferences if the state hasn't been used \"recently\", but it's a lot\nmore complex than just not caching the socket."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: espintcp: eliminar el almacenamiento en cach\u00e9 del socket encap para evitar fugas de referencia El esquema actual para almacenar en cach\u00e9 el socket encap puede provocar fugas de referencia cuando intentamos eliminar los netns. La cadena de referencia es: xfrm_state -&gt; enacp_sk -&gt; netns Dado que el socket encap es un socket de espacio de usuario, contiene una referencia en los netns. Si eliminamos el estado de espintcp (a trav\u00e9s de vaciado o eliminaci\u00f3n individual) antes de eliminar los netns, la referencia en el socket se elimina y los netns se eliminan correctamente. De lo contrario, los netns pueden no ser accesibles m\u00e1s (si todos los procesos dentro de los ns han terminado), por lo que no podemos eliminar el estado xfrm para eliminar su referencia en el socket. Este parche da como resultado una peque\u00f1a regresi\u00f3n del rendimiento (~2% en mis pruebas). Se podr\u00eda agregar un mecanismo de tipo GC para el cach\u00e9 del socket, para borrar referencias si el estado no se ha usado \"recientemente\", pero es mucho m\u00e1s complejo que simplemente no almacenar en cach\u00e9 el socket."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/028363685bd0b7a19b4a820f82dd905b1dc83999", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/74fd327767fb784c5875cf7c4ba1217f26020943", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/9cbca30102028f9ad3d2098f935c4368f581fd07", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/b58a295d10065960bcb9d60cb8ca6ead9837cd27", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e4cde54b46a87231c77256a633be1bef62687d69", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}