{"publishedDate": "2025-02-27T20:16Z", "lastModifiedDate": "2025-06-04T13:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-21816", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nhrtimers: Force migrate away hrtimers queued after CPUHP_AP_HRTIMERS_DYING\n\nhrtimers are migrated away from the dying CPU to any online target at\nthe CPUHP_AP_HRTIMERS_DYING stage in order not to delay bandwidth timers\nhandling tasks involved in the CPU hotplug forward progress.\n\nHowever wakeups can still be performed by the outgoing CPU after\nCPUHP_AP_HRTIMERS_DYING. Those can result again in bandwidth timers being\narmed. Depending on several considerations (crystal ball power management\nbased election, earliest timer already enqueued, timer migration enabled or\nnot), the target may eventually be the current CPU even if offline. If that\nhappens, the timer is eventually ignored.\n\nThe most notable example is RCU which had to deal with each and every of\nthose wake-ups by deferring them to an online CPU, along with related\nworkarounds:\n\n_ e787644caf76 (rcu: Defer RCU kthreads wakeup when CPU is dying)\n_ 9139f93209d1 (rcu/nocb: Fix RT throttling hrtimer armed from offline CPU)\n_ f7345ccc62a4 (rcu/nocb: Fix rcuog wake-up from offline softirq)\n\nThe problem isn't confined to RCU though as the stop machine kthread\n(which runs CPUHP_AP_HRTIMERS_DYING) reports its completion at the end\nof its work through cpu_stop_signal_done() and performs a wake up that\neventually arms the deadline server timer:\n\n   WARNING: CPU: 94 PID: 588 at kernel/time/hrtimer.c:1086 hrtimer_start_range_ns+0x289/0x2d0\n   CPU: 94 UID: 0 PID: 588 Comm: migration/94 Not tainted\n   Stopper: multi_cpu_stop+0x0/0x120 <- stop_machine_cpuslocked+0x66/0xc0\n   RIP: 0010:hrtimer_start_range_ns+0x289/0x2d0\n   Call Trace:\n   <TASK>\n     start_dl_timer\n     enqueue_dl_entity\n     dl_server_start\n     enqueue_task_fair\n     enqueue_task\n     ttwu_do_activate\n     try_to_wake_up\n     complete\n     cpu_stopper_thread\n\nInstead of providing yet another bandaid to work around the situation, fix\nit in the hrtimers infrastructure instead: always migrate away a timer to\nan online target whenever it is enqueued from an offline CPU.\n\nThis will also allow to revert all the above RCU disgraceful hacks."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: hrtimers: fuerza la migraci\u00f3n de los hrtimers en cola despu\u00e9s de CPUHP_AP_HRTIMERS_DYING. Los hrtimers se migran desde la CPU que se est\u00e1 muriendo a cualquier destino en l\u00ednea en la etapa CPUHP_AP_HRTIMERS_DYING para no retrasar las tareas de gesti\u00f3n de los temporizadores de ancho de banda involucradas en el progreso de avance de la conexi\u00f3n en caliente de la CPU. Sin embargo, las reactivaciones a\u00fan pueden ser realizadas por la CPU saliente despu\u00e9s de CPUHP_AP_HRTIMERS_DYING. Esto puede dar como resultado nuevamente que los temporizadores de ancho de banda se activen. Dependiendo de varias consideraciones (elecci\u00f3n basada en administraci\u00f3n de energ\u00eda de Crystal Ball, temporizador m\u00e1s antiguo ya en cola, migraci\u00f3n de temporizador habilitada o no), el destino puede eventualmente ser la CPU actual incluso si est\u00e1 fuera de l\u00ednea. Si eso sucede, el temporizador eventualmente se ignora. El ejemplo m\u00e1s notable es RCU, que tuvo que lidiar con todos y cada uno de esos despertares difiri\u00e9ndolos a una CPU en l\u00ednea, junto con workarounds relacionados: _ e787644caf76 (rcu: Diferir el despertar de kthreads de RCU cuando la CPU est\u00e1 muriendo) _ 9139f93209d1 (rcu/nocb: Reparar la limitaci\u00f3n de RT de hrtimer armado desde una CPU fuera de l\u00ednea) _ f7345ccc62a4 (rcu/nocb: Reparar el despertar de rcuog desde softirq fuera de l\u00ednea) El problema no se limita a RCU, ya que el kthread de la m\u00e1quina de detenci\u00f3n (que ejecuta CPUHP_AP_HRTIMERS_DYING) informa su finalizaci\u00f3n al final de su trabajo a trav\u00e9s de cpu_stop_signal_done() y realiza un despertar que eventualmente arma el temporizador del servidor de fecha l\u00edmite: ADVERTENCIA: CPU: 94 PID: 588 en kernel/time/hrtimer.c:1086 hrtimer_start_range_ns+0x289/0x2d0 CPU: 94 UID: 0 PID: 588 Comm: immigration/94 No contaminado Detenedor: multi_cpu_stop+0x0/0x120 &lt;- stop_machine_cpuslocked+0x66/0xc0 RIP: 0010:hrtimer_start_range_ns+0x289/0x2d0 Rastreo de llamadas:  start_dl_timer enqueue_dl_entity dl_server_start enqueue_task_fair enqueue_task ttwu_do_activate try_to_wake_up complete cpu_stopper_thread En lugar de proporcionar otro workaround para solucionar la situaci\u00f3n, corr\u00edjala en la infraestructura de hrtimers: siempre migre un temporizador a un destino en l\u00ednea cuando se ponga en cola desde una CPU fuera de l\u00ednea. Esto tambi\u00e9n permitir\u00e1 revertir todos los vergonzosos hackeos de RCU mencionados anteriormente."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/2aecec58e9040ce3d2694707889f9914a2374955", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/53dac345395c0d2493cbc2f4c85fe38aef5b63f5", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/63815bef47ec25f5a125019ca480882481ee1553", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/82ac6adbbb2aad14548a71d5e2e37f4964a15e38", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e456a88bddae4030ba962447bb84be6669f2a0c1", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}