{"publishedDate": "2025-05-01T13:15Z", "lastModifiedDate": "2025-10-02T14:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2025-23143", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: Fix null-ptr-deref by sock_lock_init_class_and_name() and rmmod.\n\nWhen I ran the repro [0] and waited a few seconds, I observed two\nLOCKDEP splats: a warning immediately followed by a null-ptr-deref. [1]\n\nReproduction Steps:\n\n  1) Mount CIFS\n  2) Add an iptables rule to drop incoming FIN packets for CIFS\n  3) Unmount CIFS\n  4) Unload the CIFS module\n  5) Remove the iptables rule\n\nAt step 3), the CIFS module calls sock_release() for the underlying\nTCP socket, and it returns quickly.  However, the socket remains in\nFIN_WAIT_1 because incoming FIN packets are dropped.\n\nAt this point, the module's refcnt is 0 while the socket is still\nalive, so the following rmmod command succeeds.\n\n  # ss -tan\n  State      Recv-Q Send-Q Local Address:Port  Peer Address:Port\n  FIN-WAIT-1 0      477        10.0.2.15:51062   10.0.0.137:445\n\n  # lsmod | grep cifs\n  cifs                 1159168  0\n\nThis highlights a discrepancy between the lifetime of the CIFS module\nand the underlying TCP socket.  Even after CIFS calls sock_release()\nand it returns, the TCP socket does not die immediately in order to\nclose the connection gracefully.\n\nWhile this is generally fine, it causes an issue with LOCKDEP because\nCIFS assigns a different lock class to the TCP socket's sk->sk_lock\nusing sock_lock_init_class_and_name().\n\nOnce an incoming packet is processed for the socket or a timer fires,\nsk->sk_lock is acquired.\n\nThen, LOCKDEP checks the lock context in check_wait_context(), where\nhlock_class() is called to retrieve the lock class.  However, since\nthe module has already been unloaded, hlock_class() logs a warning\nand returns NULL, triggering the null-ptr-deref.\n\nIf LOCKDEP is enabled, we must ensure that a module calling\nsock_lock_init_class_and_name() (CIFS, NFS, etc) cannot be unloaded\nwhile such a socket is still alive to prevent this issue.\n\nLet's hold the module reference in sock_lock_init_class_and_name()\nand release it when the socket is freed in sk_prot_free().\n\nNote that sock_lock_init() clears sk->sk_owner for svc_create_socket()\nthat calls sock_lock_init_class_and_name() for a listening socket,\nwhich clones a socket by sk_clone_lock() without GFP_ZERO.\n\n[0]:\nCIFS_SERVER=\"10.0.0.137\"\nCIFS_PATH=\"//${CIFS_SERVER}/Users/Administrator/Desktop/CIFS_TEST\"\nDEV=\"enp0s3\"\nCRED=\"/root/WindowsCredential.txt\"\n\nMNT=$(mktemp -d /tmp/XXXXXX)\nmount -t cifs ${CIFS_PATH} ${MNT} -o vers=3.0,credentials=${CRED},cache=none,echo_interval=1\n\niptables -A INPUT -s ${CIFS_SERVER} -j DROP\n\nfor i in $(seq 10);\ndo\n    umount ${MNT}\n    rmmod cifs\n    sleep 1\ndone\n\nrm -r ${MNT}\n\niptables -D INPUT -s ${CIFS_SERVER} -j DROP\n\n[1]:\nDEBUG_LOCKS_WARN_ON(1)\nWARNING: CPU: 10 PID: 0 at kernel/locking/lockdep.c:234 hlock_class (kernel/locking/lockdep.c:234 kernel/locking/lockdep.c:223)\nModules linked in: cifs_arc4 nls_ucs2_utils cifs_md4 [last unloaded: cifs]\nCPU: 10 UID: 0 PID: 0 Comm: swapper/10 Not tainted 6.14.0 #36\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\nRIP: 0010:hlock_class (kernel/locking/lockdep.c:234 kernel/locking/lockdep.c:223)\n...\nCall Trace:\n <IRQ>\n __lock_acquire (kernel/locking/lockdep.c:4853 kernel/locking/lockdep.c:5178)\n lock_acquire (kernel/locking/lockdep.c:469 kernel/locking/lockdep.c:5853 kernel/locking/lockdep.c:5816)\n _raw_spin_lock_nested (kernel/locking/spinlock.c:379)\n tcp_v4_rcv (./include/linux/skbuff.h:1678 ./include/net/tcp.h:2547 net/ipv4/tcp_ipv4.c:2350)\n...\n\nBUG: kernel NULL pointer dereference, address: 00000000000000c4\n PF: supervisor read access in kernel mode\n PF: error_code(0x0000) - not-present page\nPGD 0\nOops: Oops: 0000 [#1] PREEMPT SMP NOPTI\nCPU: 10 UID: 0 PID: 0 Comm: swapper/10 Tainted: G        W          6.14.0 #36\nTainted: [W]=WARN\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 04/01/2014\nRIP: 0010:__lock_acquire (kernel/\n---truncated---"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net: Fix null-ptr-deref por sock_lock_init_class_and_name() y rmmod. Cuando ejecut\u00e9 la reproducci\u00f3n [0] y esper\u00e9 unos segundos, observ\u00e9 dos s\u00edmbolos LOCKDEP: una advertencia seguida inmediatamente por un null-ptr-deref. [1] Pasos de reproducci\u00f3n: 1) Montar CIFS 2) Agregar una regla de iptables para descartar los paquetes FIN entrantes para CIFS 3) Desmontar CIFS 4) Descargar el m\u00f3dulo CIFS 5) Eliminar la regla de iptables En el paso 3), el m\u00f3dulo CIFS llama a sock_release() para el socket TCP subyacente y regresa r\u00e1pidamente. Sin embargo, el socket permanece en FIN_WAIT_1 porque los paquetes FIN entrantes se descartan. En este punto, el refcnt del m\u00f3dulo es 0 mientras el socket sigue activo, por lo que el siguiente comando rmmod tiene \u00e9xito. # ss -tan State Recv-Q Send-Q Local Address:Port Peer Address:Port FIN-WAIT-1 0 477 10.0.2.15:51062 10.0.0.137:445 # lsmod | grep cifs cifs 1159168 0 Esto indica una discrepancia entre la duraci\u00f3n del m\u00f3dulo CIFS y el socket TCP subyacente. Incluso despu\u00e9s de que CIFS invoque sock_release() y este regrese, el socket TCP no se cierra inmediatamente para cerrar la conexi\u00f3n correctamente. Si bien esto generalmente funciona bien, causa un problema con LOCKDEP, ya que CIFS asigna una clase de bloqueo diferente al sk-&gt;sk_lock del socket TCP mediante sock_lock_init_class_and_name(). Una vez que se procesa un paquete entrante para el socket o se activa un temporizador, se adquiere sk-&gt;sk_lock. Luego, LOCKDEP verifica el contexto de bloqueo en check_wait_context(), donde se llama a hlock_class() para recuperar la clase de bloqueo. Sin embargo, dado que el m\u00f3dulo ya se ha descargado, hlock_class() registra una advertencia y devuelve NULL, lo que activa la desreferencia null-ptr. Si LOCKDEP est\u00e1 habilitado, debemos asegurarnos de que un m\u00f3dulo que llama a sock_lock_init_class_and_name() (CIFS, NFS, etc.) no pueda descargarse mientras dicho socket siga activo para evitar este problema. Mantendremos la referencia del m\u00f3dulo en sock_lock_init_class_and_name() y la liberaremos cuando el socket se libere en sk_prot_free(). Tenga en cuenta que sock_lock_init() borra sk-&gt;sk_owner para svc_create_socket(), que llama a sock_lock_init_class_and_name() para un socket que escucha, lo que clona un socket mediante sk_clone_lock() sin GFP_ZERO. [0]: CIFS_SERVER=\"10.0.0.137\" CIFS_PATH=\"//${CIFS_SERVER}/Usuarios/Administrador/Escritorio/CIFS_TEST\" DEV=\"enp0s3\" CRED=\"/root/WindowsCredential.txt\" MNT=$(mktemp -d /tmp/XXXXXX) mount -t cifs ${CIFS_PATH} ${MNT} -o vers=3.0,credenciales=${CRED},cach\u00e9=ninguno,intervalo_de_eco=1 iptables -A INPUT -s ${CIFS_SERVER} -j DROP para i en $(seq 10); Desmontar ${MNT} rmmod cifs sleep 1 hecho rm -r ${MNT} iptables -D INPUT -s ${CIFS_SERVER} -j DROP [1]: DEBUG_LOCKS_WARN_ON(1) ADVERTENCIA: CPU: 10 PID: 0 en kernel/locking/lockdep.c:234 hlock_class (kernel/locking/lockdep.c:234 kernel/locking/lockdep.c:223) M\u00f3dulos enlazados en: cifs_arc4 nls_ucs2_utils cifs_md4 [\u00faltima descarga: cifs] CPU: 10 UID: 0 PID: 0 Comm: swapper/10 No contaminado 6.14.0 #36 Nombre del hardware: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.16.0-0-gd239552ce722-prebuilt.qemu.org 01/04/2014 RIP: 0010:hlock_class (kernel/locking/lockdep.c:234 kernel/locking/lockdep.c:223) ... Rastreo de llamadas:  __lock_acquire (kernel/locking/lockdep.c:4853 kernel/locking/lockdep.c:5178) lock_acquire (kernel/locking/lockdep.c:469 kernel/locking/lockdep.c:5853 kernel/locking/lockdep.c:5816) _raw_spin_lock_nested (kernel/locking/spinlock.c:379) tcp_v4_rcv (./include/linux/skbuff.h:1678 ./include/net/tcp.h:2547 net/ipv4/tcp_ipv4.c:2350) ... ERROR: desreferencia de puntero NULL del n\u00facleo, direcci\u00f3n: 00000000000000c4 PF: acceso de lectura del supervisor en modo n\u00facleo PF: error_code(0x0000) - p\u00e1gina no presente PGD 0 Oops: Oops: 0000 [#1] PREEMPT SMP NOPTI CPU: 10 UID: 0 PID: 0 Comm: swapper/10 Contaminado: GW 6.14.0 #36 Contaminado: [W]=WARN Nombre del hardware: QEMU Standard PC (i440FX + PIIX, ---truncado---"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/0bb2f7a1ad1f11d861f58e5ee5051c8974ff9569", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/2155802d3313d7b8365935c6b8d6edc0ddd7eb94", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/5f7f6abd92b6c8dc8f19625ef93c3a18549ede04", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/83083c5fc7cf9b0f136a42f26aba60da380f3601", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/905d43b8ad2436c240f844acb3ebcc7a99b8ebf1", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/b7489b753667bc9245958a4896c9419743083c27", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/c11247a21aab4b50a23c8b696727d7483de2f1e1", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/d51e47e2ab6ef10a317d576075cf625cdbf96426", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/feda73ad44a5cc80f6bf796bb1099a3fe71576d4", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}