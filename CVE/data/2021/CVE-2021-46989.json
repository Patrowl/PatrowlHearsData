{"publishedDate": "2024-02-28T09:15Z", "lastModifiedDate": "2025-03-14T19:02Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2021-46989", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nhfsplus: prevent corruption in shrinking truncate\n\nI believe there are some issues introduced by commit 31651c607151\n(\"hfsplus: avoid deadlock on file truncation\")\n\nHFS+ has extent records which always contains 8 extents.  In case the\nfirst extent record in catalog file gets full, new ones are allocated from\nextents overflow file.\n\nIn case shrinking truncate happens to middle of an extent record which\nlocates in extents overflow file, the logic in hfsplus_file_truncate() was\nchanged so that call to hfs_brec_remove() is not guarded any more.\n\nRight action would be just freeing the extents that exceed the new size\ninside extent record by calling hfsplus_free_extents(), and then check if\nthe whole extent record should be removed.  However since the guard\n(blk_cnt > start) is now after the call to hfs_brec_remove(), this has\nunfortunate effect that the last matching extent record is removed\nunconditionally.\n\nTo reproduce this issue, create a file which has at least 10 extents, and\nthen perform shrinking truncate into middle of the last extent record, so\nthat the number of remaining extents is not under or divisible by 8.  This\ncauses the last extent record (8 extents) to be removed totally instead of\ntruncating into middle of it.  Thus this causes corruption, and lost data.\n\nFix for this is simply checking if the new truncated end is below the\nstart of this extent record, making it safe to remove the full extent\nrecord.  However call to hfs_brec_remove() can't be moved to it's previous\nplace since we're dropping ->tree_lock and it can cause a race condition\nand the cached info being invalidated possibly corrupting the node data.\n\nAnother issue is related to this one.  When entering into the block\n(blk_cnt > start) we are not holding the ->tree_lock.  We break out from\nthe loop not holding the lock, but hfs_find_exit() does unlock it.  Not\nsure if it's possible for someone else to take the lock under our feet,\nbut it can cause hard to debug errors and premature unlocking.  Even if\nthere's no real risk of it, the locking should still always be kept in\nbalance.  Thus taking the lock now just before the check."}, {"lang": "es", "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: hfsplus: evita la corrupci\u00f3n al reducir y truncar Creo que hay algunos problemas introducidos por el commit 31651c607151 (\"hfsplus: evita el punto muerto en el truncamiento de archivos\") HFS+ tiene registros de extensi\u00f3n que siempre contienen 8 extensiones. En caso de que el primer registro de extensi\u00f3n en el archivo de cat\u00e1logo se llene, se asignan nuevos registros desde el archivo de desbordamiento de extensiones. En caso de que se produzca un truncamiento reducido en la mitad de un registro de extensi\u00f3n que se ubica en un archivo de desbordamiento de extensiones, la l\u00f3gica en hfsplus_file_truncate() se cambi\u00f3 para que la llamada a hfs_brec_remove() ya no est\u00e9 protegida. La acci\u00f3n correcta ser\u00eda simplemente liberar las extensiones que exceden el nuevo tama\u00f1o dentro del registro de extensi\u00f3n llamando a hfsplus_free_extents() y luego verificar si se debe eliminar todo el registro de extensi\u00f3n. Sin embargo, dado que la guardia (blk_cnt &gt; start) est\u00e1 ahora despu\u00e9s de la llamada a hfs_brec_remove(), esto tiene el efecto desafortunado de que el \u00faltimo registro de extensi\u00f3n coincidente se elimina incondicionalmente. Para reproducir este problema, cree un archivo que tenga al menos 10 extensiones y luego realice un truncamiento reducido hasta la mitad del \u00faltimo registro de extensi\u00f3n, de modo que el n\u00famero de extensiones restantes no sea menor o divisible por 8. Esto hace que el \u00faltimo registro de extensi\u00f3n ( 8 extensiones) para eliminarse por completo en lugar de truncarse a la mitad. Por tanto, esto provoca corrupci\u00f3n y p\u00e9rdida de datos. La soluci\u00f3n para esto es simplemente verificar si el nuevo final truncado est\u00e1 debajo del inicio de este registro de extensi\u00f3n, lo que hace que sea seguro eliminar el registro de extensi\u00f3n completo. Sin embargo, la llamada a hfs_brec_remove() no se puede mover a su lugar anterior ya que estamos eliminando -&gt;tree_lock y puede provocar una condici\u00f3n de ejecuci\u00f3n y la invalidaci\u00f3n de la informaci\u00f3n almacenada en cach\u00e9, posiblemente corrompiendo los datos del nodo. Otro tema est\u00e1 relacionado con \u00e9ste. Al ingresar al bloque (blk_cnt &gt; start) no mantenemos -&gt;tree_lock. Salimos del bucle sin mantener el bloqueo, pero hfs_find_exit() lo desbloquea. No estoy seguro de si es posible que otra persona tome el bloqueo bajo nuestros pies, pero puede causar errores dif\u00edciles de depurar y desbloqueo prematuro. Aunque no exista ning\u00fan riesgo real, el bloqueo siempre debe mantenerse en equilibrio. Tomando as\u00ed el candado ahora justo antes del control."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/52dde855663e5db824af51db39b5757d2ef3e28a", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/97314e45aa1223a42d60256a62c5d9af54baf446", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/adbd8a2a8cc05d9e501f93e5c95c59307874cc99", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/c3187cf32216313fb316084efac4dab3a8459b1d", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/c451a6bafb5f422197d31536f82116aed132b72c", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/c477f62db1a0c0ecaa60a29713006ceeeb04b685", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/52dde855663e5db824af51db39b5757d2ef3e28a", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/97314e45aa1223a42d60256a62c5d9af54baf446", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/adbd8a2a8cc05d9e501f93e5c95c59307874cc99", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/c3187cf32216313fb316084efac4dab3a8459b1d", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/c451a6bafb5f422197d31536f82116aed132b72c", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/c477f62db1a0c0ecaa60a29713006ceeeb04b685", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-Other"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "64B18B0C-5B02-4506-ADE4-6B1430542B99", "cpe_name": [], "versionStartIncluding": "4.19", "versionEndExcluding": "4.19.191"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "2BDC71CF-4451-4D53-93E9-61DE7C4E25B0", "cpe_name": [], "versionStartIncluding": "4.20", "versionEndExcluding": "5.4.120"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "2BB4E5E8-4AAD-475A-A1B9-F287254C7D72", "cpe_name": [], "versionStartIncluding": "5.5", "versionEndExcluding": "5.10.38"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "83B53E9A-F426-4C03-9A5F-A931FF79827E", "cpe_name": [], "versionStartIncluding": "5.11", "versionEndExcluding": "5.11.22"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "0274929A-B36C-4F4C-AB22-30A0DD6B995B", "cpe_name": [], "versionStartIncluding": "5.12", "versionEndExcluding": "5.12.5"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:5.13:rc1:*:*:*:*:*:*", "matchCriteriaId": "0CBAD0FC-C281-4666-AB2F-F8E6E1165DF7", "cpe_name": []}]}]}}