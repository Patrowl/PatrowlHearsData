{"publishedDate": "2024-05-22T07:15Z", "lastModifiedDate": "2024-11-21T06:36Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2021-47460", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nocfs2: fix data corruption after conversion from inline format\n\nCommit 6dbf7bb55598 (\"fs: Don't invalidate page buffers in\nblock_write_full_page()\") uncovered a latent bug in ocfs2 conversion\nfrom inline inode format to a normal inode format.\n\nThe code in ocfs2_convert_inline_data_to_extents() attempts to zero out\nthe whole cluster allocated for file data by grabbing, zeroing, and\ndirtying all pages covering this cluster.  However these pages are\nbeyond i_size, thus writeback code generally ignores these dirty pages\nand no blocks were ever actually zeroed on the disk.\n\nThis oversight was fixed by commit 693c241a5f6a (\"ocfs2: No need to zero\npages past i_size.\") for standard ocfs2 write path, inline conversion\npath was apparently forgotten; the commit log also has a reasoning why\nthe zeroing actually is not needed.\n\nAfter commit 6dbf7bb55598, things became worse as writeback code stopped\ninvalidating buffers on pages beyond i_size and thus these pages end up\nwith clean PageDirty bit but with buffers attached to these pages being\nstill dirty.  So when a file is converted from inline format, then\nwriteback triggers, and then the file is grown so that these pages\nbecome valid, the invalid dirtiness state is preserved,\nmark_buffer_dirty() does nothing on these pages (buffers are already\ndirty) but page is never written back because it is clean.  So data\nwritten to these pages is lost once pages are reclaimed.\n\nSimple reproducer for the problem is:\n\n  xfs_io -f -c \"pwrite 0 2000\" -c \"pwrite 2000 2000\" -c \"fsync\" \\\n    -c \"pwrite 4000 2000\" ocfs2_file\n\nAfter unmounting and mounting the fs again, you can observe that end of\n'ocfs2_file' has lost its contents.\n\nFix the problem by not doing the pointless zeroing during conversion\nfrom inline format similarly as in the standard write path.\n\n[akpm@linux-foundation.org: fix whitespace, per Joseph]"}, {"lang": "es", "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: ocfs2: corrige la corrupci\u00f3n de datos despu\u00e9s de la conversi\u00f3n desde el formato en l\u00ednea. el commit 6dbf7bb55598 (\"fs: No invalide los buffers de p\u00e1gina en block_write_full_page()\") descubri\u00f3 un error latente en la conversi\u00f3n de ocfs2 desde el inodo en l\u00ednea. formato a un formato de inodo normal. El c\u00f3digo en ocfs2_convert_inline_data_to_extents() intenta poner a cero todo el cl\u00faster asignado para datos de archivos capturando, poniendo a cero y ensuciando todas las p\u00e1ginas que cubren este cl\u00faster. Sin embargo, estas p\u00e1ginas est\u00e1n m\u00e1s all\u00e1 de i_size, por lo que el c\u00f3digo de reescritura generalmente ignora estas p\u00e1ginas sucias y nunca se puso a cero ning\u00fan bloque en el disco. Este descuido se solucion\u00f3 mediante el commit 693c241a5f6a (\"ocfs2: No es necesario poner a cero las p\u00e1ginas despu\u00e9s de i_size.\") para la ruta de escritura est\u00e1ndar de ocfs2, la ruta de conversi\u00f3n en l\u00ednea aparentemente se olvid\u00f3; el registro de confirmaci\u00f3n tambi\u00e9n tiene un razonamiento por el cual la puesta a cero en realidad no es necesaria. Despu\u00e9s de el commit 6dbf7bb55598, las cosas empeoraron ya que el c\u00f3digo de reescritura dej\u00f3 de invalidar los buffers en p\u00e1ginas m\u00e1s all\u00e1 de i_size y, por lo tanto, estas p\u00e1ginas terminan con un bit PageDirty limpio pero con los b\u00faferes adjuntos a estas p\u00e1ginas todav\u00eda sucios. Entonces, cuando un archivo se convierte desde un formato en l\u00ednea, se activa la reescritura y luego el archivo crece para que estas p\u00e1ginas se vuelvan v\u00e1lidas, se conserva el estado de suciedad no v\u00e1lido, mark_buffer_dirty() no hace nada en estas p\u00e1ginas (los b\u00faferes ya est\u00e1n sucios), excepto la p\u00e1gina nunca se vuelve a escribir porque est\u00e1 limpio. Por lo tanto, los datos escritos en estas p\u00e1ginas se pierden una vez que se recuperan las p\u00e1ginas. El reproductor simple para el problema es: xfs_io -f -c \"pwrite 0 2000\" -c \"pwrite 2000 2000\" -c \"fsync\" \\ -c \"pwrite 4000 2000\" ocfs2_file Despu\u00e9s de desmontar y montar el fs nuevamente, puede observar que El final de 'ocfs2_file' ha perdido su contenido. Solucione el problema al no realizar la puesta a cero in\u00fatil durante la conversi\u00f3n desde el formato en l\u00ednea de manera similar a como lo hace en la ruta de escritura est\u00e1ndar. [akpm@linux-foundation.org: arreglar espacios en blanco, seg\u00fan Joseph]"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/5314454ea3ff6fc746eaf71b9a7ceebed52888fa", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/560edd14de2bf9dbc0129681eeb4d5ef87cc105f", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/8e6bfb4f70168ddfd32fb6dc028ad52faaf1f32e", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/a3a089c241cd49b33a8cdd7fcb37cc87a086912a", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/b05caf023b14cbed9223bb5b48ecc7bffe38f632", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f1b98569e81c37d7e0deada7172f8f60860c1360", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/fa9b6b6c953e3f6441ed6cf83b4c771dac2dae08", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/5314454ea3ff6fc746eaf71b9a7ceebed52888fa", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/560edd14de2bf9dbc0129681eeb4d5ef87cc105f", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/8e6bfb4f70168ddfd32fb6dc028ad52faaf1f32e", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/a3a089c241cd49b33a8cdd7fcb37cc87a086912a", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/b05caf023b14cbed9223bb5b48ecc7bffe38f632", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f1b98569e81c37d7e0deada7172f8f60860c1360", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/fa9b6b6c953e3f6441ed6cf83b4c771dac2dae08", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}