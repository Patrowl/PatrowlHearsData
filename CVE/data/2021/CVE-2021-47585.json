{"publishedDate": "2024-06-19T15:15Z", "lastModifiedDate": "2024-11-21T06:36Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2021-47585", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix memory leak in __add_inode_ref()\n\nLine 1169 (#3) allocates a memory chunk for victim_name by kmalloc(),\nbut  when the function returns in line 1184 (#4) victim_name allocated\nby line 1169 (#3) is not freed, which will lead to a memory leak.\nThere is a similar snippet of code in this function as allocating a memory\nchunk for victim_name in line 1104 (#1) as well as releasing the memory\nin line 1116 (#2).\n\nWe should kfree() victim_name when the return value of backref_in_log()\nis less than zero and before the function returns in line 1184 (#4).\n\n1057 static inline int __add_inode_ref(struct btrfs_trans_handle *trans,\n1058 \t\t\t\t  struct btrfs_root *root,\n1059 \t\t\t\t  struct btrfs_path *path,\n1060 \t\t\t\t  struct btrfs_root *log_root,\n1061 \t\t\t\t  struct btrfs_inode *dir,\n1062 \t\t\t\t  struct btrfs_inode *inode,\n1063 \t\t\t\t  u64 inode_objectid, u64 parent_objectid,\n1064 \t\t\t\t  u64 ref_index, char *name, int namelen,\n1065 \t\t\t\t  int *search_done)\n1066 {\n\n1104 \tvictim_name = kmalloc(victim_name_len, GFP_NOFS);\n\t// #1: kmalloc (victim_name-1)\n1105 \tif (!victim_name)\n1106 \t\treturn -ENOMEM;\n\n1112\tret = backref_in_log(log_root, &search_key,\n1113\t\t\tparent_objectid, victim_name,\n1114\t\t\tvictim_name_len);\n1115\tif (ret < 0) {\n1116\t\tkfree(victim_name); // #2: kfree (victim_name-1)\n1117\t\treturn ret;\n1118\t} else if (!ret) {\n\n1169 \tvictim_name = kmalloc(victim_name_len, GFP_NOFS);\n\t// #3: kmalloc (victim_name-2)\n1170 \tif (!victim_name)\n1171 \t\treturn -ENOMEM;\n\n1180 \tret = backref_in_log(log_root, &search_key,\n1181 \t\t\tparent_objectid, victim_name,\n1182 \t\t\tvictim_name_len);\n1183 \tif (ret < 0) {\n1184 \t\treturn ret; // #4: missing kfree (victim_name-2)\n1185 \t} else if (!ret) {\n\n1241 \treturn 0;\n1242 }"}, {"lang": "es", "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: btrfs: corrige la p\u00e9rdida de memoria en __add_inode_ref() La l\u00ednea 1169 (#3) asigna un fragmento de memoria para victim_name mediante kmalloc(), pero cuando la funci\u00f3n regresa en la l\u00ednea 1184 (#4) victim_name asignado por la l\u00ednea 1169 (#3) no se libera, lo que provocar\u00e1 una p\u00e9rdida de memoria. Hay un fragmento de c\u00f3digo similar en esta funci\u00f3n para asignar un fragmento de memoria para victim_name en la l\u00ednea 1104 (n.\u00ba 1), as\u00ed como para liberar la memoria en la l\u00ednea 1116 (n.\u00ba 2). Deber\u00edamos kfree() victim_name cuando el valor de retorno de backref_in_log() sea menor que cero y antes de que la funci\u00f3n regrese en la l\u00ednea 1184 (#4). 1057 static inline int __add_inode_ref(struct btrfs_trans_handle *trans, 1058 struct btrfs_root *root, 1059 struct btrfs_path *path, 1060 struct btrfs_root *log_root, 1061 struct btrfs_inode *dir, 1062 struct btrfs_inode *inode, 63 u64 inode_objectid, u64 parent_objectid, 1064 u64 ref_index, char *nombre, int nombrelen, 1065 int *search_done) 1066 { 1104 nombre_v\u00edctima = kmalloc(nombre_v\u00edctima_len, GFP_NOFS); // #1: kmalloc (nombre_v\u00edctima-1) 1105 if (!nombre_v\u00edctima) 1106 return -ENOMEM; 1112 ret = backref_in_log(log_root, &amp;search_key, 1113 parent_objectid, victim_name, 1114 victim_name_len); 1115 if (ret &lt; 0) { 1116 kfree(nombre_v\u00edctima); // #2: kfree (nombre_v\u00edctima-1) 1117 return ret; 1118 } else if (!ret) { 1169 nombre_v\u00edctima = kmalloc(nombre_v\u00edctima_len, GFP_NOFS); // #3: kmalloc (nombre_v\u00edctima-2) 1170 if (!nombre_v\u00edctima) 1171 return -ENOMEM; 1180 ret = backref_in_log(log_root, &amp;search_key, 1181 parent_objectid, victim_name, 1182 victim_name_len); 1183 si (ret &lt; 0) { 1184 retorno ret; // #4: falta kfree (nombre_v\u00edctima-2) 1185 } else if (!ret) { 1241 return 0; 1242 }"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/005d9292b5b2e71a009f911bd85d755009b37242", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/493ff661d434d6bdf02e3a21adae04d7a0b4265d", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/f35838a6930296fc1988764cfa54cb3f705c0665", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/005d9292b5b2e71a009f911bd85d755009b37242", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/493ff661d434d6bdf02e3a21adae04d7a0b4265d", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/f35838a6930296fc1988764cfa54cb3f705c0665", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-401"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "A657B2D0-5B9D-42BE-A3BF-228DBC1B057C", "cpe_name": [], "versionStartIncluding": "5.5", "versionEndExcluding": "5.10.88"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "11274E95-438A-449A-B100-01B2B0046669", "cpe_name": [], "versionStartIncluding": "5.11", "versionEndExcluding": "5.15.11"}]}]}}