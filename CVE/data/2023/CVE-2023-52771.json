{"publishedDate": "2024-05-21T16:15Z", "lastModifiedDate": "2024-11-21T08:40Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2023-52771", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ncxl/port: Fix delete_endpoint() vs parent unregistration race\n\nThe CXL subsystem, at cxl_mem ->probe() time, establishes a lineage of\nports (struct cxl_port objects) between an endpoint and the root of a\nCXL topology. Each port including the endpoint port is attached to the\ncxl_port driver.\n\nGiven that setup, it follows that when either any port in that lineage\ngoes through a cxl_port ->remove() event, or the memdev goes through a\ncxl_mem ->remove() event. The hierarchy below the removed port, or the\nentire hierarchy if the memdev is removed needs to come down.\n\nThe delete_endpoint() callback is careful to check whether it is being\ncalled to tear down the hierarchy, or if it is only being called to\nteardown the memdev because an ancestor port is going through\n->remove().\n\nThat care needs to take the device_lock() of the endpoint's parent.\nWhich requires 2 bugs to be fixed:\n\n1/ A reference on the parent is needed to prevent use-after-free\n   scenarios like this signature:\n\n    BUG: spinlock bad magic on CPU#0, kworker/u56:0/11\n    Hardware name: QEMU Standard PC (Q35 + ICH9, 2009), BIOS edk2-20230524-3.fc38 05/24/2023\n    Workqueue: cxl_port detach_memdev [cxl_core]\n    RIP: 0010:spin_bug+0x65/0xa0\n    Call Trace:\n      do_raw_spin_lock+0x69/0xa0\n     __mutex_lock+0x695/0xb80\n     delete_endpoint+0xad/0x150 [cxl_core]\n     devres_release_all+0xb8/0x110\n     device_unbind_cleanup+0xe/0x70\n     device_release_driver_internal+0x1d2/0x210\n     detach_memdev+0x15/0x20 [cxl_core]\n     process_one_work+0x1e3/0x4c0\n     worker_thread+0x1dd/0x3d0\n\n2/ In the case of RCH topologies, the parent device that needs to be\n   locked is not always @port->dev as returned by cxl_mem_find_port(), use\n   endpoint->dev.parent instead."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: cxl/port: corrige delete_endpoint() frente a la ejecuci\u00f3n de cancelaci\u00f3n del registro principal. El subsistema CXL, en el momento cxl_mem -&gt;probe(), establece un linaje de puertos (objetos struct cxl_port) entre un punto final y la ra\u00edz de una topolog\u00eda CXL. Cada puerto, incluido el puerto del punto final, est\u00e1 conectado al controlador cxl_port. Dada esa configuraci\u00f3n, se deduce que cuando cualquier puerto en ese linaje pasa por un evento cxl_port -&gt;remove(), o el memdev pasa por un evento cxl_mem -&gt;remove(). La jerarqu\u00eda debajo del puerto eliminado, o toda la jerarqu\u00eda si se elimina el memdev, debe bajar. La devoluci\u00f3n de llamada delete_endpoint() tiene cuidado de verificar si se llama para derribar la jerarqu\u00eda o si solo se llama para derribar memdev porque un puerto ancestro est\u00e1 pasando por -&gt;remove(). Ese cuidado debe tenerse en cuenta con el dispositivo_lock() del padre del punto final. Lo que requiere la correcci\u00f3n de 2 errores: 1/ Se necesita una referencia en el padre para evitar escenarios de use after free como esta firma: ERROR: spinlock bad magic en CPU#0, kworker/u56:0/11 Nombre del hardware: QEMU PC est\u00e1ndar (Q35 + ICH9, 2009), BIOS edk2-20230524-3.fc38 24/05/2023 Cola de trabajo: cxl_port detach_memdev [cxl_core] RIP: 0010:spin_bug+0x65/0xa0 Seguimiento de llamadas: do_raw_spin_lock+0x69/0xa0 5 /0xb80 delete_endpoint+0xad/0x150 [cxl_core] devres_release_all+0xb8/0x110 device_unbind_cleanup+0xe/0x70 device_release_driver_internal+0x1d2/0x210 detach_memdev+0x15/0x20 [cxl_core] proceso_one_work+0x1e3/0x4c0 _thread+0x1dd/0x3d0 2/ En el caso de RCH topolog\u00edas, el dispositivo principal que debe bloquearse no siempre es @port-&gt;dev como lo devuelve cxl_mem_find_port(); utilice endpoint-&gt;dev.parent en su lugar."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/37179fcc916bce8c3cc7b36d67ef814cce55142b", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/6b2e428e673b3f55965674a426c40922e91388aa", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/8d2ad999ca3c64cb08cf6a58d227b9d9e746d708", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/37179fcc916bce8c3cc7b36d67ef814cce55142b", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/6b2e428e673b3f55965674a426c40922e91388aa", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/8d2ad999ca3c64cb08cf6a58d227b9d9e746d708", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 0.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:N/I:N/A:H", "baseScore": 4.4, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}