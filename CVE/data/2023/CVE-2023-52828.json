{"publishedDate": "2024-05-21T16:15Z", "lastModifiedDate": "2025-09-26T16:57Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2023-52828", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Detect IP == ksym.end as part of BPF program\n\nNow that bpf_throw kfunc is the first such call instruction that has\nnoreturn semantics within the verifier, this also kicks in dead code\nelimination in unprecedented ways. For one, any instruction following\na bpf_throw call will never be marked as seen. Moreover, if a callchain\nends up throwing, any instructions after the call instruction to the\neventually throwing subprog in callers will also never be marked as\nseen.\n\nThe tempting way to fix this would be to emit extra 'int3' instructions\nwhich bump the jited_len of a program, and ensure that during runtime\nwhen a program throws, we can discover its boundaries even if the call\ninstruction to bpf_throw (or to subprogs that always throw) is emitted\nas the final instruction in the program.\n\nAn example of such a program would be this:\n\ndo_something():\n\t...\n\tr0 = 0\n\texit\n\nfoo():\n\tr1 = 0\n\tcall bpf_throw\n\tr0 = 0\n\texit\n\nbar(cond):\n\tif r1 != 0 goto pc+2\n\tcall do_something\n\texit\n\tcall foo\n\tr0 = 0  // Never seen by verifier\n\texit\t//\n\nmain(ctx):\n\tr1 = ...\n\tcall bar\n\tr0 = 0\n\texit\n\nHere, if we do end up throwing, the stacktrace would be the following:\n\nbpf_throw\nfoo\nbar\nmain\n\nIn bar, the final instruction emitted will be the call to foo, as such,\nthe return address will be the subsequent instruction (which the JIT\nemits as int3 on x86). This will end up lying outside the jited_len of\nthe program, thus, when unwinding, we will fail to discover the return\naddress as belonging to any program and end up in a panic due to the\nunreliable stack unwinding of BPF programs that we never expect.\n\nTo remedy this case, make bpf_prog_ksym_find treat IP == ksym.end as\npart of the BPF program, so that is_bpf_text_address returns true when\nsuch a case occurs, and we are able to unwind reliably when the final\ninstruction ends up being a call instruction."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf: Detectar IP == ksym.end como parte del programa BPF. Ahora que bpf_throw kfunc es la primera instrucci\u00f3n de llamada que no tiene sem\u00e1ntica de retorno dentro del verificador, esto tambi\u00e9n activa el c\u00f3digo muerto eliminaci\u00f3n de formas sin precedentes. Por un lado, cualquier instrucci\u00f3n que siga a una llamada a bpf_throw nunca se marcar\u00e1 como vista. Adem\u00e1s, si una cadena de llamadas termina lanz\u00e1ndose, cualquier instrucci\u00f3n posterior a la instrucci\u00f3n de llamada al subprog que finalmente se lance en las personas que llaman tampoco se marcar\u00e1 como vista. La forma tentadora de solucionar este problema ser\u00eda emitir instrucciones 'int3' adicionales que superen el jited_len de un programa y garantizar que, durante el tiempo de ejecuci\u00f3n, cuando se inicia un programa, podamos descubrir sus l\u00edmites incluso si la instrucci\u00f3n de llamada a bpf_throw (o a subprogs que siempre tirar) se emite como instrucci\u00f3n final en el programa. Un ejemplo de un programa de este tipo ser\u00eda este: do_something(): ... r0 = 0 salir foo(): r1 = 0 llamar a bpf_throw r0 = 0 salir de la barra (cond): si r1 != 0 ir a pc+2 llamar a hacer_algo exit call foo r0 = 0 // Nunca visto por el verificador exit // main(ctx): r1 = ... call bar r0 = 0 exit Aqu\u00ed, si terminamos lanzando, el seguimiento de pila ser\u00eda el siguiente: bpf_throw foo bar main En bar, la instrucci\u00f3n final emitida ser\u00e1 la llamada a foo, como tal, la direcci\u00f3n de retorno ser\u00e1 la instrucci\u00f3n posterior (que el JIT emite como int3 en x86). Esto terminar\u00e1 quedando fuera del jited_len del programa, por lo tanto, al desenrollarlo, no podremos descubrir que la direcci\u00f3n del remitente pertenece a ning\u00fan programa y terminaremos en p\u00e1nico debido al desenrollado poco confiable de la pila de programas BPF que nunca esperamos. Para remediar este caso, haga que bpf_prog_ksym_find trate IP == ksym.end como parte del programa BPF, de modo que is_bpf_text_address devuelva verdadero cuando ocurra tal caso, y podamos desenredarlo de manera confiable cuando la instrucci\u00f3n final termine siendo una instrucci\u00f3n de llamada."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/327b92e8cb527ae097961ffd1610c720481947f5", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/6058e4829696412457729a00734969acc6fd1d18", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/66d9111f3517f85ef2af0337ece02683ce0faf21", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/821a7e4143af115b840ec199eb179537e18af922", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/aa42a7cb92647786719fe9608685da345883878f", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/cf353904a82873e952633fcac4385c2fcd3a46e1", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/327b92e8cb527ae097961ffd1610c720481947f5", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/6058e4829696412457729a00734969acc6fd1d18", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/66d9111f3517f85ef2af0337ece02683ce0faf21", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/821a7e4143af115b840ec199eb179537e18af922", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/aa42a7cb92647786719fe9608685da345883878f", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/cf353904a82873e952633fcac4385c2fcd3a46e1", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "FF5E31E1-4DDB-480A-966E-3470C98B932E", "cpe_name": [], "versionEndExcluding": "5.10.202"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "15D6C23C-78A3-40D2-B76B-4F1D9C2D95C0", "cpe_name": [], "versionStartIncluding": "5.11", "versionEndExcluding": "5.15.140"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "8D7C884A-CAA2-4EA2-9FEB-5CE776D7B05F", "cpe_name": [], "versionStartIncluding": "5.16", "versionEndExcluding": "6.1.64"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "674C4F82-C336-4B49-BF64-1DE422E889C4", "cpe_name": [], "versionStartIncluding": "6.2", "versionEndExcluding": "6.5.13"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "B58252FA-A49C-411F-9B28-DC5FE44BC5A0", "cpe_name": [], "versionStartIncluding": "6.6", "versionEndExcluding": "6.6.3"}]}]}}