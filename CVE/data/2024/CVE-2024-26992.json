{"publishedDate": "2024-05-01T06:15Z", "lastModifiedDate": "2024-11-21T09:03Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-26992", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nKVM: x86/pmu: Disable support for adaptive PEBS\n\nDrop support for virtualizing adaptive PEBS, as KVM's implementation is\narchitecturally broken without an obvious/easy path forward, and because\nexposing adaptive PEBS can leak host LBRs to the guest, i.e. can leak\nhost kernel addresses to the guest.\n\nBug #1 is that KVM doesn't account for the upper 32 bits of\nIA32_FIXED_CTR_CTRL when (re)programming fixed counters, e.g\nfixed_ctrl_field() drops the upper bits, reprogram_fixed_counters()\nstores local variables as u8s and truncates the upper bits too, etc.\n\nBug #2 is that, because KVM _always_ sets precise_ip to a non-zero value\nfor PEBS events, perf will _always_ generate an adaptive record, even if\nthe guest requested a basic record.  Note, KVM will also enable adaptive\nPEBS in individual *counter*, even if adaptive PEBS isn't exposed to the\nguest, but this is benign as MSR_PEBS_DATA_CFG is guaranteed to be zero,\ni.e. the guest will only ever see Basic records.\n\nBug #3 is in perf.  intel_pmu_disable_fixed() doesn't clear the upper\nbits either, i.e. leaves ICL_FIXED_0_ADAPTIVE set, and\nintel_pmu_enable_fixed() effectively doesn't clear ICL_FIXED_0_ADAPTIVE\neither.  I.e. perf _always_ enables ADAPTIVE counters, regardless of what\nKVM requests.\n\nBug #4 is that adaptive PEBS *might* effectively bypass event filters set\nby the host, as \"Updated Memory Access Info Group\" records information\nthat might be disallowed by userspace via KVM_SET_PMU_EVENT_FILTER.\n\nBug #5 is that KVM doesn't ensure LBR MSRs hold guest values (or at least\nzeros) when entering a vCPU with adaptive PEBS, which allows the guest\nto read host LBRs, i.e. host RIPs/addresses, by enabling \"LBR Entries\"\nrecords.\n\nDisable adaptive PEBS support as an immediate fix due to the severity of\nthe LBR leak in particular, and because fixing all of the bugs will be\nnon-trivial, e.g. not suitable for backporting to stable kernels.\n\nNote!  This will break live migration, but trying to make KVM play nice\nwith live migration would be quite complicated, wouldn't be guaranteed to\nwork (i.e. KVM might still kill/confuse the guest), and it's not clear\nthat there are any publicly available VMMs that support adaptive PEBS,\nlet alone live migrate VMs that support adaptive PEBS, e.g. QEMU doesn't\nsupport PEBS in any capacity."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: KVM: x86/pmu: deshabilitar el soporte para PEBS adaptativos. Eliminar el soporte para virtualizar PEBS adaptativos, ya que la implementaci\u00f3n de KVM tiene una arquitectura rota sin un camino obvio/f\u00e1cil a seguir, y porque exponer PEBS adaptativos puede filtrar los LBR del host al hu\u00e9sped, es decir, puede filtrar las direcciones del kernel del host al hu\u00e9sped. El error n\u00famero 1 es que KVM no tiene en cuenta los 32 bits superiores de IA32_FIXED_CTR_CTRL cuando (re)programa contadores fijos, por ejemplo, fix_ctrl_field() elimina los bits superiores, reprogram_fixed_counters() almacena variables locales como u8 y tambi\u00e9n trunca los bits superiores, etc. El error n\u00famero 2 es que, debido a que KVM _siempre_ establece precision_ip en un valor distinto de cero para eventos PEBS, perf _siempre_ generar\u00e1 un registro adaptativo, incluso si el invitado solicit\u00f3 un registro b\u00e1sico. Tenga en cuenta que KVM tambi\u00e9n habilitar\u00e1 PEBS adaptativo en *contador* individual, incluso si PEBS adaptativo no est\u00e1 expuesto al invitado, pero esto es benigno ya que se garantiza que MSR_PEBS_DATA_CFG ser\u00e1 cero, es decir, el invitado solo ver\u00e1 registros b\u00e1sicos. El error n\u00famero 3 est\u00e1 en rendimiento. intel_pmu_disable_fixed() tampoco borra los bits superiores, es decir, deja ICL_FIXED_0_ADAPTIVE configurado, e intel_pmu_enable_fixed() efectivamente tampoco borra ICL_FIXED_0_ADAPTIVE. Es decir, perf _siempre_ habilita contadores ADAPTIVOS, independientemente de lo que solicite KVM. El error n\u00famero 4 es que los PEBS adaptables *podr\u00edan* omitir efectivamente los filtros de eventos establecidos por el host, ya que el \"Grupo de informaci\u00f3n de acceso a memoria actualizado\" registra informaci\u00f3n que podr\u00eda no estar permitida por el espacio de usuario a trav\u00e9s de KVM_SET_PMU_EVENT_FILTER. El error n\u00famero 5 es que KVM no garantiza que los MSR LBR mantengan valores de invitado (o al menos ceros) al ingresar a una vCPU con PEBS adaptable, lo que permite al invitado leer los LBR del host, es decir, los RIP/direcciones del host, al habilitar las \"Entradas LBR\". registros. Deshabilite el soporte PEBS adaptable como soluci\u00f3n inmediata debido a la gravedad de la fuga de LBR en particular, y porque corregir todos los errores no ser\u00e1 trivial, por ejemplo, no es adecuado para realizar backporting a n\u00facleos estables. \u00a1Nota! Esto interrumpir\u00e1 la migraci\u00f3n en vivo, pero tratar de hacer que KVM funcione bien con la migraci\u00f3n en vivo ser\u00eda bastante complicado, no se garantizar\u00eda que funcione (es decir, KVM a\u00fan podr\u00eda matar/confundir al invitado) y no est\u00e1 claro si hay alguno disponible p\u00fablicamente. Los VMM que admiten PEBS adaptables, y mucho menos migran en vivo las m\u00e1quinas virtuales que admiten PEBS adaptables; por ejemplo, QEMU no admite PEBS de ninguna manera."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/037e48ceccf163899374b601afb6ae8d0bf1d2ac", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/0fb74c00d140a66128afc0003785dcc57e69d312", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/7a7650b3ac23e5fc8c990f00e94f787dc84e3175", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/9e985cbf2942a1bb8fcef9adc2a17d90fd7ca8ee", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/037e48ceccf163899374b601afb6ae8d0bf1d2ac", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/0fb74c00d140a66128afc0003785dcc57e69d312", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/7a7650b3ac23e5fc8c990f00e94f787dc84e3175", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/9e985cbf2942a1bb8fcef9adc2a17d90fd7ca8ee", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}