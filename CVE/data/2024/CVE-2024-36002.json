{"publishedDate": "2024-05-20T10:15Z", "lastModifiedDate": "2024-11-21T09:21Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-36002", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ndpll: fix dpll_pin_on_pin_register() for multiple parent pins\n\nIn scenario where pin is registered with multiple parent pins via\ndpll_pin_on_pin_register(..), all belonging to the same dpll device.\nA second call to dpll_pin_on_pin_unregister(..) would cause a call trace,\nas it tries to use already released registration resources (due to fix\nintroduced in b446631f355e). In this scenario pin was registered twice,\nso resources are not yet expected to be release until each registered\npin/pin pair is unregistered.\n\nCurrently, the following crash/call trace is produced when ice driver is\nremoved on the system with installed E810T NIC which includes dpll device:\n\nWARNING: CPU: 51 PID: 9155 at drivers/dpll/dpll_core.c:809 dpll_pin_ops+0x20/0x30\nRIP: 0010:dpll_pin_ops+0x20/0x30\nCall Trace:\n ? __warn+0x7f/0x130\n ? dpll_pin_ops+0x20/0x30\n dpll_msg_add_pin_freq+0x37/0x1d0\n dpll_cmd_pin_get_one+0x1c0/0x400\n ? __nlmsg_put+0x63/0x80\n dpll_pin_event_send+0x93/0x140\n dpll_pin_on_pin_unregister+0x3f/0x100\n ice_dpll_deinit_pins+0xa1/0x230 [ice]\n ice_remove+0xf1/0x210 [ice]\n\nFix by adding a parent pointer as a cookie when creating a registration,\nalso when searching for it. For the regular pins pass NULL, this allows to\ncreate separated registration for each parent the pin is registered with."}, {"lang": "es", "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: dpll: corrige dpll_pin_on_pin_register() para m\u00faltiples pines principales En un escenario donde el pin se registra con m\u00faltiples pines principales a trav\u00e9s de dpll_pin_on_pin_register(..), todos pertenecientes al mismo dispositivo dpll. Una segunda llamada a dpll_pin_on_pin_unregister(..) provocar\u00eda un seguimiento de la llamada, ya que intenta utilizar recursos de registro ya liberados (debido a la soluci\u00f3n introducida en b446631f355e). En este escenario, el pin se registr\u00f3 dos veces, por lo que a\u00fan no se espera que se liberen recursos hasta que se cancele el registro de cada pin/par de pines registrado. Actualmente, se produce el siguiente seguimiento de fallas/llamadas cuando se elimina el controlador Ice en el sistema con la NIC E810T instalada que incluye el dispositivo dpll: ADVERTENCIA: CPU: 51 PID: 9155 en drivers/dpll/dpll_core.c:809 dpll_pin_ops+0x20/0x30 RIP: 0010:dpll_pin_ops+0x20/0x30 Seguimiento de llamadas:? __warn+0x7f/0x130 ? dpll_pin_ops+0x20/0x30 dpll_msg_add_pin_freq+0x37/0x1d0 dpll_cmd_pin_get_one+0x1c0/0x400 ? __nlmsg_put+0x63/0x80 dpll_pin_event_send+0x93/0x140 dpll_pin_on_pin_unregister+0x3f/0x100 ice_dpll_deinit_pins+0xa1/0x230 [ice] ice_remove+0xf1/0x210 [ice] Se soluciona agregando un puntero principal como cookie al crear un registro. tambi\u00e9n al buscarlo . Para los pines normales pasan NULL, esto permite crear un registro separado para cada padre con el que est\u00e1 registrado el pin."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/38d7b94e81d068b8d8c8392f421cfd2c3bbfd1a6", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f3e1cf62d18220a3aa97e084e7a3552debece9fc", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/38d7b94e81d068b8d8c8392f421cfd2c3bbfd1a6", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f3e1cf62d18220a3aa97e084e7a3552debece9fc", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}