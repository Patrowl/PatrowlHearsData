{"publishedDate": "2024-12-24T12:15Z", "lastModifiedDate": "2025-10-08T14:43Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-53153", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nPCI: qcom-ep: Move controller cleanups to qcom_pcie_perst_deassert()\n\nCurrently, the endpoint cleanup function dw_pcie_ep_cleanup() and EPF\ndeinit notify function pci_epc_deinit_notify() are called during the\nexecution of qcom_pcie_perst_assert() i.e., when the host has asserted\nPERST#. But quickly after this step, refclk will also be disabled by the\nhost.\n\nAll of the Qcom endpoint SoCs supported as of now depend on the refclk from\nthe host for keeping the controller operational. Due to this limitation,\nany access to the hardware registers in the absence of refclk will result\nin a whole endpoint crash. Unfortunately, most of the controller cleanups\nrequire accessing the hardware registers (like eDMA cleanup performed in\ndw_pcie_ep_cleanup(), powering down MHI EPF etc...). So these cleanup\nfunctions are currently causing the crash in the endpoint SoC once host\nasserts PERST#.\n\nOne way to address this issue is by generating the refclk in the endpoint\nitself and not depending on the host. But that is not always possible as\nsome of the endpoint designs do require the endpoint to consume refclk from\nthe host (as I was told by the Qcom engineers).\n\nThus, fix this crash by moving the controller cleanups to the start of\nthe qcom_pcie_perst_deassert() function. qcom_pcie_perst_deassert() is\ncalled whenever the host has deasserted PERST# and it is guaranteed that\nthe refclk would be active at this point. So at the start of this function\n(after enabling resources), the controller cleanup can be performed. Once\nfinished, rest of the code execution for PERST# deassert can continue as\nusual."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: PCI: qcom-ep: mover las desinfecciones del controlador a qcom_pcie_perst_deassert() Actualmente, la funci\u00f3n de desinfecci\u00f3n de endpoints dw_pcie_ep_cleanup() y la funci\u00f3n de notificaci\u00f3n deinit de EPF pci_epc_deinit_notify() se llaman durante la ejecuci\u00f3n de qcom_pcie_perst_assert( ) es decir, cuando el host ha afirmado PREST#. Pero poco despu\u00e9s de este paso, el host tambi\u00e9n desactivar\u00e1 refclk. Todos los SoC de endpoint de Qcom admitidos a partir de ahora dependen de la refclk del host para mantener el controlador operativo. Debido a esta limitaci\u00f3n, cualquier acceso a los registros de hardware en ausencia de refclk provocar\u00e1 un fallo completo del terminal. Desafortunadamente, la mayor\u00eda de las desinfecciones del controlador requieren acceder a los registros de hardware (como la desinfecci\u00f3n de eDMA realizada en dw_pcie_ep_cleanup(), apagar MHI EPF, etc.). Por lo tanto, estas funciones de desinfecci\u00f3n actualmente causan el bloqueo en el SoC del endpoint una vez que el host afirma PREST#. Una forma de abordar este problema es generando el refclk en el propio endpoint y sin depender del host. Pero eso no siempre es posible ya que algunos de los dise\u00f1os de terminales requieren que el terminal consuma refclk del host (como me dijeron los ingenieros de Qcom). Por lo tanto, solucione este bloqueo moviendo las desinfecciones del controlador al inicio de la funci\u00f3n qcom_pcie_perst_deassert(). Se llama a qcom_pcie_perst_deassert() cada vez que el host ha desactivado PERST# y se garantiza que refclk estar\u00e1 activo en este punto. Entonces, al inicio de esta funci\u00f3n (despu\u00e9s de habilitar los recursos), se puede realizar la desinfecci\u00f3n del controlador. Una vez finalizado, el resto de la ejecuci\u00f3n del c\u00f3digo para la desactivaci\u00f3n de PERST# puede continuar como de costumbre."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/516969d5765e2302d33b4f251496eedb757d55ea", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/7d7cf89b119af433354f865fc01017b9f8aa411a", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/e03b5f1615c84f4139cb53ef8659f4cdb8d6a563", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "158A6B22-9260-41D7-965A-A81798A5A969", "cpe_name": [], "versionStartIncluding": "6.10", "versionEndExcluding": "6.11.11"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "D8882B1B-2ABC-4838-AC1D-DBDBB5764776", "cpe_name": [], "versionStartIncluding": "6.12", "versionEndExcluding": "6.12.2"}]}]}}