{"publishedDate": "2024-10-21T18:15Z", "lastModifiedDate": "2025-01-09T16:16Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-49998", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: dsa: improve shutdown sequence\n\nAlexander Sverdlin presents 2 problems during shutdown with the\nlan9303 driver. One is specific to lan9303 and the other just happens\nto reproduce there.\n\nThe first problem is that lan9303 is unique among DSA drivers in that it\ncalls dev_get_drvdata() at \"arbitrary runtime\" (not probe, not shutdown,\nnot remove):\n\nphy_state_machine()\n-> ...\n   -> dsa_user_phy_read()\n      -> ds->ops->phy_read()\n         -> lan9303_phy_read()\n            -> chip->ops->phy_read()\n               -> lan9303_mdio_phy_read()\n                  -> dev_get_drvdata()\n\nBut we never stop the phy_state_machine(), so it may continue to run\nafter dsa_switch_shutdown(). Our common pattern in all DSA drivers is\nto set drvdata to NULL to suppress the remove() method that may come\nafterwards. But in this case it will result in an NPD.\n\nThe second problem is that the way in which we set\ndp->conduit->dsa_ptr = NULL; is concurrent with receive packet\nprocessing. dsa_switch_rcv() checks once whether dev->dsa_ptr is NULL,\nbut afterwards, rather than continuing to use that non-NULL value,\ndev->dsa_ptr is dereferenced again and again without NULL checks:\ndsa_conduit_find_user() and many other places. In between dereferences,\nthere is no locking to ensure that what was valid once continues to be\nvalid.\n\nBoth problems have the common aspect that closing the conduit interface\nsolves them.\n\nIn the first case, dev_close(conduit) triggers the NETDEV_GOING_DOWN\nevent in dsa_user_netdevice_event() which closes user ports as well.\ndsa_port_disable_rt() calls phylink_stop(), which synchronously stops\nthe phylink state machine, and ds->ops->phy_read() will thus no longer\ncall into the driver after this point.\n\nIn the second case, dev_close(conduit) should do this, as per\nDocumentation/networking/driver.rst:\n\n| Quiescence\n| ----------\n|\n| After the ndo_stop routine has been called, the hardware must\n| not receive or transmit any data.  All in flight packets must\n| be aborted. If necessary, poll or wait for completion of\n| any reset commands.\n\nSo it should be sufficient to ensure that later, when we zeroize\nconduit->dsa_ptr, there will be no concurrent dsa_switch_rcv() call\non this conduit.\n\nThe addition of the netif_device_detach() function is to ensure that\nioctls, rtnetlinks and ethtool requests on the user ports no longer\npropagate down to the driver - we're no longer prepared to handle them.\n\nThe race condition actually did not exist when commit 0650bf52b31f\n(\"net: dsa: be compatible with masters which unregister on shutdown\")\nfirst introduced dsa_switch_shutdown(). It was created later, when we\nstopped unregistering the user interfaces from a bad spot, and we just\nreplaced that sequence with a racy zeroization of conduit->dsa_ptr\n(one which doesn't ensure that the interfaces aren't up)."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: net: dsa: mejorar la secuencia de apagado Alexander Sverdlin presenta 2 problemas durante el apagado con el controlador lan9303. Uno es espec\u00edfico de lan9303 y el otro simplemente se reproduce all\u00ed. El primer problema es que lan9303 es \u00fanico entre los controladores DSA en el sentido de que llama a dev_get_drvdata() en un \"tiempo de ejecuci\u00f3n arbitrario\" (no sondeo, no apagado, no eliminaci\u00f3n): phy_state_machine() -&gt; ... -&gt; dsa_user_phy_read() -&gt; ds-&gt;ops-&gt;phy_read() -&gt; lan9303_phy_read() -&gt; chip-&gt;ops-&gt;phy_read() -&gt; lan9303_mdio_phy_read() -&gt; dev_get_drvdata() Pero nunca detenemos phy_state_machine(), por lo que puede continuar ejecut\u00e1ndose despu\u00e9s de dsa_switch_shutdown(). Nuestro patr\u00f3n com\u00fan en todos los controladores DSA es establecer drvdata en NULL para suprimir el m\u00e9todo remove() que puede venir despu\u00e9s. Pero en este caso resultar\u00e1 en un NPD. El segundo problema es que la forma en que establecemos dp-&gt;conduit-&gt;dsa_ptr = NULL; es concurrente con el procesamiento de paquetes de recepci\u00f3n. dsa_switch_rcv() verifica una vez si dev-&gt;dsa_ptr es NULL, pero despu\u00e9s, en lugar de continuar usando ese valor no NULL, dev-&gt;dsa_ptr se desreferencia una y otra vez sin verificaciones NULL: dsa_conduit_find_user() y muchos otros lugares. Entre desreferencias, no hay bloqueo para asegurar que lo que era v\u00e1lido una vez contin\u00faa siendo v\u00e1lido. Ambos problemas tienen el aspecto com\u00fan de que cerrar la interfaz del conducto los resuelve. En el primer caso, dev_close(conduit) activa el evento NETDEV_GOING_DOWN en dsa_user_netdevice_event() que tambi\u00e9n cierra los puertos de usuario. dsa_port_disable_rt() llama a phylink_stop(), que detiene sincr\u00f3nicamente la m\u00e1quina de estado de phylink, y ds-&gt;ops-&gt;phy_read() ya no llamar\u00e1 al controlador despu\u00e9s de este punto. En el segundo caso, dev_close(conduit) deber\u00eda hacer esto, seg\u00fan Documentation/networking/driver.rst: | Quiescence | ---------- | | Despu\u00e9s de que se haya llamado a la rutina ndo_stop, el hardware no debe recibir ni transmitir ning\u00fan dato. Todos los paquetes en tr\u00e1nsito deben ser abortados. Si es necesario, sondee o espere a que se completen los comandos de reinicio. Por lo tanto, deber\u00eda ser suficiente para garantizar que m\u00e1s adelante, cuando pongamos a cero conduit-&gt;dsa_ptr, no habr\u00e1 ninguna llamada dsa_switch_rcv() concurrente en este conducto. La adici\u00f3n de la funci\u00f3n netif_device_detach() es para garantizar que las solicitudes ioctls, rtnetlinks y ethtool en los puertos de usuario ya no se propaguen al controlador; ya no estamos preparados para manejarlas. La condici\u00f3n de ejecuci\u00f3n en realidad no exist\u00eda cuando el commit 0650bf52b31f (\"net: dsa: sea compatible con los maestros que cancelan el registro al apagar\") introdujo por primera vez dsa_switch_shutdown(). Se cre\u00f3 m\u00e1s tarde, cuando dejamos de cancelar el registro de las interfaces de usuario desde un lugar incorrecto y simplemente reemplazamos esa secuencia con una puesta a cero de ejecuci\u00f3n de conduit-&gt;dsa_ptr (que no garantiza que las interfaces no est\u00e9n activas)."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/6c24a03a61a245fe34d47582898331fa034b6ccd", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/87bd909a7014e32790e8c759d5b7694a95778ca5", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/ab5d3420a1120950703dbdc33698b28a6ebc3d23", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/b4a65d479213fe84ecb14e328271251eebe69492", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-367"}, {"lang": "en", "value": "CWE-476"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.0, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 4.7, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "5E1DEA80-F82B-404D-9BFF-B251D28EECE1", "cpe_name": [], "versionStartIncluding": "5.15.155", "versionEndExcluding": "5.16"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "EC68CAC9-3619-42EC-A9B1-3CB0ACC2EE27", "cpe_name": [], "versionStartIncluding": "5.16.10", "versionEndExcluding": "5.17"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "76DE2BAD-A9E3-4933-B8B4-9ED1212F1DF1", "cpe_name": [], "versionStartIncluding": "5.17", "versionEndExcluding": "6.10.14"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "54D9C704-D679-41A7-9C40-10A6B1E7FFE9", "cpe_name": [], "versionStartIncluding": "6.11", "versionEndExcluding": "6.11.3"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.12:rc1:*:*:*:*:*:*", "matchCriteriaId": "7F361E1D-580F-4A2D-A509-7615F73167A1", "cpe_name": []}]}]}}