{"publishedDate": "2024-05-01T13:15Z", "lastModifiedDate": "2025-09-18T16:04Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-27036", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\ncifs: Fix writeback data corruption\n\ncifs writeback doesn't correctly handle the case where\ncifs_extend_writeback() hits a point where it is considering an additional\nfolio, but this would overrun the wsize - at which point it drops out of\nthe xarray scanning loop and calls xas_pause().  The problem is that\nxas_pause() advances the loop counter - thereby skipping that page.\n\nWhat needs to happen is for xas_reset() to be called any time we decide we\ndon't want to process the page we're looking at, but rather send the\nrequest we are building and start a new one.\n\nFix this by copying and adapting the netfslib writepages code as a\ntemporary measure, with cifs writeback intending to be offloaded to\nnetfslib in the near future.\n\nThis also fixes the issue with the use of filemap_get_folios_tag() causing\nretry of a bunch of pages which the extender already dealt with.\n\nThis can be tested by creating, say, a 64K file somewhere not on cifs\n(otherwise copy-offload may get underfoot), mounting a cifs share with a\nwsize of 64000, copying the file to it and then comparing the original file\nand the copy:\n\n        dd if=/dev/urandom of=/tmp/64K bs=64k count=1\n        mount //192.168.6.1/test /mnt -o user=...,pass=...,wsize=64000\n        cp /tmp/64K /mnt/64K\n        cmp /tmp/64K /mnt/64K\n\nWithout the fix, the cmp fails at position 64000 (or shortly thereafter)."}, {"lang": "es", "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: cifs: corrige la corrupci\u00f3n de datos de reescritura cifs writeback no maneja correctamente el caso en el que cifs_extend_writeback() llega a un punto en el que est\u00e1 considerando una publicaci\u00f3n adicional, pero esto sobrepasar\u00eda el tama\u00f1o de wsize - en momento en el que sale del ciclo de escaneo de xarray y llama a xas_pause(). El problema es que xas_pause() avanza el contador de bucle, omitiendo as\u00ed esa p\u00e1gina. Lo que debe suceder es que se llame a xas_reset() cada vez que decidamos que no queremos procesar la p\u00e1gina que estamos viendo, sino enviar la solicitud que estamos creando y comenzar una nueva. Solucione este problema copiando y adaptando el c\u00f3digo de escritura de netfslib como medida temporal, y la escritura diferida de cifs se descargar\u00e1 a netfslib en un futuro pr\u00f3ximo. Esto tambi\u00e9n soluciona el problema con el uso de filemap_get_folios_tag() que provocaba un reintento de un grupo de p\u00e1ginas que el extensor ya hab\u00eda tratado. Esto se puede probar creando, por ejemplo, un archivo de 64 K en alg\u00fan lugar que no est\u00e9 en cif (de lo contrario, la descarga de copia podr\u00eda complicarse), montando un recurso compartido cif con un tama\u00f1o de 64000, copiando el archivo en \u00e9l y luego comparando el archivo original y la copia. : dd if=/dev/urandom of=/tmp/64K bs=64k count=1 mount //192.168.6.1/test /mnt -o user=...,pass=...,wsize=64000 cp /tmp /64K /mnt/64K cmp /tmp/64K /mnt/64K Sin la correcci\u00f3n, el cmp falla en la posici\u00f3n 64000 (o poco despu\u00e9s)."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/65f2ced695982ccd516196d0a9447d85dbe2eed5", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/844b4e132f57f1333dc79feaa035075a096762e4", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/e45deec35bf7f1f4f992a707b2d04a8c162f2240", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/f3dc1bdb6b0b0693562c7c54a6c28bafa608ba3c", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/65f2ced695982ccd516196d0a9447d85dbe2eed5", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/844b4e132f57f1333dc79feaa035075a096762e4", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/e45deec35bf7f1f4f992a707b2d04a8c162f2240", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/f3dc1bdb6b0b0693562c7c54a6c28bafa608ba3c", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-787"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 5.9, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "baseScore": 7.8, "baseSeverity": "HIGH", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "FF3B2DAF-D3AB-46CC-A8F5-C374664586C9", "cpe_name": [], "versionStartIncluding": "6.3", "versionEndExcluding": "6.6.23"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "9B95D3A6-E162-47D5-ABFC-F3FA74FA7CFD", "cpe_name": [], "versionStartIncluding": "6.7", "versionEndExcluding": "6.7.11"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "543A75FF-25B8-4046-A514-1EA8EDD87AB1", "cpe_name": [], "versionStartIncluding": "6.8", "versionEndExcluding": "6.8.2"}]}]}}