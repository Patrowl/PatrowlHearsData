{"publishedDate": "2024-11-08T06:15Z", "lastModifiedDate": "2025-10-08T16:03Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-50200", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmaple_tree: correct tree corruption on spanning store\n\nPatch series \"maple_tree: correct tree corruption on spanning store\", v3.\n\nThere has been a nasty yet subtle maple tree corruption bug that appears\nto have been in existence since the inception of the algorithm.\n\nThis bug seems far more likely to happen since commit f8d112a4e657\n(\"mm/mmap: avoid zeroing vma tree in mmap_region()\"), which is the point\nat which reports started to be submitted concerning this bug.\n\nWe were made definitely aware of the bug thanks to the kind efforts of\nBert Karwatzki who helped enormously in my being able to track this down\nand identify the cause of it.\n\nThe bug arises when an attempt is made to perform a spanning store across\ntwo leaf nodes, where the right leaf node is the rightmost child of the\nshared parent, AND the store completely consumes the right-mode node.\n\nThis results in mas_wr_spanning_store() mitakenly duplicating the new and\nexisting entries at the maximum pivot within the range, and thus maple\ntree corruption.\n\nThe fix patch corrects this by detecting this scenario and disallowing the\nmistaken duplicate copy.\n\nThe fix patch commit message goes into great detail as to how this occurs.\n\nThis series also includes a test which reliably reproduces the issue, and\nasserts that the fix works correctly.\n\nBert has kindly tested the fix and confirmed it resolved his issues.  Also\nMikhail Gavrilov kindly reported what appears to be precisely the same\nbug, which this fix should also resolve.\n\n\nThis patch (of 2):\n\nThere has been a subtle bug present in the maple tree implementation from\nits inception.\n\nThis arises from how stores are performed - when a store occurs, it will\noverwrite overlapping ranges and adjust the tree as necessary to\naccommodate this.\n\nA range may always ultimately span two leaf nodes.  In this instance we\nwalk the two leaf nodes, determine which elements are not overwritten to\nthe left and to the right of the start and end of the ranges respectively\nand then rebalance the tree to contain these entries and the newly\ninserted one.\n\nThis kind of store is dubbed a 'spanning store' and is implemented by\nmas_wr_spanning_store().\n\nIn order to reach this stage, mas_store_gfp() invokes\nmas_wr_preallocate(), mas_wr_store_type() and mas_wr_walk() in turn to\nwalk the tree and update the object (mas) to traverse to the location\nwhere the write should be performed, determining its store type.\n\nWhen a spanning store is required, this function returns false stopping at\nthe parent node which contains the target range, and mas_wr_store_type()\nmarks the mas->store_type as wr_spanning_store to denote this fact.\n\nWhen we go to perform the store in mas_wr_spanning_store(), we first\ndetermine the elements AFTER the END of the range we wish to store (that\nis, to the right of the entry to be inserted) - we do this by walking to\nthe NEXT pivot in the tree (i.e.  r_mas.last + 1), starting at the node we\nhave just determined contains the range over which we intend to write.\n\nWe then turn our attention to the entries to the left of the entry we are\ninserting, whose state is represented by l_mas, and copy these into a 'big\nnode', which is a special node which contains enough slots to contain two\nleaf node's worth of data.\n\nWe then copy the entry we wish to store immediately after this - the copy\nand the insertion of the new entry is performed by mas_store_b_node().\n\nAfter this we copy the elements to the right of the end of the range which\nwe are inserting, if we have not exceeded the length of the node (i.e. \nr_mas.offset <= r_mas.end).\n\nHerein lies the bug - under very specific circumstances, this logic can\nbreak and corrupt the maple tree.\n\nConsider the following tree:\n\nHeight\n  0                             Root Node\n                                 /      \\\n                 pivot = 0xffff /        \\ pivot = ULONG_MAX\n                               /          \n---truncated---"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: maple_tree: corregir la corrupci\u00f3n del \u00e1rbol en el almac\u00e9n de expansi\u00f3n Serie de parches \"maple_tree: corregir la corrupci\u00f3n del \u00e1rbol en el almac\u00e9n de expansi\u00f3n\", v3. Ha habido un error de corrupci\u00f3n del \u00e1rbol de maple desagradable pero sutil que parece haber existido desde el inicio del algoritmo. Este error parece mucho m\u00e1s probable que ocurra desde el commit f8d112a4e657 (\"mm/mmap: evitar poner a cero el \u00e1rbol vma en mmap_region()\"), que es el punto en el que comenzaron a enviarse informes sobre este error. Nos enteramos definitivamente del error gracias a los amables esfuerzos de Bert Karwatzki, quien me ayud\u00f3 enormemente a poder rastrearlo e identificar la causa. El error surge cuando se intenta realizar un almacenamiento de expansi\u00f3n en dos nodos de hoja, donde el nodo de hoja derecho es el hijo m\u00e1s a la derecha del padre compartido, y el almacenamiento consume por completo el nodo de modo derecho. Esto da como resultado que mas_wr_spanning_store() duplique por error las entradas nuevas y existentes en el pivote m\u00e1ximo dentro del rango, y por lo tanto la corrupci\u00f3n del \u00e1rbol de maple. El parche de correcci\u00f3n corrige esto detectando este escenario y no permitiendo la copia duplicada err\u00f3nea. El mensaje de confirmaci\u00f3n del parche de correcci\u00f3n detalla en gran medida c\u00f3mo ocurre esto. Esta serie tambi\u00e9n incluye una prueba que reproduce el problema de manera confiable y afirma que la correcci\u00f3n funciona correctamente. Bert ha probado amablemente la correcci\u00f3n y confirm\u00f3 que resolvi\u00f3 sus problemas. Adem\u00e1s, Mikhail Gavrilov inform\u00f3 amablemente lo que parece ser exactamente el mismo error, que esta correcci\u00f3n tambi\u00e9n deber\u00eda resolver. Este parche (de 2): Ha habido un error sutil presente en la implementaci\u00f3n del \u00e1rbol de maple desde su inicio. Esto surge de c\u00f3mo se realizan los almacenamientos: cuando se produce un almacenamiento, sobrescribir\u00e1 los rangos superpuestos y ajustar\u00e1 el \u00e1rbol seg\u00fan sea necesario para adaptarse a esto. Un rango siempre puede abarcar en \u00faltima instancia dos nodos de hoja. En este caso, recorremos los dos nodos de hoja, determinamos qu\u00e9 elementos no se sobrescriben a la izquierda y a la derecha del inicio y el final de los rangos respectivamente y luego reequilibramos el \u00e1rbol para que contenga estas entradas y la reci\u00e9n insertada. Este tipo de almacenamiento se denomina \"almac\u00e9n de expansi\u00f3n\" y se implementa mediante mas_wr_spanning_store(). Para llegar a esta etapa, mas_store_gfp() invoca a mas_wr_preallocate(), mas_wr_store_type() y mas_wr_walk() a su vez para recorrer el \u00e1rbol y actualizar el objeto (mas) para atravesar la ubicaci\u00f3n donde se debe realizar la escritura, determinando su tipo de almacenamiento. Cuando se requiere un almacenamiento de expansi\u00f3n, esta funci\u00f3n devuelve falso y se detiene en el nodo principal que contiene el rango de destino, y mas_wr_store_type() marca mas-&gt;store_type como wr_spanning_store para denotar este hecho. Cuando vamos a realizar el almacenamiento en mas_wr_spanning_store(), primero determinamos los elementos DESPU\u00c9S del FINAL del rango que deseamos almacenar (es decir, a la derecha de la entrada que se insertar\u00e1); lo hacemos caminando hasta el SIGUIENTE pivote en el \u00e1rbol (es decir, r_mas.last + 1), comenzando en el nodo que acabamos de determinar que contiene el rango sobre el que pretendemos escribir. Luego dirigimos nuestra atenci\u00f3n a las entradas a la izquierda de la entrada que estamos insertando, cuyo estado est\u00e1 representado por l_mas, y las copiamos en un \"nodo grande\", que es un nodo especial que contiene suficientes ranuras para contener los datos de dos nodos hoja. Luego copiamos la entrada que deseamos almacenar inmediatamente despu\u00e9s de esto; la copia y la inserci\u00f3n de la nueva entrada se realiza mediante mas_store_b_node(). Despu\u00e9s de esto, copiamos los elementos a la derecha del final del rango que estamos insertando, si no hemos excedido la longitud del nodo (es decir, r_mas.offset &lt;= r_mas.end).  ---truncado---"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/677f1df179cb68c12ddf7707ec325eb50e99c7d9", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/7c7874977da9e47ca0f53d8b9a5b17385fed83f2", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/982dd0d26d1f015ed34866579480d2be5250b0ef", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/bea07fd63192b61209d48cbb81ef474cc3ee4c62", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "53598F54-9EC3-481D-B042-1384D6EC10DD", "cpe_name": [], "versionStartIncluding": "6.1", "versionEndExcluding": "6.1.114"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "6B9489BC-825E-4EEE-8D93-F93C801988C8", "cpe_name": [], "versionStartIncluding": "6.2", "versionEndExcluding": "6.6.58"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "6E62D61A-F704-44DB-A311-17B7534DA7BC", "cpe_name": [], "versionStartIncluding": "6.7", "versionEndExcluding": "6.11.5"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.12:rc1:*:*:*:*:*:*", "matchCriteriaId": "7F361E1D-580F-4A2D-A509-7615F73167A1", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.12:rc2:*:*:*:*:*:*", "matchCriteriaId": "925478D0-3E3D-4E6F-ACD5-09F28D5DF82C", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.12:rc3:*:*:*:*:*:*", "matchCriteriaId": "3C95E234-D335-4B6C-96BF-E2CEBD8654ED", "cpe_name": []}]}]}}