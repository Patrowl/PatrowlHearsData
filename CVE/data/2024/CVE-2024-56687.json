{"publishedDate": "2024-12-28T10:15Z", "lastModifiedDate": "2025-01-31T15:58Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-56687", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: musb: Fix hardware lockup on first Rx endpoint request\n\nThere is a possibility that a request's callback could be invoked from\nusb_ep_queue() (call trace below, supplemented with missing calls):\n\nreq->complete from usb_gadget_giveback_request\n\t(drivers/usb/gadget/udc/core.c:999)\nusb_gadget_giveback_request from musb_g_giveback\n\t(drivers/usb/musb/musb_gadget.c:147)\nmusb_g_giveback from rxstate\n\t(drivers/usb/musb/musb_gadget.c:784)\nrxstate from musb_ep_restart\n\t(drivers/usb/musb/musb_gadget.c:1169)\nmusb_ep_restart from musb_ep_restart_resume_work\n\t(drivers/usb/musb/musb_gadget.c:1176)\nmusb_ep_restart_resume_work from musb_queue_resume_work\n\t(drivers/usb/musb/musb_core.c:2279)\nmusb_queue_resume_work from musb_gadget_queue\n\t(drivers/usb/musb/musb_gadget.c:1241)\nmusb_gadget_queue from usb_ep_queue\n\t(drivers/usb/gadget/udc/core.c:300)\n\nAccording to the docstring of usb_ep_queue(), this should not happen:\n\n\"Note that @req's ->complete() callback must never be called from within\nusb_ep_queue() as that can create deadlock situations.\"\n\nIn fact, a hardware lockup might occur in the following sequence:\n\n1. The gadget is initialized using musb_gadget_enable().\n2. Meanwhile, a packet arrives, and the RXPKTRDY flag is set, raising an\n   interrupt.\n3. If IRQs are enabled, the interrupt is handled, but musb_g_rx() finds an\n   empty queue (next_request() returns NULL). The interrupt flag has\n   already been cleared by the glue layer handler, but the RXPKTRDY flag\n   remains set.\n4. The first request is enqueued using usb_ep_queue(), leading to the call\n   of req->complete(), as shown in the call trace above.\n5. If the callback enables IRQs and another packet is waiting, step (3)\n   repeats. The request queue is empty because usb_g_giveback() removes the\n   request before invoking the callback.\n6. The endpoint remains locked up, as the interrupt triggered by hardware\n   setting the RXPKTRDY flag has been handled, but the flag itself remains\n   set.\n\nFor this scenario to occur, it is only necessary for IRQs to be enabled at\nsome point during the complete callback. This happens with the USB Ethernet\ngadget, whose rx_complete() callback calls netif_rx(). If called in the\ntask context, netif_rx() disables the bottom halves (BHs). When the BHs are\nre-enabled, IRQs are also enabled to allow soft IRQs to be processed. The\ngadget itself is initialized at module load (or at boot if built-in), but\nthe first request is enqueued when the network interface is brought up,\ntriggering rx_complete() in the task context via ioctl(). If a packet\narrives while the interface is down, it can prevent the interface from\nreceiving any further packets from the USB host.\n\nThe situation is quite complicated with many parties involved. This\nparticular issue can be resolved in several possible ways:\n\n1. Ensure that callbacks never enable IRQs. This would be difficult to\n   enforce, as discovering how netif_rx() interacts with interrupts was\n   already quite challenging and u_ether is not the only function driver.\n   Similar \"bugs\" could be hidden in other drivers as well.\n2. Disable MUSB interrupts in musb_g_giveback() before calling the callback\n   and re-enable them afterwars (by calling musb_{dis,en}able_interrupts(),\n   for example). This would ensure that MUSB interrupts are not handled\n   during the callback, even if IRQs are enabled. In fact, it would allow\n   IRQs to be enabled when releasing the lock. However, this feels like an\n   inelegant hack.\n3. Modify the interrupt handler to clear the RXPKTRDY flag if the request\n   queue is empty. While this approach also feels like a hack, it wastes\n   CPU time by attempting to handle incoming packets when the software is\n   not ready to process them.\n4. Flush the Rx FIFO instead of calling rxstate() in musb_ep_restart().\n   This ensures that the hardware can receive packets when there is at\n   least one request in the queue. Once I\n---truncated---"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: musb: Reparar bloqueo de hardware en la primera solicitud de endpoint Rx Existe la posibilidad de que la devoluci\u00f3n de llamada de una solicitud pueda invocarse desde usb_ep_queue() (rastreo de llamada a continuaci\u00f3n, complementado con llamadas faltantes): req-&gt;complete desde usb_gadget_giveback_request (drivers/usb/gadget/udc/core.c:999) usb_gadget_giveback_request desde musb_g_giveback (drivers/usb/musb/musb_gadget.c:147) musb_g_giveback desde rxstate (drivers/usb/musb/musb_gadget.c:784) rxstate desde musb_ep_restart (drivers/usb/musb/musb_gadget.c:1169) musb_ep_restart desde Seg\u00fan la cadena de documentaci\u00f3n de usb_ep_queue(), esto no deber\u00eda suceder: \"Tenga en cuenta que la devoluci\u00f3n de llamada -&gt;complete() de @req nunca debe llamarse desde usb_ep_queue() ya que eso puede crear situaciones de bloqueo\". De hecho, un bloqueo de hardware podr\u00eda ocurrir en la siguiente secuencia: 1. El gadget se inicializa usando musb_gadget_enable(). 2. Mientras tanto, llega un paquete y se activa el indicador RXPKTRDY, lo que genera una interrupci\u00f3n. 3. Si las IRQ est\u00e1n habilitadas, se gestiona la interrupci\u00f3n, pero musb_g_rx() encuentra una cola vac\u00eda (next_request() devuelve NULL). El indicador de interrupci\u00f3n ya ha sido borrado por el controlador de la capa de pegamento, pero el indicador RXPKTRDY permanece activado. 4. La primera solicitud se pone en cola usando usb_ep_queue(), lo que lleva a la llamada de req-&gt;complete(), como se muestra en el seguimiento de la llamada anterior. 5. Si la devoluci\u00f3n de llamada habilita las IRQ y hay otro paquete en espera, se repite el paso (3). La cola de solicitudes est\u00e1 vac\u00eda porque usb_g_giveback() elimina la solicitud antes de invocar la devoluci\u00f3n de llamada. 6. El endpoint permanece bloqueado, ya que se ha gestionado la interrupci\u00f3n provocada por la configuraci\u00f3n del hardware del indicador RXPKTRDY, pero el indicador en s\u00ed permanece configurado. Para que se produzca este escenario, solo es necesario que las IRQ se habiliten en alg\u00fan momento durante la devoluci\u00f3n de llamada completa. Esto sucede con el dispositivo USB Ethernet, cuya devoluci\u00f3n de llamada rx_complete() llama a netif_rx(). Si se llama en el contexto de la tarea, netif_rx() deshabilita las mitades inferiores (BH). Cuando se vuelven a habilitar las BH, tambi\u00e9n se habilitan las IRQ para permitir que se procesen las IRQ suaves. El dispositivo en s\u00ed se inicializa en la carga del m\u00f3dulo (o en el arranque si est\u00e1 integrado), pero la primera solicitud se pone en cola cuando se activa la interfaz de red, lo que activa rx_complete() en el contexto de la tarea a trav\u00e9s de ioctl(). Si llega un paquete mientras la interfaz est\u00e1 inactiva, puede impedir que la interfaz reciba m\u00e1s paquetes del host USB. La situaci\u00f3n es bastante complicada con muchas partes involucradas. Este problema en particular se puede resolver de varias maneras posibles: 1. Aseg\u00farese de que las devoluciones de llamadas nunca habiliten las IRQ. Esto ser\u00eda dif\u00edcil de hacer cumplir, ya que descubrir c\u00f3mo interact\u00faa netif_rx() con las interrupciones ya era bastante desafiante y u_ether no es el \u00fanico controlador de funci\u00f3n. Tambi\u00e9n podr\u00edan estar ocultos \"errores\" similares en otros controladores. 2. Desactive las interrupciones MUSB en musb_g_giveback() antes de llamar a la devoluci\u00f3n de llamada y vuelva a habilitarlas despu\u00e9s (llamando a musb_{dis,en}able_interrupts(), por ejemplo). Esto garantizar\u00eda que las interrupciones MUSB no se gestionen durante la devoluci\u00f3n de llamada, incluso si las IRQ est\u00e1n habilitadas. De hecho, permitir\u00eda que las IRQ se habiliten al liberar el bloqueo. Sin embargo, esto parece un truco poco elegante. 3. Modifique el controlador de interrupciones para borrar el indicador RXPKTRDY si la cola de solicitudes est\u00e1 vac\u00eda. Si bien este enfoque tambi\u00e9n parece un truco, desperdicia tiempo de CPU al intentar gestionar paquetes entrantes cuando el software no est\u00e1 listo para procesarlos. ---trunqu\u00e9---"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/0c89445e6d475b78d37b64ae520831cd43af7db4", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/3fc137386c4620305bbc2a216868c53f9245670a", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/5906ee3693674d734177df13a519a21bb03f730d", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/c749500b28cae67410792096133ee7f282439c51", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/f05ad9755bb294328c3d0f429164ac6d4d08c548", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-667"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "4EB97A09-F7D3-4B32-8BA0-E85161566B20", "cpe_name": [], "versionStartIncluding": "5.18", "versionEndExcluding": "6.1.120"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "CA16DEE3-ABEC-4449-9F4A-7A3DC4FC36C7", "cpe_name": [], "versionStartIncluding": "6.2", "versionEndExcluding": "6.6.64"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "21434379-192D-472F-9B54-D45E3650E893", "cpe_name": [], "versionStartIncluding": "6.7", "versionEndExcluding": "6.11.11"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "D8882B1B-2ABC-4838-AC1D-DBDBB5764776", "cpe_name": [], "versionStartIncluding": "6.12", "versionEndExcluding": "6.12.2"}]}]}}