{"publishedDate": "2024-12-27T14:15Z", "lastModifiedDate": "2025-10-01T20:17Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-53190", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nwifi: rtlwifi: Drastically reduce the attempts to read efuse in case of failures\n\nSyzkaller reported a hung task with uevent_show() on stack trace. That\nspecific issue was addressed by another commit [0], but even with that\nfix applied (for example, running v6.12-rc5) we face another type of hung\ntask that comes from the same reproducer [1]. By investigating that, we\ncould narrow it to the following path:\n\n(a) Syzkaller emulates a Realtek USB WiFi adapter using raw-gadget and\ndummy_hcd infrastructure.\n\n(b) During the probe of rtl8192cu, the driver ends-up performing an efuse\nread procedure (which is related to EEPROM load IIUC), and here lies the\nissue: the function read_efuse() calls read_efuse_byte() many times, as\nloop iterations depending on the efuse size (in our example, 512 in total).\n\nThis procedure for reading efuse bytes relies in a loop that performs an\nI/O read up to *10k* times in case of failures. We measured the time of\nthe loop inside read_efuse_byte() alone, and in this reproducer (which\ninvolves the dummy_hcd emulation layer), it takes 15 seconds each. As a\nconsequence, we have the driver stuck in its probe routine for big time,\nexposing a stack trace like below if we attempt to reboot the system, for\nexample:\n\ntask:kworker/0:3 state:D stack:0 pid:662 tgid:662 ppid:2 flags:0x00004000\nWorkqueue: usb_hub_wq hub_event\nCall Trace:\n __schedule+0xe22/0xeb6\n schedule_timeout+0xe7/0x132\n __wait_for_common+0xb5/0x12e\n usb_start_wait_urb+0xc5/0x1ef\n ? usb_alloc_urb+0x95/0xa4\n usb_control_msg+0xff/0x184\n _usbctrl_vendorreq_sync+0xa0/0x161\n _usb_read_sync+0xb3/0xc5\n read_efuse_byte+0x13c/0x146\n read_efuse+0x351/0x5f0\n efuse_read_all_map+0x42/0x52\n rtl_efuse_shadow_map_update+0x60/0xef\n rtl_get_hwinfo+0x5d/0x1c2\n rtl92cu_read_eeprom_info+0x10a/0x8d5\n ? rtl92c_read_chip_version+0x14f/0x17e\n rtl_usb_probe+0x323/0x851\n usb_probe_interface+0x278/0x34b\n really_probe+0x202/0x4a4\n __driver_probe_device+0x166/0x1b2\n driver_probe_device+0x2f/0xd8\n [...]\n\nWe propose hereby to drastically reduce the attempts of doing the I/O\nreads in case of failures, restricted to USB devices (given that\nthey're inherently slower than PCIe ones). By retrying up to 10 times\n(instead of 10000), we got reponsiveness in the reproducer, while seems\nreasonable to believe that there's no sane USB device implementation in\nthe field requiring this amount of retries at every I/O read in order\nto properly work. Based on that assumption, it'd be good to have it\nbackported to stable but maybe not since driver implementation (the 10k\nnumber comes from day 0), perhaps up to 6.x series makes sense.\n\n[0] Commit 15fffc6a5624 (\"driver core: Fix uevent_show() vs driver detach race\")\n\n[1] A note about that: this syzkaller report presents multiple reproducers\nthat differs by the type of emulated USB device. For this specific case,\ncheck the entry from 2024/08/08 06:23 in the list of crashes; the C repro\nis available at https://syzkaller.appspot.com/text?tag=ReproC&x=1521fc83980000."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: wifi: rtlwifi: Reduce dr\u00e1sticamente los intentos de leer efuse en caso de fallos Syzkaller inform\u00f3 de una tarea colgada con uevent_show() en el seguimiento de la pila. Ese problema espec\u00edfico fue abordado por otra confirmaci\u00f3n [0], pero incluso con esa correcci\u00f3n aplicada (por ejemplo, ejecutando v6.12-rc5) nos enfrentamos a otro tipo de tarea colgada que proviene del mismo reproductor [1]. Al investigar eso, pudimos reducirlo a la siguiente ruta: (a) Syzkaller emula un adaptador WiFi USB Realtek utilizando raw-gadget y la infraestructura dummy_hcd. (b) Durante el sondeo de rtl8192cu, el controlador termina realizando un procedimiento de lectura de efuse (que est\u00e1 relacionado con la carga de EEPROM IIUC), y aqu\u00ed radica el problema: la funci\u00f3n read_efuse() llama a read_efuse_byte() muchas veces, como iteraciones de bucle dependiendo del tama\u00f1o de efuse (en nuestro ejemplo, 512 en total). Este procedimiento para leer bytes de efuse se basa en un bucle que realiza una lectura de E/S hasta *10k* veces en caso de fallas. Medimos el tiempo del bucle dentro de read_efuse_byte() solamente, y en este reproductor (que involucra la capa de emulaci\u00f3n dummy_hcd), toma 15 segundos cada uno. Como consecuencia, tenemos al controlador atascado en su rutina de sondeo por mucho tiempo, exponiendo un seguimiento de pila como el siguiente si intentamos reiniciar el sistema, por ejemplo: task:kworker/0:3 state:D stack:0 pid:662 tgid:662 ppid:2 flags:0x00004000 Workqueue: usb_hub_wq hub_event Call Trace: __schedule+0xe22/0xeb6 schedule_timeout+0xe7/0x132 __wait_for_common+0xb5/0x12e usb_start_wait_urb+0xc5/0x1ef ? usb_alloc_urb+0x95/0xa4 usb_control_msg+0xff/0x184 _usbctrl_vendorreq_sync+0xa0/0x161 _usb_read_sync+0xb3/0xc5 lectura_efuse_byte+0x13c/0x146 lectura_efuse+0x351/0x5f0 efuse_read_all_map+0x42/0x52 rtl_efuse_shadow_map_update+0x60/0xef rtl_get_hwinfo+0x5d/0x1c2 rtl92cu_read_eeprom_info+0x10a/0x8d5 ? rtl92c_read_chip_version+0x14f/0x17e rtl_usb_probe+0x323/0x851 usb_probe_interface+0x278/0x34b really_probe+0x202/0x4a4 __driver_probe_device+0x166/0x1b2 driver_probe_device+0x2f/0xd8 [...] Proponemos reducir dr\u00e1sticamente los intentos de realizar lecturas de E/S en caso de fallos, restringidos a dispositivos USB (dado que son inherentemente m\u00e1s lentos que los PCIe). Al reintentar hasta 10 veces (en lugar de 10000), obtuvimos capacidad de respuesta en el reproductor, aunque parece razonable creer que no existe una implementaci\u00f3n sensata de dispositivos USB en el campo que requiera esta cantidad de reintentos en cada lectura de E/S para funcionar correctamente. En base a esa suposici\u00f3n, ser\u00eda bueno tenerlo retroportado a estable, pero tal vez no desde la implementaci\u00f3n del controlador (el n\u00famero 10k proviene del d\u00eda 0), tal vez hasta la serie 6.x tenga sentido. [0] Commit 15fffc6a5624 (\"driver core: Fix uevent_show() vs driver detach race\") [1] Una nota sobre eso: este informe de syzkaller presenta m\u00faltiples reproductores que difieren seg\u00fan el tipo de dispositivo USB emulado. Para este caso espec\u00edfico, verifique la entrada de 2024/08/08 06:23 en la lista de fallas; la reproducci\u00f3n en C est\u00e1 disponible en https://syzkaller.appspot.com/text?tag=ReproC&amp;x=1521fc83980000."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/5c1b544563005a00591a3aa86ecff62ed4d11be3", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/8f3551f67991652c83469c7dd51d7b9b187b265f", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/ac064c656f105b9122bc43991a170f95f72b7a43", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/c386fb76f01794f1023d01a6ec5f5c93d00acd3b", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/eeb0b9b9e66b0b54cdad8e1c1cf0f55e8ba4211c", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "C6CF4F6C-6140-4D9A-A477-CC5787AE2929", "cpe_name": [], "versionStartIncluding": "2.6.38", "versionEndExcluding": "6.1.120"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "CA16DEE3-ABEC-4449-9F4A-7A3DC4FC36C7", "cpe_name": [], "versionStartIncluding": "6.2", "versionEndExcluding": "6.6.64"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "21434379-192D-472F-9B54-D45E3650E893", "cpe_name": [], "versionStartIncluding": "6.7", "versionEndExcluding": "6.11.11"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "D8882B1B-2ABC-4838-AC1D-DBDBB5764776", "cpe_name": [], "versionStartIncluding": "6.12", "versionEndExcluding": "6.12.2"}]}]}}