{"publishedDate": "2024-05-17T14:15Z", "lastModifiedDate": "2024-11-21T09:20Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-35825", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: ncm: Fix handling of zero block length packets\n\nWhile connecting to a Linux host with CDC_NCM_NTB_DEF_SIZE_TX\nset to 65536, it has been observed that we receive short packets,\nwhich come at interval of 5-10 seconds sometimes and have block\nlength zero but still contain 1-2 valid datagrams present.\n\nAccording to the NCM spec:\n\n\"If wBlockLength = 0x0000, the block is terminated by a\nshort packet. In this case, the USB transfer must still\nbe shorter than dwNtbInMaxSize or dwNtbOutMaxSize. If\nexactly dwNtbInMaxSize or dwNtbOutMaxSize bytes are sent,\nand the size is a multiple of wMaxPacketSize for the\ngiven pipe, then no ZLP shall be sent.\n\nwBlockLength= 0x0000 must be used with extreme care, because\nof the possibility that the host and device may get out of\nsync, and because of test issues.\n\nwBlockLength = 0x0000 allows the sender to reduce latency by\nstarting to send a very large NTB, and then shortening it when\nthe sender discovers that there\u2019s not sufficient data to justify\nsending a large NTB\"\n\nHowever, there is a potential issue with the current implementation,\nas it checks for the occurrence of multiple NTBs in a single\ngiveback by verifying if the leftover bytes to be processed is zero\nor not. If the block length reads zero, we would process the same\nNTB infintely because the leftover bytes is never zero and it leads\nto a crash. Fix this by bailing out if block length reads zero."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: usb: gadget: ncm: corregido el manejo de paquetes de longitud de bloque cero Al conectarnos a un host Linux con CDC_NCM_NTB_DEF_SIZE_TX configurado en 65536, se ha observado que recibimos paquetes cortos, que vienen en intervalo de 5 a 10 segundos a veces y tiene una longitud de bloque cero, pero a\u00fan contiene 1 o 2 datagramas v\u00e1lidos presentes. Seg\u00fan la especificaci\u00f3n NCM: \"Si wBlockLength = 0x0000, el bloque finaliza con un paquete corto. En este caso, la transferencia USB a\u00fan debe ser m\u00e1s corta que dwNtbInMaxSize o dwNtbOutMaxSize. Si se env\u00edan exactamente bytes dwNtbInMaxSize o dwNtbOutMaxSize, y el tama\u00f1o es un m\u00faltiplo de wMaxPacketSize para la pipe dada, entonces no se enviar\u00e1 ning\u00fan ZLP. wBlockLength= 0x0000 debe usarse con extremo cuidado, debido a la posibilidad de que el host y el dispositivo no est\u00e9n sincronizados y debido a problemas de prueba con wBlockLength = 0x0000. permite al remitente reducir la latencia comenzando a enviar un NTB muy grande y luego acort\u00e1ndolo cuando el remitente descubre que no hay datos suficientes para justificar el env\u00edo de un NTB grande\". Sin embargo, existe un problema potencial con la implementaci\u00f3n actual, ya que verifica para la aparici\u00f3n de m\u00faltiples NTB en una sola devoluci\u00f3n verificando si los bytes sobrantes a procesar son cero o no. Si la longitud del bloque es cero, procesar\u00edamos el mismo NTB infinitamente porque los bytes sobrantes nunca son cero y provocan un bloqueo. Solucione este problema rescatando si la longitud del bloque es cero."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/6b2c73111a252263807b7598682663dc33aa4b4c", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/7664ee8bd80309b90d53488b619764f0a057f2b7", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/92b051b87658df7649ffcdef522593f21a2b296b", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/a0f77b5d6067285b8eca0ee3bd1e448a6258026f", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/a766761d206e7c36d7526e0ae749949d17ca582c", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e2dbfea520e60d58e0c498ba41bde10452257779", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/ef846cdbd100f7f9dc045e8bcd7fe4b3a3713c03", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f90ce1e04cbcc76639d6cba0fdbd820cd80b3c70", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/6b2c73111a252263807b7598682663dc33aa4b4c", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/7664ee8bd80309b90d53488b619764f0a057f2b7", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/92b051b87658df7649ffcdef522593f21a2b296b", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/a0f77b5d6067285b8eca0ee3bd1e448a6258026f", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/a766761d206e7c36d7526e0ae749949d17ca582c", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e2dbfea520e60d58e0c498ba41bde10452257779", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/ef846cdbd100f7f9dc045e8bcd7fe4b3a3713c03", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f90ce1e04cbcc76639d6cba0fdbd820cd80b3c70", "name": "", "refsource": "", "tags": []}, {"url": "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html", "name": "", "refsource": "", "tags": []}, {"url": "https://lists.debian.org/debian-lts-announce/2024/06/msg00020.html", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}