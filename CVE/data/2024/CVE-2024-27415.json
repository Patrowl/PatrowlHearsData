{"publishedDate": "2024-05-17T12:15Z", "lastModifiedDate": "2024-11-21T09:04Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-27415", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: bridge: confirm multicast packets before passing them up the stack\n\nconntrack nf_confirm logic cannot handle cloned skbs referencing\nthe same nf_conn entry, which will happen for multicast (broadcast)\nframes on bridges.\n\n Example:\n    macvlan0\n       |\n      br0\n     /  \\\n  ethX    ethY\n\n ethX (or Y) receives a L2 multicast or broadcast packet containing\n an IP packet, flow is not yet in conntrack table.\n\n 1. skb passes through bridge and fake-ip (br_netfilter)Prerouting.\n    -> skb->_nfct now references a unconfirmed entry\n 2. skb is broad/mcast packet. bridge now passes clones out on each bridge\n    interface.\n 3. skb gets passed up the stack.\n 4. In macvlan case, macvlan driver retains clone(s) of the mcast skb\n    and schedules a work queue to send them out on the lower devices.\n\n    The clone skb->_nfct is not a copy, it is the same entry as the\n    original skb.  The macvlan rx handler then returns RX_HANDLER_PASS.\n 5. Normal conntrack hooks (in NF_INET_LOCAL_IN) confirm the orig skb.\n\nThe Macvlan broadcast worker and normal confirm path will race.\n\nThis race will not happen if step 2 already confirmed a clone. In that\ncase later steps perform skb_clone() with skb->_nfct already confirmed (in\nhash table).  This works fine.\n\nBut such confirmation won't happen when eb/ip/nftables rules dropped the\npackets before they reached the nf_confirm step in postrouting.\n\nPablo points out that nf_conntrack_bridge doesn't allow use of stateful\nnat, so we can safely discard the nf_conn entry and let inet call\nconntrack again.\n\nThis doesn't work for bridge netfilter: skb could have a nat\ntransformation. Also bridge nf prevents re-invocation of inet prerouting\nvia 'sabotage_in' hook.\n\nWork around this problem by explicit confirmation of the entry at LOCAL_IN\ntime, before upper layer has a chance to clone the unconfirmed entry.\n\nThe downside is that this disables NAT and conntrack helpers.\n\nAlternative fix would be to add locking to all code parts that deal with\nunconfirmed packets, but even if that could be done in a sane way this\nopens up other problems, for example:\n\n-m physdev --physdev-out eth0 -j SNAT --snat-to 1.2.3.4\n-m physdev --physdev-out eth1 -j SNAT --snat-to 1.2.3.5\n\nFor multicast case, only one of such conflicting mappings will be\ncreated, conntrack only handles 1:1 NAT mappings.\n\nUsers should set create a setup that explicitly marks such traffic\nNOTRACK (conntrack bypass) to avoid this, but we cannot auto-bypass\nthem, ruleset might have accept rules for untracked traffic already,\nso user-visible behaviour would change."}, {"lang": "es", "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: netfilter: bridge: confirme los paquetes de multidifusi\u00f3n antes de pasarlos a la pila conntrack La l\u00f3gica nf_confirm no puede manejar skbs clonados que hagan referencia a la misma entrada nf_conn, lo que suceder\u00e1 con las tramas de multidifusi\u00f3n (difusi\u00f3n) en puentes. Ejemplo: macvlan0 | br0 / \\ ethX ethY ethX (o Y) recibe un paquete de multidifusi\u00f3n o difusi\u00f3n L2 que contiene un paquete IP, el flujo a\u00fan no est\u00e1 en la tabla conntrack. 1. skb pasa por el puente y el enrutamiento previo de IP falsa (br_netfilter). -&gt; skb-&gt;_nfct ahora hace referencia a una entrada no confirmada 2. skb es un paquete amplio/mcast. El puente ahora pasa clones en cada interfaz del puente. 3. skb pasa a la pila. 4. En el caso de macvlan, el controlador macvlan conserva los clones del skb mcast y programa una cola de trabajo para enviarlos a los dispositivos inferiores. El clon skb-&gt;_nfct no es una copia, es la misma entrada que el skb original. El controlador macvlan rx luego devuelve RX_HANDLER_PASS. 5. Los ganchos de conexi\u00f3n normales (en NF_INET_LOCAL_IN) confirman el skb original. El trabajador de transmisi\u00f3n de Macvlan y la ruta de confirmaci\u00f3n normal correr\u00e1n. Esta carrera no se realizar\u00e1 si el paso 2 ya confirm\u00f3 un clon. En ese caso, los pasos posteriores realizan skb_clone() con skb-&gt;_nfct ya confirmado (en la tabla hash). Esto funciona bien. Pero dicha confirmaci\u00f3n no ocurrir\u00e1 cuando las reglas eb/ip/nftables eliminen los paquetes antes de que alcancen el paso nf_confirm en el posenrutamiento. Pablo se\u00f1ala que nf_conntrack_bridge no permite el uso de nat con estado, por lo que podemos descartar con seguridad la entrada nf_conn y dejar que inet llame a conntrack nuevamente. Esto no funciona para bridge netfilter: skb podr\u00eda tener una transformaci\u00f3n nat. Adem\u00e1s, bridge nf evita la reinvocaci\u00f3n del enrutamiento previo de inet a trav\u00e9s del gancho 'sabotage_in'. Evite este problema confirmando expl\u00edcitamente la entrada en el momento LOCAL_IN, antes de que la capa superior tenga la oportunidad de clonar la entrada no confirmada. La desventaja es que esto desactiva NAT y los asistentes de conexi\u00f3n. Una soluci\u00f3n alternativa ser\u00eda agregar bloqueo a todas las partes del c\u00f3digo que tratan con paquetes no confirmados, pero incluso si eso pudiera hacerse de manera sensata, esto abre otros problemas, por ejemplo: -m physdev --physdev-out eth0 -j SNAT - -snat-to 1.2.3.4 -m physdev --physdev-out eth1 -j SNAT --snat-to 1.2.3.5 Para el caso de multidifusi\u00f3n, solo se crear\u00e1 una de estas asignaciones conflictivas, conntrack solo maneja asignaciones NAT 1:1. Los usuarios deben crear una configuraci\u00f3n que marque expl\u00edcitamente dicho tr\u00e1fico NOTRACK (omisi\u00f3n de conntrack) para evitar esto, pero no podemos omitirlos autom\u00e1ticamente, es posible que el conjunto de reglas ya haya aceptado reglas para el tr\u00e1fico sin seguimiento, por lo que el comportamiento visible para el usuario cambiar\u00eda."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/2b1414d5e94e477edff1d2c79030f1d742625ea0", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/62e7151ae3eb465e0ab52a20c941ff33bb6332e9", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/7c3f28599652acf431a2211168de4a583f30b6d5", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/80cd0487f630b5382734997c3e5e3003a77db315", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/cb734975b0ffa688ff6cc0eed463865bf07b6c01", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/2b1414d5e94e477edff1d2c79030f1d742625ea0", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/62e7151ae3eb465e0ab52a20c941ff33bb6332e9", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/7c3f28599652acf431a2211168de4a583f30b6d5", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/80cd0487f630b5382734997c3e5e3003a77db315", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/cb734975b0ffa688ff6cc0eed463865bf07b6c01", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}