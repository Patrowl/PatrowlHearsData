{"publishedDate": "2024-05-17T14:15Z", "lastModifiedDate": "2024-11-21T09:20Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-35803", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nx86/efistub: Call mixed mode boot services on the firmware's stack\n\nNormally, the EFI stub calls into the EFI boot services using the stack\nthat was live when the stub was entered. According to the UEFI spec,\nthis stack needs to be at least 128k in size - this might seem large but\nall asynchronous processing and event handling in EFI runs from the same\nstack and so quite a lot of space may be used in practice.\n\nIn mixed mode, the situation is a bit different: the bootloader calls\nthe 32-bit EFI stub entry point, which calls the decompressor's 32-bit\nentry point, where the boot stack is set up, using a fixed allocation\nof 16k. This stack is still in use when the EFI stub is started in\n64-bit mode, and so all calls back into the EFI firmware will be using\nthe decompressor's limited boot stack.\n\nDue to the placement of the boot stack right after the boot heap, any\nstack overruns have gone unnoticed. However, commit\n\n  5c4feadb0011983b (\"x86/decompressor: Move global symbol references to C code\")\n\nmoved the definition of the boot heap into C code, and now the boot\nstack is placed right at the base of BSS, where any overruns will\ncorrupt the end of the .data section.\n\nWhile it would be possible to work around this by increasing the size of\nthe boot stack, doing so would affect all x86 systems, and mixed mode\nsystems are a tiny (and shrinking) fraction of the x86 installed base.\n\nSo instead, record the firmware stack pointer value when entering from\nthe 32-bit firmware, and switch to this stack every time a EFI boot\nservice call is made."}, {"lang": "es", "value": "En el kernel de Linux, se resolvi\u00f3 la siguiente vulnerabilidad: x86/efistub: llame a los servicios de arranque en modo mixto en la pila del firmware. Normalmente, el c\u00f3digo auxiliar de EFI llama a los servicios de arranque de EFI utilizando la pila que estaba activa cuando se ingres\u00f3 el c\u00f3digo auxiliar. Seg\u00fan la especificaci\u00f3n UEFI, esta pila debe tener un tama\u00f1o m\u00ednimo de 128k; esto puede parecer grande, pero todo el procesamiento as\u00edncrono y el manejo de eventos en EFI se ejecutan desde la misma pila, por lo que en la pr\u00e1ctica se puede utilizar bastante espacio. En modo mixto, la situaci\u00f3n es un poco diferente: el gestor de arranque llama al punto de entrada del c\u00f3digo auxiliar EFI de 32 bits, que llama al punto de entrada de 32 bits del descompresor, donde se configura la pila de arranque, utilizando una asignaci\u00f3n fija de 16k. Esta pila todav\u00eda est\u00e1 en uso cuando el c\u00f3digo auxiliar EFI se inicia en modo de 64 bits, por lo que todas las llamadas al firmware EFI utilizar\u00e1n la pila de arranque limitada del descompresor. Debido a la ubicaci\u00f3n de la pila de arranque justo despu\u00e9s del mont\u00f3n de arranque, cualquier desbordamiento de la pila pasa desapercibido. Sin embargo, la confirmaci\u00f3n 5c4feadb0011983b (\"x86/decompressor: Mover referencias de s\u00edmbolos globales al c\u00f3digo C\") movi\u00f3 la definici\u00f3n del mont\u00f3n de arranque al c\u00f3digo C, y ahora la pila de arranque se coloca justo en la base de BSS, donde cualquier desbordamiento da\u00f1ar\u00e1 el final de la secci\u00f3n .data. Si bien ser\u00eda posible solucionar este problema aumentando el tama\u00f1o de la pila de arranque, hacerlo afectar\u00eda a todos los sistemas x86, y los sistemas de modo mixto son una fracci\u00f3n peque\u00f1a (y cada vez menor) de la base instalada x86. En su lugar, registre el valor del puntero de la pila de firmware al ingresar desde el firmware de 32 bits y cambie a esta pila cada vez que se realice una llamada al servicio de arranque EFI."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/2149f8a56e2ed345c7a4d022a79f6b8fc53ae926", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/725351c036452b7db5771a7bed783564bc4b99cc", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/930775060ca348b8665f60eef14b204172d14f31", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/cefcd4fe2e3aaf792c14c9e56dab89e3d7a65d02", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/fba7ee7187581b5bc222003e73e2592b398bb06d", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/2149f8a56e2ed345c7a4d022a79f6b8fc53ae926", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/725351c036452b7db5771a7bed783564bc4b99cc", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/930775060ca348b8665f60eef14b204172d14f31", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/cefcd4fe2e3aaf792c14c9e56dab89e3d7a65d02", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/fba7ee7187581b5bc222003e73e2592b398bb06d", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}