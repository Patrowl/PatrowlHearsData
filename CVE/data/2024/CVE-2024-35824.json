{"publishedDate": "2024-05-17T14:15Z", "lastModifiedDate": "2024-11-21T09:20Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-35824", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmisc: lis3lv02d_i2c: Fix regulators getting en-/dis-abled twice on suspend/resume\n\nWhen not configured for wakeup lis3lv02d_i2c_suspend() will call\nlis3lv02d_poweroff() even if the device has already been turned off\nby the runtime-suspend handler and if configured for wakeup and\nthe device is runtime-suspended at this point then it is not turned\nback on to serve as a wakeup source.\n\nBefore commit b1b9f7a49440 (\"misc: lis3lv02d_i2c: Add missing setting\nof the reg_ctrl callback\"), lis3lv02d_poweroff() failed to disable\nthe regulators which as a side effect made calling poweroff() twice ok.\n\nNow that poweroff() correctly disables the regulators, doing this twice\ntriggers a WARN() in the regulator core:\n\nunbalanced disables for regulator-dummy\nWARNING: CPU: 1 PID: 92 at drivers/regulator/core.c:2999 _regulator_disable\n...\n\nFix lis3lv02d_i2c_suspend() to not call poweroff() a second time if\nalready runtime-suspended and add a poweron() call when necessary to\nmake wakeup work.\n\nlis3lv02d_i2c_resume() has similar issues, with an added weirness that\nit always powers on the device if it is runtime suspended, after which\nthe first runtime-resume will call poweron() again, causing the enabled\ncount for the regulator to increase by 1 every suspend/resume. These\nunbalanced regulator_enable() calls cause the regulator to never\nbe turned off and trigger the following WARN() on driver unbind:\n\nWARNING: CPU: 1 PID: 1724 at drivers/regulator/core.c:2396 _regulator_put\n\nFix this by making lis3lv02d_i2c_resume() mirror the new suspend()."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: misc: lis3lv02d_i2c: corrige que los reguladores se activen/desactiven dos veces al suspender/reanudar Cuando no est\u00e1 configurado para reactivaci\u00f3n, lis3lv02d_i2c_suspend() llamar\u00e1 a lis3lv02d_poweroff() incluso si el dispositivo ya ha sido desactivado por el controlador de suspensi\u00f3n de tiempo de ejecuci\u00f3n y si est\u00e1 configurado para reactivaci\u00f3n y el dispositivo est\u00e1 suspendido en tiempo de ejecuci\u00f3n en este punto, no se vuelve a activar para que sirva como fuente de activaci\u00f3n. Antes de la confirmaci\u00f3n b1b9f7a49440 (\"misc: lis3lv02d_i2c: Agregar configuraci\u00f3n faltante de la devoluci\u00f3n de llamada reg_ctrl\"), lis3lv02d_poweroff() fallaba al deshabilitar los reguladores, lo que como efecto secundario hizo que llamar a poweroff() dos veces fuera correcto. Ahora que poweroff() desactiva correctamente los reguladores, al hacer esto dos veces se activa una ADVERTENCIA() en el n\u00facleo del regulador: desactivaciones desequilibradas para regulador ficticio ADVERTENCIA: CPU: 1 PID: 92 en drivers/regulator/core.c:2999 _regulator_disable .. Corrija lis3lv02d_i2c_suspend() para que no llame a poweroff() una segunda vez si ya est\u00e1 suspendido el tiempo de ejecuci\u00f3n y agregue una llamada a poweron() cuando sea necesario para que la reactivaci\u00f3n funcione. lis3lv02d_i2c_resume() tiene problemas similares, con el inconveniente adicional de que siempre enciende el dispositivo si el tiempo de ejecuci\u00f3n est\u00e1 suspendido, despu\u00e9s de lo cual la primera reanudaci\u00f3n del tiempo de ejecuci\u00f3n llamar\u00e1 a poweron() nuevamente, lo que provocar\u00e1 que el recuento habilitado para el regulador aumente en 1 cada suspender/reanudar. Estas llamadas desequilibradas regulator_enable() hacen que el regulador nunca se apague y activan la siguiente ADVERTENCIA() al desvincular el controlador: ADVERTENCIA: CPU: 1 PID: 1724 en drivers/regulator/core.c:2396 _regulator_put Solucione esto haciendo lis3lv02d_i2c_resume( ) refleja la nueva suspensi\u00f3n()."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/4154e767354140db7804207117e7238fb337b0e7", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/997ca415384612c8df76d99d9a768e0b3f42b325", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/ac3e0384073b2408d6cb0d972fee9fcc3776053d", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f6df761182fc953907b18aba5049fc2a044ecb45", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/4154e767354140db7804207117e7238fb337b0e7", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/997ca415384612c8df76d99d9a768e0b3f42b325", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/ac3e0384073b2408d6cb0d972fee9fcc3776053d", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f6df761182fc953907b18aba5049fc2a044ecb45", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}