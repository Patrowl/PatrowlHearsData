{"publishedDate": "2024-05-17T14:15Z", "lastModifiedDate": "2024-11-21T09:20Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-35818", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nLoongArch: Define the __io_aw() hook as mmiowb()\n\nCommit fb24ea52f78e0d595852e (\"drivers: Remove explicit invocations of\nmmiowb()\") remove all mmiowb() in drivers, but it says:\n\n\"NOTE: mmiowb() has only ever guaranteed ordering in conjunction with\nspin_unlock(). However, pairing each mmiowb() removal in this patch with\nthe corresponding call to spin_unlock() is not at all trivial, so there\nis a small chance that this change may regress any drivers incorrectly\nrelying on mmiowb() to order MMIO writes between CPUs using lock-free\nsynchronisation.\"\n\nThe mmio in radeon_ring_commit() is protected by a mutex rather than a\nspinlock, but in the mutex fastpath it behaves similar to spinlock. We\ncan add mmiowb() calls in the radeon driver but the maintainer says he\ndoesn't like such a workaround, and radeon is not the only example of\nmutex protected mmio.\n\nSo we should extend the mmiowb tracking system from spinlock to mutex,\nand maybe other locking primitives. This is not easy and error prone, so\nwe solve it in the architectural code, by simply defining the __io_aw()\nhook as mmiowb(). And we no longer need to override queued_spin_unlock()\nso use the generic definition.\n\nWithout this, we get such an error when run 'glxgears' on weak ordering\narchitectures such as LoongArch:\n\nradeon 0000:04:00.0: ring 0 stalled for more than 10324msec\nradeon 0000:04:00.0: ring 3 stalled for more than 10240msec\nradeon 0000:04:00.0: GPU lockup (current fence id 0x000000000001f412 last fence id 0x000000000001f414 on ring 3)\nradeon 0000:04:00.0: GPU lockup (current fence id 0x000000000000f940 last fence id 0x000000000000f941 on ring 0)\nradeon 0000:04:00.0: scheduling IB failed (-35).\n[drm:radeon_gem_va_ioctl [radeon]] *ERROR* Couldn't update BO_VA (-35)\nradeon 0000:04:00.0: scheduling IB failed (-35).\n[drm:radeon_gem_va_ioctl [radeon]] *ERROR* Couldn't update BO_VA (-35)\nradeon 0000:04:00.0: scheduling IB failed (-35).\n[drm:radeon_gem_va_ioctl [radeon]] *ERROR* Couldn't update BO_VA (-35)\nradeon 0000:04:00.0: scheduling IB failed (-35).\n[drm:radeon_gem_va_ioctl [radeon]] *ERROR* Couldn't update BO_VA (-35)\nradeon 0000:04:00.0: scheduling IB failed (-35).\n[drm:radeon_gem_va_ioctl [radeon]] *ERROR* Couldn't update BO_VA (-35)\nradeon 0000:04:00.0: scheduling IB failed (-35).\n[drm:radeon_gem_va_ioctl [radeon]] *ERROR* Couldn't update BO_VA (-35)\nradeon 0000:04:00.0: scheduling IB failed (-35).\n[drm:radeon_gem_va_ioctl [radeon]] *ERROR* Couldn't update BO_VA (-35)"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: LoongArch: define el gancho __io_aw() como mmiowb(). Confirmaci\u00f3n fb24ea52f78e0d595852e (\"drivers: elimina las invocaciones expl\u00edcitas de mmiowb()\") elimina todos los mmiowb() en los controladores, pero dice : \"NOTA: mmiowb() solo ha garantizado el pedido junto con spin_unlock(). Sin embargo, emparejar cada eliminaci\u00f3n de mmiowb() en este parche con la llamada correspondiente a spin_unlock() no es nada trivial, por lo que existe una peque\u00f1a posibilidad que este cambio puede hacer retroceder cualquier controlador que dependa incorrectamente de mmiowb() para ordenar escrituras MMIO entre CPU usando sincronizaci\u00f3n sin bloqueo\". El mmio en radeon_ring_commit() est\u00e1 protegido por un mutex en lugar de un spinlock, pero en el mutex fastpath se comporta de manera similar al spinlock. Podemos agregar llamadas mmiowb() en el controlador radeon, pero el mantenedor dice que no le gusta esa soluci\u00f3n, y radeon no es el \u00fanico ejemplo de mmio protegido por mutex. Entonces deber\u00edamos extender el sistema de seguimiento mmiowb de spinlock a mutex, y tal vez a otras primitivas de bloqueo. Esto no es f\u00e1cil y propenso a errores, por lo que lo solucionamos en el c\u00f3digo arquitect\u00f3nico, simplemente definiendo el gancho __io_aw() como mmiowb(). Y ya no necesitamos anular queued_spin_unlock() as\u00ed que use la definici\u00f3n gen\u00e9rica. Sin esto, obtenemos este error cuando ejecutamos 'glxgears' en arquitecturas de ordenamiento d\u00e9biles como LoongArch: radeon 0000:04:00.0: el anillo 0 se detuvo durante m\u00e1s de 10324 mseg radeon 0000:04:00.0: el anillo 3 se detuvo durante m\u00e1s de 10240 mseg radeon 0000:04:00.0: bloqueo de GPU (ID de valla actual 0x000000000001f412 ID de \u00faltima valla 0x000000000001f414 en el anillo 3) radeon 0000:04:00.0: Bloqueo de GPU (ID de valla actual 0x000000000000f940 ID de \u00faltima valla 0x000 000000000f941 en el anillo 0) radeon 0000:04:00.0: la programaci\u00f3n IB fall\u00f3 (-35). [drm:radeon_gem_va_ioctl [radeon]] *ERROR* No se pudo actualizar BO_VA (-35) radeon 0000:04:00.0: fall\u00f3 la programaci\u00f3n de IB (-35). [drm:radeon_gem_va_ioctl [radeon]] *ERROR* No se pudo actualizar BO_VA (-35) radeon 0000:04:00.0: fall\u00f3 la programaci\u00f3n de IB (-35). [drm:radeon_gem_va_ioctl [radeon]] *ERROR* No se pudo actualizar BO_VA (-35) radeon 0000:04:00.0: fall\u00f3 la programaci\u00f3n de IB (-35). [drm:radeon_gem_va_ioctl [radeon]] *ERROR* No se pudo actualizar BO_VA (-35) radeon 0000:04:00.0: fall\u00f3 la programaci\u00f3n de IB (-35). [drm:radeon_gem_va_ioctl [radeon]] *ERROR* No se pudo actualizar BO_VA (-35) radeon 0000:04:00.0: fall\u00f3 la programaci\u00f3n de IB (-35). [drm:radeon_gem_va_ioctl [radeon]] *ERROR* No se pudo actualizar BO_VA (-35) radeon 0000:04:00.0: fall\u00f3 la programaci\u00f3n de IB (-35). [drm:radeon_gem_va_ioctl [radeon]] *ERROR* No se pudo actualizar BO_VA (-35)"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/0b61a7dc6712b78799b3949997e8a5e94db5c4b0", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/97cd43ba824aec764f5ea2790d0c0a318f885167", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/9adec248bba33b1503252caf8e59d81febfc5ceb", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/9c68ece8b2a5c5ff9b2fcaea923dd73efeb174cd", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/d7d7c6cdea875be3b241d7d39873bb431db7154d", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/0b61a7dc6712b78799b3949997e8a5e94db5c4b0", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/97cd43ba824aec764f5ea2790d0c0a318f885167", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/9adec248bba33b1503252caf8e59d81febfc5ceb", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/9c68ece8b2a5c5ff9b2fcaea923dd73efeb174cd", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/d7d7c6cdea875be3b241d7d39873bb431db7154d", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}