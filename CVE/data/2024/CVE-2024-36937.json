{"publishedDate": "2024-05-30T16:15Z", "lastModifiedDate": "2024-11-21T09:22Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-36937", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nxdp: use flags field to disambiguate broadcast redirect\n\nWhen redirecting a packet using XDP, the bpf_redirect_map() helper will set\nup the redirect destination information in struct bpf_redirect_info (using\nthe __bpf_xdp_redirect_map() helper function), and the xdp_do_redirect()\nfunction will read this information after the XDP program returns and pass\nthe frame on to the right redirect destination.\n\nWhen using the BPF_F_BROADCAST flag to do multicast redirect to a whole\nmap, __bpf_xdp_redirect_map() sets the 'map' pointer in struct\nbpf_redirect_info to point to the destination map to be broadcast. And\nxdp_do_redirect() reacts to the value of this map pointer to decide whether\nit's dealing with a broadcast or a single-value redirect. However, if the\ndestination map is being destroyed before xdp_do_redirect() is called, the\nmap pointer will be cleared out (by bpf_clear_redirect_map()) without\nwaiting for any XDP programs to stop running. This causes xdp_do_redirect()\nto think that the redirect was to a single target, but the target pointer\nis also NULL (since broadcast redirects don't have a single target), so\nthis causes a crash when a NULL pointer is passed to dev_map_enqueue().\n\nTo fix this, change xdp_do_redirect() to react directly to the presence of\nthe BPF_F_BROADCAST flag in the 'flags' value in struct bpf_redirect_info\nto disambiguate between a single-target and a broadcast redirect. And only\nread the 'map' pointer if the broadcast flag is set, aborting if that has\nbeen cleared out in the meantime. This prevents the crash, while keeping\nthe atomic (cmpxchg-based) clearing of the map pointer itself, and without\nadding any more checks in the non-broadcast fast path."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: xdp: use el campo flags para eliminar la ambig\u00fcedad de la redirecci\u00f3n de transmisi\u00f3n Al redireccionar un paquete usando XDP, el asistente bpf_redirect_map() configurar\u00e1 la informaci\u00f3n del destino de redireccionamiento en la estructura bpf_redirect_info (usando el asistente __bpf_xdp_redirect_map() funci\u00f3n), y la funci\u00f3n xdp_do_redirect() leer\u00e1 esta informaci\u00f3n despu\u00e9s de que el programa XDP regrese y pasar\u00e1 el framework al destino de redireccionamiento correcto. Cuando se utiliza el indicador BPF_F_BROADCAST para realizar una redirecci\u00f3n de multidifusi\u00f3n a un mapa completo, __bpf_xdp_redirect_map() establece el puntero 'mapa' en la estructura bpf_redirect_info para que apunte al mapa de destino que se va a transmitir. Y xdp_do_redirect() reacciona al valor de este puntero de mapa para decidir si se trata de una transmisi\u00f3n o una redirecci\u00f3n de valor \u00fanico. Sin embargo, si el mapa de destino se destruye antes de llamar a xdp_do_redirect(), el puntero del mapa se borrar\u00e1 (mediante bpf_clear_redirect_map()) sin esperar a que deje de ejecutarse ning\u00fan programa XDP. Esto hace que xdp_do_redirect() piense que la redirecci\u00f3n fue a un \u00fanico objetivo, pero el puntero de destino tambi\u00e9n es NULL (dado que las redirecciones de difusi\u00f3n no tienen un \u00fanico objetivo), por lo que esto provoca un bloqueo cuando se pasa un puntero NULL a dev_map_enqueue( ). Para solucionar este problema, cambie xdp_do_redirect() para reaccionar directamente a la presencia del indicador BPF_F_BROADCAST en el valor 'flags' en la estructura bpf_redirect_info para eliminar la ambig\u00fcedad entre un redireccionamiento de destino \u00fanico y de transmisi\u00f3n. Y solo lea el puntero del 'mapa' si la bandera de transmisi\u00f3n est\u00e1 activada, abortando si se ha borrado mientras tanto. Esto evita el bloqueo, manteniendo al mismo tiempo la limpieza at\u00f3mica (basada en cmpxchg) del puntero del mapa y sin agregar m\u00e1s comprobaciones en la ruta r\u00e1pida sin transmisi\u00f3n."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/12481f30128fbebc2eeb55eb2d56390fdfa30c5e", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/272bfb019f3cc018f654b992115774e77b4f3ffc", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/5bcf0dcbf9066348058b88a510c57f70f384c92c", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/6fd81f9d333e7b3532036577b1beb74ba1323553", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e22e25820fa04ea5eaac4ef7ee200e9923f466a4", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/12481f30128fbebc2eeb55eb2d56390fdfa30c5e", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/272bfb019f3cc018f654b992115774e77b4f3ffc", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/5bcf0dcbf9066348058b88a510c57f70f384c92c", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/6fd81f9d333e7b3532036577b1beb74ba1323553", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/e22e25820fa04ea5eaac4ef7ee200e9923f466a4", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}