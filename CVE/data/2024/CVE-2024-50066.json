{"publishedDate": "2024-10-23T06:15Z", "lastModifiedDate": "2025-03-07T17:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-50066", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/mremap: fix move_normal_pmd/retract_page_tables race\n\nIn mremap(), move_page_tables() looks at the type of the PMD entry and the\nspecified address range to figure out by which method the next chunk of\npage table entries should be moved.\n\nAt that point, the mmap_lock is held in write mode, but no rmap locks are\nheld yet.  For PMD entries that point to page tables and are fully covered\nby the source address range, move_pgt_entry(NORMAL_PMD, ...) is called,\nwhich first takes rmap locks, then does move_normal_pmd(). \nmove_normal_pmd() takes the necessary page table locks at source and\ndestination, then moves an entire page table from the source to the\ndestination.\n\nThe problem is: The rmap locks, which protect against concurrent page\ntable removal by retract_page_tables() in the THP code, are only taken\nafter the PMD entry has been read and it has been decided how to move it. \nSo we can race as follows (with two processes that have mappings of the\nsame tmpfs file that is stored on a tmpfs mount with huge=advise); note\nthat process A accesses page tables through the MM while process B does it\nthrough the file rmap:\n\nprocess A                      process B\n=========                      =========\nmremap\n  mremap_to\n    move_vma\n      move_page_tables\n        get_old_pmd\n        alloc_new_pmd\n                      *** PREEMPT ***\n                               madvise(MADV_COLLAPSE)\n                                 do_madvise\n                                   madvise_walk_vmas\n                                     madvise_vma_behavior\n                                       madvise_collapse\n                                         hpage_collapse_scan_file\n                                           collapse_file\n                                             retract_page_tables\n                                               i_mmap_lock_read(mapping)\n                                               pmdp_collapse_flush\n                                               i_mmap_unlock_read(mapping)\n        move_pgt_entry(NORMAL_PMD, ...)\n          take_rmap_locks\n          move_normal_pmd\n          drop_rmap_locks\n\nWhen this happens, move_normal_pmd() can end up creating bogus PMD entries\nin the line `pmd_populate(mm, new_pmd, pmd_pgtable(pmd))`.  The effect\ndepends on arch-specific and machine-specific details; on x86, you can end\nup with physical page 0 mapped as a page table, which is likely\nexploitable for user->kernel privilege escalation.\n\nFix the race by letting process B recheck that the PMD still points to a\npage table after the rmap locks have been taken.  Otherwise, we bail and\nlet the caller fall back to the PTE-level copying path, which will then\nbail immediately at the pmd_none() check.\n\nBug reachability: Reaching this bug requires that you can create\nshmem/file THP mappings - anonymous THP uses different code that doesn't\nzap stuff under rmap locks.  File THP is gated on an experimental config\nflag (CONFIG_READ_ONLY_THP_FOR_FS), so on normal distro kernels you need\nshmem THP to hit this bug.  As far as I know, getting shmem THP normally\nrequires that you can mount your own tmpfs with the right mount flags,\nwhich would require creating your own user+mount namespace; though I don't\nknow if some distros maybe enable shmem THP by default or something like\nthat.\n\nBug impact: This issue can likely be used for user->kernel privilege\nescalation when it is reachable."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm/mremap: correcci\u00f3n de la ejecuci\u00f3n move_normal_pmd/retract_page_tables En mremap(), move_page_tables() examina el tipo de entrada PMD y el rango de direcciones especificado para determinar mediante qu\u00e9 m\u00e9todo se debe mover el siguiente fragmento de entradas de la tabla de p\u00e1ginas. En ese punto, el mmap_lock se mantiene en modo de escritura, pero a\u00fan no se mantienen bloqueos rmap. Para las entradas PMD que apuntan a tablas de p\u00e1ginas y est\u00e1n completamente cubiertas por el rango de direcciones de origen, se llama a move_pgt_entry(NORMAL_PMD, ...), que primero toma bloqueos rmap y luego realiza move_normal_pmd(). move_normal_pmd() toma los bloqueos de tabla de p\u00e1ginas necesarios en el origen y el destino, luego mueve una tabla de p\u00e1ginas completa desde el origen hasta el destino. El problema es el siguiente: los bloqueos de rmap, que protegen contra la eliminaci\u00f3n simult\u00e1nea de tablas de p\u00e1ginas por retract_page_tables() en el c\u00f3digo THP, solo se toman despu\u00e9s de que se haya le\u00eddo la entrada PMD y se haya decidido c\u00f3mo moverla. Por lo tanto, podemos competir de la siguiente manera (con dos procesos que tienen asignaciones del mismo archivo tmpfs que est\u00e1 almacenado en un montaje tmpfs con huge=advise); tenga en cuenta que el proceso A accede a las tablas de p\u00e1ginas a trav\u00e9s del MM mientras que el proceso B lo hace a trav\u00e9s del archivo rmap: proceso A proceso B ========= ========= mremap mremap_to move_vma move_page_tables get_old_pmd alloc_new_pmd *** PREEMPT *** madvise(MADV_COLLAPSE) do_madvise madvise_walk_vmas madvise_vma_behavior madvise_collapse hpage_collapse_scan_file collapse_file retract_page_tables i_mmap_lock_read(mapping) pmdp_collapse_flush i_mmap_unlock_read(mapping) move_pgt_entry(NORMAL_PMD, ...) take_rmap_locks move_normal_pmd drop_rmap_locks Cuando esto sucede, move_normal_pmd() puede terminar creando entradas PMD falsas en la l\u00ednea `pmd_populate(mm, new_pmd, pmd_pgtable(pmd))`. El efecto depende de detalles espec\u00edficos de la arquitectura y de la m\u00e1quina; en x86, puede terminar con la p\u00e1gina f\u00edsica 0 mapeada como una tabla de p\u00e1ginas, lo que probablemente sea explotable para la escalada de privilegios de usuario a kernel. Arregle la ejecuci\u00f3n permitiendo que el proceso B vuelva a verificar que el PMD a\u00fan apunta a una tabla de p\u00e1ginas despu\u00e9s de que se hayan tomado los bloqueos rmap. De lo contrario, abandonamos y dejamos que el llamador vuelva a la ruta de copia de nivel PTE, que luego abandonar\u00e1 inmediatamente en la verificaci\u00f3n pmd_none(). Alcance del error: Alcanzar este error requiere que pueda crear asignaciones shmem/file THP - el THP an\u00f3nimo usa un c\u00f3digo diferente que no elimina cosas bajo bloqueos rmap. El THP de archivo est\u00e1 controlado por un indicador de configuraci\u00f3n experimental (CONFIG_READ_ONLY_THP_FOR_FS), por lo que en los n\u00facleos de distribuci\u00f3n normales necesita shmem THP para alcanzar este error. Hasta donde yo s\u00e9, obtener shmem THP normalmente requiere que puedas montar tu propio tmpfs con los indicadores de montaje correctos, lo que requerir\u00eda crear tu propio espacio de nombres de usuario+montaje; aunque no s\u00e9 si algunas distribuciones habilitan shmem THP de forma predeterminada o algo as\u00ed. Impacto del error: es probable que este problema se pueda usar para la escalada de privilegios de usuario a kernel cuando sea posible."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/1552ce9ce8af47c0fe911682e5e1855e25851ca9", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/17396e32f975130b3e6251f024c8807d192e4c3e", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/6fa1066fc5d00cb9f1b0e83b7ff6ef98d26ba2aa", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://project-zero.issues.chromium.org/issues/371047675", "name": "", "refsource": "", "tags": []}, {"url": "https://www.vicarius.io/vsociety/posts/cve-2024-50066-kernel-detection-vulnerability", "name": "", "refsource": "", "tags": []}, {"url": "https://www.vicarius.io/vsociety/posts/cve-2024-50066-kernel-mitigation-vulnerability", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-362"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.0, "impactScore": 5.9, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "baseScore": 7.0, "baseSeverity": "HIGH", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "EF2A1323-F872-46E8-8B68-855EFEFA193F", "cpe_name": [], "versionStartIncluding": "6.6", "versionEndExcluding": "6.6.58"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "6E62D61A-F704-44DB-A311-17B7534DA7BC", "cpe_name": [], "versionStartIncluding": "6.7", "versionEndExcluding": "6.11.5"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.12:rc1:*:*:*:*:*:*", "matchCriteriaId": "7F361E1D-580F-4A2D-A509-7615F73167A1", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.12:rc2:*:*:*:*:*:*", "matchCriteriaId": "925478D0-3E3D-4E6F-ACD5-09F28D5DF82C", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.12:rc3:*:*:*:*:*:*", "matchCriteriaId": "3C95E234-D335-4B6C-96BF-E2CEBD8654ED", "cpe_name": []}]}]}}