{"publishedDate": "2024-07-17T07:15Z", "lastModifiedDate": "2025-11-03T22:17Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-41009", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix overrunning reservations in ringbuf\n\nThe BPF ring buffer internally is implemented as a power-of-2 sized circular\nbuffer, with two logical and ever-increasing counters: consumer_pos is the\nconsumer counter to show which logical position the consumer consumed the\ndata, and producer_pos which is the producer counter denoting the amount of\ndata reserved by all producers.\n\nEach time a record is reserved, the producer that \"owns\" the record will\nsuccessfully advance producer counter. In user space each time a record is\nread, the consumer of the data advanced the consumer counter once it finished\nprocessing. Both counters are stored in separate pages so that from user\nspace, the producer counter is read-only and the consumer counter is read-write.\n\nOne aspect that simplifies and thus speeds up the implementation of both\nproducers and consumers is how the data area is mapped twice contiguously\nback-to-back in the virtual memory, allowing to not take any special measures\nfor samples that have to wrap around at the end of the circular buffer data\narea, because the next page after the last data page would be first data page\nagain, and thus the sample will still appear completely contiguous in virtual\nmemory.\n\nEach record has a struct bpf_ringbuf_hdr { u32 len; u32 pg_off; } header for\nbook-keeping the length and offset, and is inaccessible to the BPF program.\nHelpers like bpf_ringbuf_reserve() return `(void *)hdr + BPF_RINGBUF_HDR_SZ`\nfor the BPF program to use. Bing-Jhong and Muhammad reported that it is however\npossible to make a second allocated memory chunk overlapping with the first\nchunk and as a result, the BPF program is now able to edit first chunk's\nheader.\n\nFor example, consider the creation of a BPF_MAP_TYPE_RINGBUF map with size\nof 0x4000. Next, the consumer_pos is modified to 0x3000 /before/ a call to\nbpf_ringbuf_reserve() is made. This will allocate a chunk A, which is in\n[0x0,0x3008], and the BPF program is able to edit [0x8,0x3008]. Now, lets\nallocate a chunk B with size 0x3000. This will succeed because consumer_pos\nwas edited ahead of time to pass the `new_prod_pos - cons_pos > rb->mask`\ncheck. Chunk B will be in range [0x3008,0x6010], and the BPF program is able\nto edit [0x3010,0x6010]. Due to the ring buffer memory layout mentioned\nearlier, the ranges [0x0,0x4000] and [0x4000,0x8000] point to the same data\npages. This means that chunk B at [0x4000,0x4008] is chunk A's header.\nbpf_ringbuf_submit() / bpf_ringbuf_discard() use the header's pg_off to then\nlocate the bpf_ringbuf itself via bpf_ringbuf_restore_from_rec(). Once chunk\nB modified chunk A's header, then bpf_ringbuf_commit() refers to the wrong\npage and could cause a crash.\n\nFix it by calculating the oldest pending_pos and check whether the range\nfrom the oldest outstanding record to the newest would span beyond the ring\nbuffer size. If that is the case, then reject the request. We've tested with\nthe ring buffer benchmark in BPF selftests (./benchs/run_bench_ringbufs.sh)\nbefore/after the fix and while it seems a bit slower on some benchmarks, it\nis still not significantly enough to matter."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf: corrige el exceso de reservas en ringbuf. El b\u00fafer de anillo BPF se implementa internamente como un b\u00fafer circular de tama\u00f1o potencia de 2, con dos contadores l\u00f3gicos y en constante aumento: consumer_pos es el consumidor contador para mostrar en qu\u00e9 posici\u00f3n l\u00f3gica el consumidor consumi\u00f3 los datos, y productor_pos, que es el contador del productor que indica la cantidad de datos reservados por todos los productores. Cada vez que se reserva un registro, el productor \"due\u00f1o\" del registro avanzar\u00e1 exitosamente el contador de productores. En el espacio de usuario, cada vez que se lee un registro, el consumidor de los datos avanza el contador del consumidor una vez que finaliza el procesamiento. Ambos contadores se almacenan en p\u00e1ginas separadas de modo que, desde el espacio del usuario, el contador del productor sea de solo lectura y el contador del consumidor sea de lectura y escritura. Un aspecto que simplifica y, por lo tanto, acelera la implementaci\u00f3n tanto de productores como de consumidores es c\u00f3mo el \u00e1rea de datos se mapea dos veces de forma contigua y consecutiva en la memoria virtual, lo que permite no tomar medidas especiales para las muestras que tienen que envolverse en el mismo lugar. al final del \u00e1rea de datos del b\u00fafer circular, porque la p\u00e1gina siguiente despu\u00e9s de la \u00faltima p\u00e1gina de datos volver\u00eda a ser la primera p\u00e1gina de datos y, por lo tanto, la muestra seguir\u00e1 apareciendo completamente contigua en la memoria virtual. Cada registro tiene una estructura bpf_ringbuf_hdr { u32 len; u32 p\u00e1gina_apagada; } encabezado para la contabilidad de la longitud y el desplazamiento, y es inaccesible para el programa BPF. Ayudantes como bpf_ringbuf_reserve() devuelven `(void *)hdr + BPF_RINGBUF_HDR_SZ` para que lo use el programa BPF. Bing-Jhong y Muhammad informaron que, sin embargo, es posible hacer que un segundo fragmento de memoria asignado se superponga con el primer fragmento y, como resultado, el programa BPF ahora puede editar el encabezado del primer fragmento. Por ejemplo, considere la creaci\u00f3n de un mapa BPF_MAP_TYPE_RINGBUF con un tama\u00f1o de 0x4000. A continuaci\u00f3n, consumer_pos se modifica a 0x3000 /antes/ se realiza una llamada a bpf_ringbuf_reserve(). Esto asignar\u00e1 un fragmento A, que est\u00e1 en [0x0,0x3008], y el programa BPF podr\u00e1 editar [0x8,0x3008]. Ahora, asignemos un fragmento B con tama\u00f1o 0x3000. Esto tendr\u00e1 \u00e9xito porque consumer_pos se edit\u00f3 con anticipaci\u00f3n para pasar la verificaci\u00f3n `new_prod_pos - cons_pos &gt; rb-&gt;mask`. El fragmento B estar\u00e1 en el rango [0x3008,0x6010] y el programa BPF podr\u00e1 editar [0x3010,0x6010]. Debido al dise\u00f1o de la memoria del b\u00fafer en anillo mencionado anteriormente, los rangos [0x0,0x4000] y [0x4000,0x8000] apuntan a las mismas p\u00e1ginas de datos. Esto significa que el fragmento B en [0x4000,0x4008] es el encabezado del fragmento A. bpf_ringbuf_submit() / bpf_ringbuf_discard() usa el pg_off del encabezado para luego ubicar el bpf_ringbuf a trav\u00e9s de bpf_ringbuf_restore_from_rec(). Una vez que el fragmento B modific\u00f3 el encabezado del fragmento A, bpf_ringbuf_commit() hace referencia a la p\u00e1gina incorrecta y podr\u00eda causar un bloqueo. Solucionelo calculando el pendiente_pos m\u00e1s antiguo y verifique si el rango desde el registro pendiente m\u00e1s antiguo hasta el m\u00e1s nuevo abarcar\u00eda m\u00e1s all\u00e1 del tama\u00f1o del b\u00fafer circular. Si ese es el caso, rechace la solicitud. Hemos probado con el punto de referencia del b\u00fafer de anillo en las autopruebas de BPF (./benchs/run_bench_ringbufs.sh) antes/despu\u00e9s de la correcci\u00f3n y, aunque parece un poco m\u00e1s lento en algunos puntos de referencia, todav\u00eda no es lo suficientemente significativo como para importar."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/0f98f40eb1ed52af8b81f61901b6c0289ff59de4", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/47416c852f2a04d348ea66ee451cbdcf8119f225", "name": "", "refsource": "", "tags": ["Mailing List", "Patch"]}, {"url": "https://git.kernel.org/stable/c/511804ab701c0503b72eac08217eabfd366ba069", "name": "", "refsource": "", "tags": ["Mailing List", "Patch"]}, {"url": "https://git.kernel.org/stable/c/be35504b959f2749bab280f4671e8df96dcf836f", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/cfa1a2329a691ffd991fcf7248a57d752e712881", "name": "", "refsource": "", "tags": ["Mailing List", "Patch"]}, {"url": "https://git.kernel.org/stable/c/d1b9df0435bc61e0b44f578846516df8ef476686", "name": "", "refsource": "", "tags": ["Mailing List", "Patch"]}, {"url": "https://git.kernel.org/stable/c/0f98f40eb1ed52af8b81f61901b6c0289ff59de4", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/47416c852f2a04d348ea66ee451cbdcf8119f225", "name": "", "refsource": "", "tags": ["Mailing List", "Patch"]}, {"url": "https://git.kernel.org/stable/c/511804ab701c0503b72eac08217eabfd366ba069", "name": "", "refsource": "", "tags": ["Mailing List", "Patch"]}, {"url": "https://git.kernel.org/stable/c/be35504b959f2749bab280f4671e8df96dcf836f", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/cfa1a2329a691ffd991fcf7248a57d752e712881", "name": "", "refsource": "", "tags": ["Mailing List", "Patch"]}, {"url": "https://git.kernel.org/stable/c/d1b9df0435bc61e0b44f578846516df8ef476686", "name": "", "refsource": "", "tags": ["Mailing List", "Patch"]}, {"url": "https://lists.debian.org/debian-lts-announce/2025/01/msg00001.html", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-770"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "5F2E2CF9-E512-4F81-AD6C-400701BDBF04", "cpe_name": [], "versionStartIncluding": "5.8", "versionEndExcluding": "6.1.97"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "D72E033B-5323-4C4D-8818-36E1EBC3535F", "cpe_name": [], "versionStartIncluding": "6.2", "versionEndExcluding": "6.6.37"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "E95105F2-32E3-4C5F-9D18-7AEFD0E6275C", "cpe_name": [], "versionStartIncluding": "6.7", "versionEndExcluding": "6.9.8"}]}]}}