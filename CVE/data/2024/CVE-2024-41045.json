{"publishedDate": "2024-07-29T15:15Z", "lastModifiedDate": "2024-11-21T09:32Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-41045", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Defer work in bpf_timer_cancel_and_free\n\nCurrently, the same case as previous patch (two timer callbacks trying\nto cancel each other) can be invoked through bpf_map_update_elem as\nwell, or more precisely, freeing map elements containing timers. Since\nthis relies on hrtimer_cancel as well, it is prone to the same deadlock\nsituation as the previous patch.\n\nIt would be sufficient to use hrtimer_try_to_cancel to fix this problem,\nas the timer cannot be enqueued after async_cancel_and_free. Once\nasync_cancel_and_free has been done, the timer must be reinitialized\nbefore it can be armed again. The callback running in parallel trying to\narm the timer will fail, and freeing bpf_hrtimer without waiting is\nsufficient (given kfree_rcu), and bpf_timer_cb will return\nHRTIMER_NORESTART, preventing the timer from being rearmed again.\n\nHowever, there exists a UAF scenario where the callback arms the timer\nbefore entering this function, such that if cancellation fails (due to\ntimer callback invoking this routine, or the target timer callback\nrunning concurrently). In such a case, if the timer expiration is\nsignificantly far in the future, the RCU grace period expiration\nhappening before it will free the bpf_hrtimer state and along with it\nthe struct hrtimer, that is enqueued.\n\nHence, it is clear cancellation needs to occur after\nasync_cancel_and_free, and yet it cannot be done inline due to deadlock\nissues. We thus modify bpf_timer_cancel_and_free to defer work to the\nglobal workqueue, adding a work_struct alongside rcu_head (both used at\n_different_ points of time, so can share space).\n\nUpdate existing code comments to reflect the new state of affairs."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf: Aplazar el trabajo en bpf_timer_cancel_and_free Actualmente, el mismo caso del parche anterior (dos devoluciones de llamada de temporizador que intentan cancelarse entre s\u00ed) tambi\u00e9n se puede invocar a trav\u00e9s de bpf_map_update_elem, o m\u00e1s precisamente, liberando mapa elementos que contienen temporizadores. Dado que esto tambi\u00e9n depende de hrtimer_cancel, es propenso a la misma situaci\u00f3n de punto muerto que el parche anterior. Ser\u00eda suficiente usar hrtimer_try_to_cancel para solucionar este problema, ya que el temporizador no se puede poner en cola despu\u00e9s de async_cancel_and_free. Una vez que se haya realizado async_cancel_and_free, el temporizador debe reinicializarse antes de poder armarse nuevamente. La devoluci\u00f3n de llamada que se ejecuta en paralelo al intentar armar el temporizador fallar\u00e1, y liberar bpf_hrtimer sin esperar es suficiente (dado kfree_rcu), y bpf_timer_cb devolver\u00e1 HRTIMER_NORESTART, evitando que el temporizador se rearme nuevamente. Sin embargo, existe un escenario UAF en el que la devoluci\u00f3n de llamada arma el temporizador antes de ingresar a esta funci\u00f3n, de modo que si la cancelaci\u00f3n falla (debido a que la devoluci\u00f3n de llamada del temporizador invoca esta rutina o la devoluci\u00f3n de llamada del temporizador de destino se ejecuta simult\u00e1neamente). En tal caso, si la expiraci\u00f3n del temporizador est\u00e1 significativamente lejos en el futuro, la expiraci\u00f3n del per\u00edodo de gracia de RCU que ocurra antes liberar\u00e1 el estado bpf_hrtimer y junto con \u00e9l la estructura hrtimer, que est\u00e1 en cola. Por lo tanto, est\u00e1 claro que la cancelaci\u00f3n debe ocurrir despu\u00e9s de async_cancel_and_free y, sin embargo, no se puede realizar en l\u00ednea debido a problemas de interbloqueo. Por lo tanto, modificamos bpf_timer_cancel_and_free para diferir el trabajo a la cola de trabajo global, agregando un work_struct junto con rcu_head (ambos usados en _diferentes_ puntos de tiempo, por lo que pueden compartir espacio). Actualice los comentarios del c\u00f3digo existente para reflejar la nueva situaci\u00f3n."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/7aa5a19279c3639ae8b758b63f05d0c616a39fa1", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/7aa5a19279c3639ae8b758b63f05d0c616a39fa1", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/a6fcd19d7eac1335eb76bc16b6a66b7f574d1d69", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}