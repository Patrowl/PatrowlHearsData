{"publishedDate": "2025-01-21T13:15Z", "lastModifiedDate": "2025-01-21T13:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-57941", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfs: Fix the (non-)cancellation of copy when cache is temporarily disabled\n\nWhen the caching for a cookie is temporarily disabled (e.g. due to a DIO\nwrite on that file), future copying to the cache for that file is disabled\nuntil all fds open on that file are closed.  However, if netfslib is using\nthe deprecated PG_private_2 method (such as is currently used by ceph), and\ndecides it wants to copy to the cache, netfs_advance_write() will just bail\nat the first check seeing that the cache stream is unavailable, and\nindicate that it dealt with all the content.\n\nThis means that we have no subrequests to provide notifications to drive\nthe state machine or even to pin the request and the request just gets\ndiscarded, leaving the folios with PG_private_2 set.\n\nFix this by jumping directly to cancel the request if the cache is not\navailable.  That way, we don't remove mark3 from the folio_queue list and\nnetfs_pgpriv2_cancel() will clean up the folios.\n\nThis was found by running the generic/013 xfstest against ceph with an\nactive cache and the \"-o fsc\" option passed to ceph.  That would usually\nhang"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: netfs: Arreglar la (no) cancelaci\u00f3n de copia cuando el cach\u00e9 est\u00e1 deshabilitado temporalmente Cuando el almacenamiento en cach\u00e9 de una cookie est\u00e1 deshabilitado temporalmente (por ejemplo, debido a una escritura DIO en ese archivo), la copia futura al cach\u00e9 para ese archivo se deshabilita hasta que todos los fds abiertos en ese archivo se cierren. Sin embargo, si netfslib est\u00e1 usando el m\u00e9todo PG_private_2 obsoleto (como el que usa actualmente ceph) y decide que quiere copiar al cach\u00e9, netfs_advance_write() simplemente abandonar\u00e1 en la primera verificaci\u00f3n al ver que el flujo de cach\u00e9 no est\u00e1 disponible e indicar\u00e1 que se ocup\u00f3 de todo el contenido. Esto significa que no tenemos subsolicitudes para proporcionar notificaciones para controlar la m\u00e1quina de estado o incluso para fijar la solicitud y la solicitud simplemente se descarta, dejando los folios con PG_private_2 establecido. Arregle esto saltando directamente para cancelar la solicitud si el cach\u00e9 no est\u00e1 disponible. De esa manera, no eliminamos mark3 de la lista folio_queue y netfs_pgpriv2_cancel() limpiar\u00e1 los folios. Esto se descubri\u00f3 al ejecutar el xfstest gen\u00e9rico/013 contra ceph con un cach\u00e9 activo y la opci\u00f3n \"-o fsc\" pasada a ceph. Eso generalmente se bloqueaba"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/ba37bdfe59fb43e80dd79290340a21864ba4b61e", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/d0327c824338cdccad058723a31d038ecd553409", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}