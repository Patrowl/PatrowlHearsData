{"publishedDate": "2024-04-03T17:15Z", "lastModifiedDate": "2025-04-16T19:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-26759", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nmm/swap: fix race when skipping swapcache\n\nWhen skipping swapcache for SWP_SYNCHRONOUS_IO, if two or more threads\nswapin the same entry at the same time, they get different pages (A, B). \nBefore one thread (T0) finishes the swapin and installs page (A) to the\nPTE, another thread (T1) could finish swapin of page (B), swap_free the\nentry, then swap out the possibly modified page reusing the same entry. \nIt breaks the pte_same check in (T0) because PTE value is unchanged,\ncausing ABA problem.  Thread (T0) will install a stalled page (A) into the\nPTE and cause data corruption.\n\nOne possible callstack is like this:\n\nCPU0                                 CPU1\n----                                 ----\ndo_swap_page()                       do_swap_page() with same entry\n<direct swapin path>                 <direct swapin path>\n<alloc page A>                       <alloc page B>\nswap_read_folio() <- read to page A  swap_read_folio() <- read to page B\n<slow on later locks or interrupt>   <finished swapin first>\n...                                  set_pte_at()\n                                     swap_free() <- entry is free\n                                     <write to page B, now page A stalled>\n                                     <swap out page B to same swap entry>\npte_same() <- Check pass, PTE seems\n              unchanged, but page A\n              is stalled!\nswap_free() <- page B content lost!\nset_pte_at() <- staled page A installed!\n\nAnd besides, for ZRAM, swap_free() allows the swap device to discard the\nentry content, so even if page (B) is not modified, if swap_read_folio()\non CPU0 happens later than swap_free() on CPU1, it may also cause data\nloss.\n\nTo fix this, reuse swapcache_prepare which will pin the swap entry using\nthe cache flag, and allow only one thread to swap it in, also prevent any\nparallel code from putting the entry in the cache.  Release the pin after\nPT unlocked.\n\nRacers just loop and wait since it's a rare and very short event.  A\nschedule_timeout_uninterruptible(1) call is added to avoid repeated page\nfaults wasting too much CPU, causing livelock or adding too much noise to\nperf statistics.  A similar livelock issue was described in commit\n029c4628b2eb (\"mm: swap: get rid of livelock in swapin readahead\")\n\nReproducer:\n\nThis race issue can be triggered easily using a well constructed\nreproducer and patched brd (with a delay in read path) [1]:\n\nWith latest 6.8 mainline, race caused data loss can be observed easily:\n$ gcc -g -lpthread test-thread-swap-race.c && ./a.out\n  Polulating 32MB of memory region...\n  Keep swapping out...\n  Starting round 0...\n  Spawning 65536 workers...\n  32746 workers spawned, wait for done...\n  Round 0: Error on 0x5aa00, expected 32746, got 32743, 3 data loss!\n  Round 0: Error on 0x395200, expected 32746, got 32743, 3 data loss!\n  Round 0: Error on 0x3fd000, expected 32746, got 32737, 9 data loss!\n  Round 0 Failed, 15 data loss!\n\nThis reproducer spawns multiple threads sharing the same memory region\nusing a small swap device.  Every two threads updates mapped pages one by\none in opposite direction trying to create a race, with one dedicated\nthread keep swapping out the data out using madvise.\n\nThe reproducer created a reproduce rate of about once every 5 minutes, so\nthe race should be totally possible in production.\n\nAfter this patch, I ran the reproducer for over a few hundred rounds and\nno data loss observed.\n\nPerformance overhead is minimal, microbenchmark swapin 10G from 32G\nzram:\n\nBefore:     10934698 us\nAfter:      11157121 us\nCached:     13155355 us (Dropping SWP_SYNCHRONOUS_IO flag)\n\n[kasong@tencent.com: v4]"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: mm/swap: corrige la ejecuci\u00f3n al omitir swapcache Al omitir swapcache para SWP_SYNCHRONOUS_IO, si dos o m\u00e1s subprocesos intercambian la misma entrada al mismo tiempo, obtienen p\u00e1ginas diferentes (A, B) . Antes de que un subproceso (T0) finalice el intercambio e instale la p\u00e1gina (A) en el PTE, otro subproceso (T1) podr\u00eda finalizar el intercambio de la p\u00e1gina (B), liberar la entrada y luego intercambiar la p\u00e1gina posiblemente modificada reutilizando la misma entrada. Rompe el control pte_same (T0) porque el valor de PTE no cambia, lo que provoca un problema de ABA. El subproceso (T0) instalar\u00e1 una p\u00e1gina bloqueada (A) en el PTE y provocar\u00e1 da\u00f1os en los datos. Una posible pila de llamadas es as\u00ed: CPU0 CPU1 ---- ---- do_swap_page() do_swap_page() con la misma entrada     swap_read_folio() &lt; - leer en la p\u00e1gina A swap_read_folio() &lt;- leer en la p\u00e1gina B   ... set_pte_at() swap_free() &lt;- la entrada es libre   pte_same() &lt;- Verificar pase, PTE parece no haber cambiado, \u00a1pero la p\u00e1gina A est\u00e1 estancada! swap_free() &lt;- \u00a1Contenido de la p\u00e1gina B perdido! set_pte_at() &lt;- \u00a1p\u00e1gina A obsoleta instalada! Y adem\u00e1s, para ZRAM, swap_free() permite que el dispositivo de intercambio descarte el contenido de la entrada, por lo que incluso si la p\u00e1gina (B) no se modifica, si swap_read_folio() en CPU0 ocurre m\u00e1s tarde que swap_free() en CPU1, tambi\u00e9n puede causar que los datos p\u00e9rdida. Para solucionar este problema, reutilice swapcache_prepare, que fijar\u00e1 la entrada de intercambio usando el indicador de cach\u00e9 y permitir\u00e1 que solo un hilo la intercambie, y tambi\u00e9n evitar\u00e1 que cualquier c\u00f3digo paralelo coloque la entrada en el cach\u00e9. Suelte el pasador despu\u00e9s de desbloquear el PT. Los corredores simplemente dan vueltas y esperan, ya que es un evento raro y muy corto. Se agrega una llamada Schedule_timeout_uninterruptible(1) para evitar errores repetidos de p\u00e1gina que desperdician demasiada CPU, provocando bloqueos en vivo o agregando demasiado ruido a las estad\u00edsticas de rendimiento. Un problema similar de livelock se describi\u00f3 en el compromiso 029c4628b2eb (\"mm: swap: deshacerse de livelock en swapin readahead\") Reproductor: este problema de ejecuci\u00f3n se puede activar f\u00e1cilmente utilizando un reproductor bien construido y un brd parcheado (con un retraso en la ruta de lectura) [ 1]: Con la \u00faltima l\u00ednea principal 6.8, la p\u00e9rdida de datos causada por la ejecuci\u00f3n se puede observar f\u00e1cilmente: $ gcc -g -lpthread test-thread-swap-race.c &amp;&amp; ./a.out Contaminando 32 MB de regi\u00f3n de memoria... Siga intercambiando. .. Comenzando la ronda 0... Generando 65536 trabajadores... Se generaron 32746 trabajadores, espere a que termine... Ronda 0: Error en 0x5aa00, se esperaban 32746, obtuve 32743, \u00a13 p\u00e9rdida de datos! Ronda 0: Error en 0x395200, se esperaba 32746, obtuve 32743, \u00a13 p\u00e9rdida de datos! Ronda 0: Error en 0x3fd000, esperado 32746, obtuve 32737, \u00a19 p\u00e9rdida de datos! Ronda 0 fallida, \u00a115 p\u00e9rdida de datos! Este reproductor genera m\u00faltiples subprocesos que comparten la misma regi\u00f3n de memoria mediante un peque\u00f1o dispositivo de intercambio. Cada dos subprocesos actualiza las p\u00e1ginas asignadas una por una en direcci\u00f3n opuesta tratando de crear una ejecuci\u00f3n, con un subproceso dedicado sigue intercambiando los datos usando madvise. El reproductor cre\u00f3 una tasa de reproducci\u00f3n de aproximadamente una vez cada 5 minutos, por lo que la ejecuci\u00f3n deber\u00eda ser totalmente posible en producci\u00f3n. Despu\u00e9s de este parche, ejecut\u00e9 el reproductor durante m\u00e1s de unos cientos de rondas y no se observ\u00f3 p\u00e9rdida de datos. ---truncado---"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/13ddaf26be324a7f951891ecd9ccd04466d27458", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/2dedda77d4493f3e92e414b272bfa60f1f51ed95", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/305152314df82b22cf9b181f3dc5fc411002079a", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/d183a4631acfc7af955c02a02e739cec15f5234d", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/13ddaf26be324a7f951891ecd9ccd04466d27458", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/2dedda77d4493f3e92e414b272bfa60f1f51ed95", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/305152314df82b22cf9b181f3dc5fc411002079a", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/d183a4631acfc7af955c02a02e739cec15f5234d", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "CWE-787"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 3.6, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "baseScore": 5.5, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "1D4BFAE6-78E1-4617-99B6-12994681E95C", "cpe_name": [], "versionStartIncluding": "4.15", "versionEndExcluding": "6.1.80"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "8D82004C-B2AE-4048-9344-32EFF65953B0", "cpe_name": [], "versionStartIncluding": "6.2", "versionEndExcluding": "6.6.19"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "575EE16B-67F2-4B5B-B5F8-1877715C898B", "cpe_name": [], "versionStartIncluding": "6.7", "versionEndExcluding": "6.7.7"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.8:rc1:*:*:*:*:*:*", "matchCriteriaId": "B9F4EA73-0894-400F-A490-3A397AB7A517", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.8:rc2:*:*:*:*:*:*", "matchCriteriaId": "056BD938-0A27-4569-B391-30578B309EE3", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.8:rc3:*:*:*:*:*:*", "matchCriteriaId": "F02056A5-B362-4370-9FF8-6F0BD384D520", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.8:rc4:*:*:*:*:*:*", "matchCriteriaId": "62075ACE-B2A0-4B16-829D-B3DA5AE5CC41", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.8:rc5:*:*:*:*:*:*", "matchCriteriaId": "A780F817-2A77-4130-A9B7-5C25606314E3", "cpe_name": []}]}]}}