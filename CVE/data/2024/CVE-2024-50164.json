{"publishedDate": "2024-11-07T10:15Z", "lastModifiedDate": "2025-01-17T14:15Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-50164", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix overloading of MEM_UNINIT's meaning\n\nLonial reported an issue in the BPF verifier where check_mem_size_reg()\nhas the following code:\n\n    if (!tnum_is_const(reg->var_off))\n        /* For unprivileged variable accesses, disable raw\n         * mode so that the program is required to\n         * initialize all the memory that the helper could\n         * just partially fill up.\n         */\n         meta = NULL;\n\nThis means that writes are not checked when the register containing the\nsize of the passed buffer has not a fixed size. Through this bug, a BPF\nprogram can write to a map which is marked as read-only, for example,\n.rodata global maps.\n\nThe problem is that MEM_UNINIT's initial meaning that \"the passed buffer\nto the BPF helper does not need to be initialized\" which was added back\nin commit 435faee1aae9 (\"bpf, verifier: add ARG_PTR_TO_RAW_STACK type\")\ngot overloaded over time with \"the passed buffer is being written to\".\n\nThe problem however is that checks such as the above which were added later\nvia 06c1c049721a (\"bpf: allow helpers access to variable memory\") set meta\nto NULL in order force the user to always initialize the passed buffer to\nthe helper. Due to the current double meaning of MEM_UNINIT, this bypasses\nverifier write checks to the memory (not boundary checks though) and only\nassumes the latter memory is read instead.\n\nFix this by reverting MEM_UNINIT back to its original meaning, and having\nMEM_WRITE as an annotation to BPF helpers in order to then trigger the\nBPF verifier checks for writing to memory.\n\nSome notes: check_arg_pair_ok() ensures that for ARG_CONST_SIZE{,_OR_ZERO}\nwe can access fn->arg_type[arg - 1] since it must contain a preceding\nARG_PTR_TO_MEM. For check_mem_reg() the meta argument can be removed\naltogether since we do check both BPF_READ and BPF_WRITE. Same for the\nequivalent check_kfunc_mem_size_reg()."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: bpf: Se corrige la sobrecarga del significado de MEM_UNINIT Lonial inform\u00f3 de un problema en el verificador BPF donde check_mem_size_reg() tiene el siguiente c\u00f3digo: if (!tnum_is_const(reg-&gt;var_off)) /* Para accesos a variables sin privilegios, deshabilitar el modo sin formato * para que el programa deba * inicializar toda la memoria que el ayudante podr\u00eda * llenar parcialmente. */ meta = NULL; Esto significa que las escrituras no se verifican cuando el registro que contiene el tama\u00f1o del b\u00fafer pasado no tiene un tama\u00f1o fijo. A trav\u00e9s de este error, un programa BPF puede escribir en un mapa que est\u00e1 marcado como de solo lectura, por ejemplo, mapas globales .rodata. El problema es que el significado inicial de MEM_UNINIT de que \"el buffer pasado al ayudante BPF no necesita ser inicializado\" que se agreg\u00f3 en el commit 435faee1aae9 (\"bpf, verificador: agregar tipo ARG_PTR_TO_RAW_STACK\") se sobrecarg\u00f3 con el tiempo con \"se est\u00e1 escribiendo en el b\u00fafer pasado\". Sin embargo, el problema es que las comprobaciones como la anterior que se agregaron m\u00e1s tarde a trav\u00e9s de 06c1c049721a (\"bpf: permitir que los ayudantes accedan a la memoria variable\") establecen meta en NULL para obligar al usuario a inicializar siempre el b\u00fafer pasado al ayudante. Debido al doble significado actual de MEM_UNINIT, esto omite las comprobaciones de escritura del verificador en la memoria (aunque no las comprobaciones de los l\u00edmites) y solo supone que se lee la \u00faltima memoria en su lugar. Solucione esto revirtiendo MEM_UNINIT a su significado original y haciendo que MEM_WRITE sea una anotaci\u00f3n para los ayudantes de BPF para luego activar las comprobaciones del verificador de BPF para escribir en la memoria. Algunas notas: check_arg_pair_ok() garantiza que para ARG_CONST_SIZE{,_OR_ZERO} podamos acceder a fn-&gt;arg_type[arg - 1] ya que debe contener un ARG_PTR_TO_MEM anterior. Para check_mem_reg(), el argumento meta se puede eliminar por completo ya que verificamos tanto BPF_READ como BPF_WRITE. Lo mismo para el check_kfunc_mem_size_reg() equivalente."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/43f4df339a4d375bedcad29a61ae6f0ee7a048f8", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/48068ccaea957469f1adf78dfd2c1c9a7e18f0fe", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/54bc31682660810af1bed7ca7a19f182df8d3df8", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/8ea607330a39184f51737c6ae706db7fdca7628e", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.8, "impactScore": 5.2, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:H", "baseScore": 7.1, "baseSeverity": "HIGH", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "3999723A-DFD7-4A89-B758-A330ECB89F4E", "cpe_name": [], "versionStartIncluding": "5.19", "versionEndExcluding": "6.6.59"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "E4486B12-007B-4794-9857-F07145637AA1", "cpe_name": [], "versionStartIncluding": "6.7", "versionEndExcluding": "6.11.6"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.12:rc1:*:*:*:*:*:*", "matchCriteriaId": "7F361E1D-580F-4A2D-A509-7615F73167A1", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.12:rc2:*:*:*:*:*:*", "matchCriteriaId": "925478D0-3E3D-4E6F-ACD5-09F28D5DF82C", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.12:rc3:*:*:*:*:*:*", "matchCriteriaId": "3C95E234-D335-4B6C-96BF-E2CEBD8654ED", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.12:rc4:*:*:*:*:*:*", "matchCriteriaId": "E0F717D8-3014-4F84-8086-0124B2111379", "cpe_name": []}]}]}}