{"publishedDate": "2024-07-12T13:15Z", "lastModifiedDate": "2025-09-17T15:37Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-40918", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nparisc: Try to fix random segmentation faults in package builds\n\nPA-RISC systems with PA8800 and PA8900 processors have had problems\nwith random segmentation faults for many years.  Systems with earlier\nprocessors are much more stable.\n\nSystems with PA8800 and PA8900 processors have a large L2 cache which\nneeds per page flushing for decent performance when a large range is\nflushed. The combined cache in these systems is also more sensitive to\nnon-equivalent aliases than the caches in earlier systems.\n\nThe majority of random segmentation faults that I have looked at\nappear to be memory corruption in memory allocated using mmap and\nmalloc.\n\nMy first attempt at fixing the random faults didn't work. On\nreviewing the cache code, I realized that there were two issues\nwhich the existing code didn't handle correctly. Both relate\nto cache move-in. Another issue is that the present bit in PTEs\nis racy.\n\n1) PA-RISC caches have a mind of their own and they can speculatively\nload data and instructions for a page as long as there is a entry in\nthe TLB for the page which allows move-in. TLBs are local to each\nCPU. Thus, the TLB entry for a page must be purged before flushing\nthe page. This is particularly important on SMP systems.\n\nIn some of the flush routines, the flush routine would be called\nand then the TLB entry would be purged. This was because the flush\nroutine needed the TLB entry to do the flush.\n\n2) My initial approach to trying the fix the random faults was to\ntry and use flush_cache_page_if_present for all flush operations.\nThis actually made things worse and led to a couple of hardware\nlockups. It finally dawned on me that some lines weren't being\nflushed because the pte check code was racy. This resulted in\nrandom inequivalent mappings to physical pages.\n\nThe __flush_cache_page tmpalias flush sets up its own TLB entry\nand it doesn't need the existing TLB entry. As long as we can find\nthe pte pointer for the vm page, we can get the pfn and physical\naddress of the page. We can also purge the TLB entry for the page\nbefore doing the flush. Further, __flush_cache_page uses a special\nTLB entry that inhibits cache move-in.\n\nWhen switching page mappings, we need to ensure that lines are\nremoved from the cache.  It is not sufficient to just flush the\nlines to memory as they may come back.\n\nThis made it clear that we needed to implement all the required\nflush operations using tmpalias routines. This includes flushes\nfor user and kernel pages.\n\nAfter modifying the code to use tmpalias flushes, it became clear\nthat the random segmentation faults were not fully resolved. The\nfrequency of faults was worse on systems with a 64 MB L2 (PA8900)\nand systems with more CPUs (rp4440).\n\nThe warning that I added to flush_cache_page_if_present to detect\npages that couldn't be flushed triggered frequently on some systems.\n\nHelge and I looked at the pages that couldn't be flushed and found\nthat the PTE was either cleared or for a swap page. Ignoring pages\nthat were swapped out seemed okay but pages with cleared PTEs seemed\nproblematic.\n\nI looked at routines related to pte_clear and noticed ptep_clear_flush.\nThe default implementation just flushes the TLB entry. However, it was\nobvious that on parisc we need to flush the cache page as well. If\nwe don't flush the cache page, stale lines will be left in the cache\nand cause random corruption. Once a PTE is cleared, there is no way\nto find the physical address associated with the PTE and flush the\nassociated page at a later time.\n\nI implemented an updated change with a parisc specific version of\nptep_clear_flush. It fixed the random data corruption on Helge's rp4440\nand rp3440, as well as on my c8000.\n\nAt this point, I realized that I could restore the code where we only\nflush in flush_cache_page_if_present if the page has been accessed.\nHowever, for this, we also need to flush the cache when the accessed\nbit is cleared in\n---truncated---"}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: parisc: intenta corregir fallas de segmentaci\u00f3n aleatoria en compilaciones de paquetes. Los sistemas PA-RISC con procesadores PA8800 y PA8900 han tenido problemas con fallas de segmentaci\u00f3n aleatoria durante muchos a\u00f1os. Los sistemas con procesadores anteriores son mucho m\u00e1s estables. Los sistemas con procesadores PA8800 y PA8900 tienen una gran cach\u00e9 L2 que necesita un vaciado por p\u00e1gina para un rendimiento decente cuando se vac\u00eda un rango grande. La cach\u00e9 combinada en estos sistemas tambi\u00e9n es m\u00e1s sensible a alias no equivalentes que las cach\u00e9s de sistemas anteriores. La mayor\u00eda de los fallos de segmentaci\u00f3n aleatoria que he observado parecen ser da\u00f1os en la memoria asignada mediante mmap y malloc. Mi primer intento de solucionar los fallos aleatorios no funcion\u00f3. Al revisar el c\u00f3digo de cach\u00e9, me di cuenta de que hab\u00eda dos problemas que el c\u00f3digo existente no manejaba correctamente. Ambos se relacionan con la entrada de cach\u00e9. Otro problema es que la actualidad en las PTE es picante. 1) Los cach\u00e9s PA-RISC tienen mente propia y pueden cargar especulativamente datos e instrucciones para una p\u00e1gina siempre que haya una entrada en el TLB para la p\u00e1gina que permita la entrada. Los TLB son locales para cada CPU. Por lo tanto, la entrada TLB de una p\u00e1gina debe eliminarse antes de eliminarla. Esto es particularmente importante en los sistemas SMP. En algunas de las rutinas de vaciado, se llamar\u00eda a la rutina de vaciado y luego se purgar\u00eda la entrada TLB. Esto se deb\u00eda a que la rutina de lavado necesitaba la entrada TLB para realizar el lavado. 2) Mi enfoque inicial para intentar solucionar las fallas aleatorias fue intentar usar Flush_cache_page_if_present para todas las operaciones de descarga. En realidad, esto empeor\u00f3 las cosas y provoc\u00f3 un par de bloqueos de hardware. Finalmente me di cuenta de que algunas l\u00edneas no se estaban borrando porque el c\u00f3digo de verificaci\u00f3n del pte era picante. Esto result\u00f3 en asignaciones aleatorias no equivalentes a p\u00e1ginas f\u00edsicas. La descarga tmpalias __flush_cache_page configura su propia entrada TLB y no necesita la entrada TLB existente. Siempre que podamos encontrar el puntero pte de la p\u00e1gina vm, podemos obtener el pfn y la direcci\u00f3n f\u00edsica de la p\u00e1gina. Tambi\u00e9n podemos purgar la entrada TLB de la p\u00e1gina antes de realizar el vaciado. Adem\u00e1s, __flush_cache_page utiliza una entrada TLB especial que inhibe la entrada de cach\u00e9. Al cambiar las asignaciones de p\u00e1ginas, debemos asegurarnos de que las l\u00edneas se eliminen del cach\u00e9. No es suficiente simplemente borrar las l\u00edneas de la memoria, ya que pueden volver. Esto dej\u00f3 en claro que necesit\u00e1bamos implementar todas las operaciones de vaciado necesarias utilizando rutinas tmpalias. Esto incluye vaciados para p\u00e1ginas de usuario y de kernel. Despu\u00e9s de modificar el c\u00f3digo para usar tmpalias vaciados, qued\u00f3 claro que los errores de segmentaci\u00f3n aleatoria no se resolvieron por completo. La frecuencia de fallas fue peor en sistemas con 64 MB L2 (PA8900) y sistemas con m\u00e1s CPU (rp4440). La advertencia que agregu\u00e9 a Flush_cache_page_if_present para detectar p\u00e1ginas que no se pod\u00edan vaciar se activaba con frecuencia en algunos sistemas. Helge y yo miramos las p\u00e1ginas que no se pod\u00edan vaciar y descubrimos que la PTE estaba vac\u00eda o era una p\u00e1gina de intercambio. Ignorar las p\u00e1ginas que se intercambiaron parec\u00eda estar bien, pero las p\u00e1ginas con PTE borradas parec\u00edan problem\u00e1ticas. Mir\u00e9 rutinas relacionadas con pte_clear y not\u00e9 ptep_clear_flush. La implementaci\u00f3n predeterminada simplemente vac\u00eda la entrada TLB. Sin embargo, era obvio que en Par\u00eds tambi\u00e9n necesitamos vaciar la p\u00e1gina de cach\u00e9. Si no limpiamos la p\u00e1gina de cach\u00e9, quedar\u00e1n l\u00edneas obsoletas en la cach\u00e9 y provocar\u00e1n da\u00f1os aleatorios. Una vez que se borra una PTE, no hay forma de encontrar la direcci\u00f3n f\u00edsica asociada con la PTE y borrar la p\u00e1gina asociada m\u00e1s adelante.  ---truncado---"}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/5bf196f1936bf93df31112fbdfb78c03537c07b0", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/72d95924ee35c8cd16ef52f912483ee938a34d49", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/d66f2607d89f760cdffed88b22f309c895a2af20", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/5bf196f1936bf93df31112fbdfb78c03537c07b0", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/72d95924ee35c8cd16ef52f912483ee938a34d49", "name": "", "refsource": "", "tags": ["Patch"]}, {"url": "https://git.kernel.org/stable/c/d66f2607d89f760cdffed88b22f309c895a2af20", "name": "", "refsource": "", "tags": ["Patch"]}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {"baseMetricV3": {"exploitabilityScore": 1.0, "impactScore": 5.2, "cvssV3": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:H/A:H", "baseScore": 6.3, "baseSeverity": "MEDIUM", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "HIGH"}}}, "configurations": {"CVE_data_version": "4.0", "nodes": [{"operator": "OR", "negate": false, "children": [], "cpe_match": [{"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "D8F520E1-506C-47D4-A31B-142545B8B199", "cpe_name": [], "versionEndExcluding": "6.6.35"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "matchCriteriaId": "0ABBBA1D-F79D-4BDB-AA41-D1EDCC4A6975", "cpe_name": [], "versionStartIncluding": "6.7", "versionEndExcluding": "6.9.6"}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "2EBB4392-5FA6-4DA9-9772-8F9C750109FA", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.10:rc2:*:*:*:*:*:*", "matchCriteriaId": "331C2F14-12C7-45D5-893D-8C52EE38EA10", "cpe_name": []}, {"vulnerable": true, "cpe23Uri": "cpe:2.3:o:linux:linux_kernel:6.10:rc3:*:*:*:*:*:*", "matchCriteriaId": "3173713D-909A-4DD3-9DD4-1E171EB057EE", "cpe_name": []}]}]}}