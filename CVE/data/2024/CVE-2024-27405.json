{"cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "4.0", "CVE_data_meta": {"ID": "CVE-2024-27405", "ASSIGNER": "cve@kernel.org"}, "problemtype": {"problemtype_data": [{"description": []}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/059285e04ebb273d32323fbad5431c5b94f77e48", "name": "https://git.kernel.org/stable/c/059285e04ebb273d32323fbad5431c5b94f77e48", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/059285e04ebb273d32323fbad5431c5b94f77e48", "name": "https://git.kernel.org/stable/c/059285e04ebb273d32323fbad5431c5b94f77e48", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/2b7ec68869d50ea998908af43b643bca7e54577e", "name": "https://git.kernel.org/stable/c/2b7ec68869d50ea998908af43b643bca7e54577e", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/2b7ec68869d50ea998908af43b643bca7e54577e", "name": "https://git.kernel.org/stable/c/2b7ec68869d50ea998908af43b643bca7e54577e", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/2cb66b62a5d64ccf09b0591ab86fb085fa491fc5", "name": "https://git.kernel.org/stable/c/2cb66b62a5d64ccf09b0591ab86fb085fa491fc5", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/2cb66b62a5d64ccf09b0591ab86fb085fa491fc5", "name": "https://git.kernel.org/stable/c/2cb66b62a5d64ccf09b0591ab86fb085fa491fc5", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/35b604a37ec70d68b19dafd10bbacf1db505c9ca", "name": "https://git.kernel.org/stable/c/35b604a37ec70d68b19dafd10bbacf1db505c9ca", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/35b604a37ec70d68b19dafd10bbacf1db505c9ca", "name": "https://git.kernel.org/stable/c/35b604a37ec70d68b19dafd10bbacf1db505c9ca", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/57ca0e16f393bb21d69734e536e383a3a4c665fd", "name": "https://git.kernel.org/stable/c/57ca0e16f393bb21d69734e536e383a3a4c665fd", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/57ca0e16f393bb21d69734e536e383a3a4c665fd", "name": "https://git.kernel.org/stable/c/57ca0e16f393bb21d69734e536e383a3a4c665fd", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/76c51146820c5dac629f21deafab0a7039bc3ccd", "name": "https://git.kernel.org/stable/c/76c51146820c5dac629f21deafab0a7039bc3ccd", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/76c51146820c5dac629f21deafab0a7039bc3ccd", "name": "https://git.kernel.org/stable/c/76c51146820c5dac629f21deafab0a7039bc3ccd", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/a31cf46d108dabce3df80b3e5c07661e24912151", "name": "https://git.kernel.org/stable/c/a31cf46d108dabce3df80b3e5c07661e24912151", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/a31cf46d108dabce3df80b3e5c07661e24912151", "name": "https://git.kernel.org/stable/c/a31cf46d108dabce3df80b3e5c07661e24912151", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/c7f43900bc723203d7554d299a2ce844054fab8e", "name": "https://git.kernel.org/stable/c/c7f43900bc723203d7554d299a2ce844054fab8e", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/c7f43900bc723203d7554d299a2ce844054fab8e", "name": "https://git.kernel.org/stable/c/c7f43900bc723203d7554d299a2ce844054fab8e", "refsource": "", "tags": []}, {"url": "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html", "name": "https://lists.debian.org/debian-lts-announce/2024/06/msg00017.html", "refsource": "", "tags": []}, {"url": "https://lists.debian.org/debian-lts-announce/2024/06/msg00020.html", "name": "https://lists.debian.org/debian-lts-announce/2024/06/msg00020.html", "refsource": "", "tags": []}]}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nusb: gadget: ncm: Avoid dropping datagrams of properly parsed NTBs\n\nIt is observed sometimes when tethering is used over NCM with Windows 11\nas host, at some instances, the gadget_giveback has one byte appended at\nthe end of a proper NTB. When the NTB is parsed, unwrap call looks for\nany leftover bytes in SKB provided by u_ether and if there are any pending\nbytes, it treats them as a separate NTB and parses it. But in case the\nsecond NTB (as per unwrap call) is faulty/corrupt, all the datagrams that\nwere parsed properly in the first NTB and saved in rx_list are dropped.\n\nAdding a few custom traces showed the following:\n[002] d..1  7828.532866: dwc3_gadget_giveback: ep1out:\nreq 000000003868811a length 1025/16384 zsI ==> 0\n[002] d..1  7828.532867: ncm_unwrap_ntb: K: ncm_unwrap_ntb toprocess: 1025\n[002] d..1  7828.532867: ncm_unwrap_ntb: K: ncm_unwrap_ntb nth: 1751999342\n[002] d..1  7828.532868: ncm_unwrap_ntb: K: ncm_unwrap_ntb seq: 0xce67\n[002] d..1  7828.532868: ncm_unwrap_ntb: K: ncm_unwrap_ntb blk_len: 0x400\n[002] d..1  7828.532868: ncm_unwrap_ntb: K: ncm_unwrap_ntb ndp_len: 0x10\n[002] d..1  7828.532869: ncm_unwrap_ntb: K: Parsed NTB with 1 frames\n\nIn this case, the giveback is of 1025 bytes and block length is 1024.\nThe rest 1 byte (which is 0x00) won't be parsed resulting in drop of\nall datagrams in rx_list.\n\nSame is case with packets of size 2048:\n[002] d..1  7828.557948: dwc3_gadget_giveback: ep1out:\nreq 0000000011dfd96e length 2049/16384 zsI ==> 0\n[002] d..1  7828.557949: ncm_unwrap_ntb: K: ncm_unwrap_ntb nth: 1751999342\n[002] d..1  7828.557950: ncm_unwrap_ntb: K: ncm_unwrap_ntb blk_len: 0x800\n\nLecroy shows one byte coming in extra confirming that the byte is coming\nin from PC:\n\n Transfer 2959 - Bytes Transferred(1025)  Timestamp((18.524 843 590)\n - Transaction 8391 - Data(1025 bytes) Timestamp(18.524 843 590)\n --- Packet 4063861\n       Data(1024 bytes)\n       Duration(2.117us) Idle(14.700ns) Timestamp(18.524 843 590)\n --- Packet 4063863\n       Data(1 byte)\n       Duration(66.160ns) Time(282.000ns) Timestamp(18.524 845 722)\n\nAccording to Windows driver, no ZLP is needed if wBlockLength is non-zero,\nbecause the non-zero wBlockLength has already told the function side the\nsize of transfer to be expected. However, there are in-market NCM devices\nthat rely on ZLP as long as the wBlockLength is multiple of wMaxPacketSize.\nTo deal with such devices, it pads an extra 0 at end so the transfer is no\nlonger multiple of wMaxPacketSize."}]}}, "configurations": {"CVE_data_version": "4.0", "nodes": []}, "impact": {}, "publishedDate": "2024-05-17T12:15Z", "lastModifiedDate": "2024-11-21T09:04Z"}