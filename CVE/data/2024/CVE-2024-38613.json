{"publishedDate": "2024-06-19T14:15Z", "lastModifiedDate": "2024-11-21T09:26Z", "cve": {"data_type": "CVE", "data_format": "MITRE", "data_version": "1.0", "CVE_data_meta": {"ID": "CVE-2024-38613", "ASSIGNER": "416baaa9-dc9f-4396-8d5f-8c081fb06d67"}, "description": {"description_data": [{"lang": "en", "value": "In the Linux kernel, the following vulnerability has been resolved:\n\nm68k: Fix spinlock race in kernel thread creation\n\nContext switching does take care to retain the correct lock owner across\nthe switch from 'prev' to 'next' tasks.  This does rely on interrupts\nremaining disabled for the entire duration of the switch.\n\nThis condition is guaranteed for normal process creation and context\nswitching between already running processes, because both 'prev' and\n'next' already have interrupts disabled in their saved copies of the\nstatus register.\n\nThe situation is different for newly created kernel threads.  The status\nregister is set to PS_S in copy_thread(), which does leave the IPL at 0.\nUpon restoring the 'next' thread's status register in switch_to() aka\nresume(), interrupts then become enabled prematurely.  resume() then\nreturns via ret_from_kernel_thread() and schedule_tail() where run queue\nlock is released (see finish_task_switch() and finish_lock_switch()).\n\nA timer interrupt calling scheduler_tick() before the lock is released\nin finish_task_switch() will find the lock already taken, with the\ncurrent task as lock owner.  This causes a spinlock recursion warning as\nreported by Guenter Roeck.\n\nAs far as I can ascertain, this race has been opened in commit\n533e6903bea0 (\"m68k: split ret_from_fork(), simplify kernel_thread()\")\nbut I haven't done a detailed study of kernel history so it may well\npredate that commit.\n\nInterrupts cannot be disabled in the saved status register copy for\nkernel threads (init will complain about interrupts disabled when\nfinally starting user space).  Disable interrupts temporarily when\nswitching the tasks' register sets in resume().\n\nNote that a simple oriw 0x700,%sr after restoring sr is not enough here\n- this leaves enough of a race for the 'spinlock recursion' warning to\nstill be observed.\n\nTested on ARAnyM and qemu (Quadra 800 emulation)."}, {"lang": "es", "value": "En el kernel de Linux, se ha resuelto la siguiente vulnerabilidad: m68k: corrige la ejecuci\u00f3n de bloqueo de giro en la creaci\u00f3n de subprocesos del kernel. El cambio de contexto se encarga de retener el propietario del bloqueo correcto durante el cambio de las tareas 'anteriores' a las 'siguientes'. Esto depende de que las interrupciones permanezcan deshabilitadas durante toda la duraci\u00f3n del cambio. Esta condici\u00f3n est\u00e1 garantizada para la creaci\u00f3n normal de procesos y el cambio de contexto entre procesos que ya se est\u00e1n ejecutando, porque tanto 'anterior' como 'siguiente' ya tienen las interrupciones deshabilitadas en sus copias guardadas del registro de estado. La situaci\u00f3n es diferente para los subprocesos del kernel reci\u00e9n creados. El registro de estado se establece en PS_S en copy_thread(), lo que deja la IPL en 0. Al restaurar el registro de estado del 'siguiente' subproceso en switch_to() tambi\u00e9n conocido como resume(), las interrupciones se habilitan prematuramente. resume() luego regresa a trav\u00e9s de ret_from_kernel_thread() y Schedule_tail() donde se libera el bloqueo de la cola de ejecuci\u00f3n (consulte Finish_task_switch() y Finish_lock_switch()). Una interrupci\u00f3n del temporizador que llama a Scheduler_tick() antes de que se libere el bloqueo en Finish_task_switch() encontrar\u00e1 el bloqueo ya tomado, con la tarea actual como propietario del bloqueo. Esto provoca una advertencia de recursividad de spinlock seg\u00fan lo informado por Guenter Roeck. Hasta donde puedo determinar, esta ejecuci\u00f3n se abri\u00f3 en el commit 533e6903bea0 (\"m68k: split ret_from_fork(), simplifica kernel_thread()\") pero no he realizado un estudio detallado de la historia del kernel, por lo que es posible que sea anterior a esa confirmaci\u00f3n. Las interrupciones no se pueden deshabilitar en la copia del registro de estado guardado para los subprocesos del kernel (init se quejar\u00e1 de las interrupciones deshabilitadas cuando finalmente inicie el espacio de usuario). Deshabilite las interrupciones temporalmente al cambiar los conjuntos de registros de tareas en resume(). Tenga en cuenta que un simple oriw 0x700,%sr despu\u00e9s de restaurar sr no es suficiente aqu\u00ed; esto deja suficiente ejecuci\u00f3n para que a\u00fan se observe la advertencia de 'recursi\u00f3n de spinlock'. Probado en ARAnyM y qemu (emulaci\u00f3n Quadra 800)."}]}, "references": {"reference_data": [{"url": "https://git.kernel.org/stable/c/0d9ae1253535f6e85a016e09c25ecbe6f7f59ef0", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/2a8d1d95302c7d52c6ac8fa5cb4a6948ae0d3a14", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/4eeffecc8e3cce25bb559502c2fd94a948bcde82", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/5213cc01d0464c011fdc09f318705603ed3a746b", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/77b2b67a0f8bce260c53907e5749d61466d90c87", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/95f00caf767b5968c2c51083957b38be4748a78a", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/da89ce46f02470ef08f0f580755d14d547da59ed", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f1d4274a84c069be0f6098ab10c3443fc1f7134c", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f3baf0f4f92af32943ebf27b960e0552c6c082fd", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/0d9ae1253535f6e85a016e09c25ecbe6f7f59ef0", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/2a8d1d95302c7d52c6ac8fa5cb4a6948ae0d3a14", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/4eeffecc8e3cce25bb559502c2fd94a948bcde82", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/5213cc01d0464c011fdc09f318705603ed3a746b", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/77b2b67a0f8bce260c53907e5749d61466d90c87", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/95f00caf767b5968c2c51083957b38be4748a78a", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/da89ce46f02470ef08f0f580755d14d547da59ed", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f1d4274a84c069be0f6098ab10c3443fc1f7134c", "name": "", "refsource": "", "tags": []}, {"url": "https://git.kernel.org/stable/c/f3baf0f4f92af32943ebf27b960e0552c6c082fd", "name": "", "refsource": "", "tags": []}]}, "problemtype": {"problemtype_data": [{"description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}]}}, "impact": {}, "configurations": {"CVE_data_version": "4.0", "nodes": []}}