{"id": "EUVD-2023-59837", "enisaUuid": "61ec94e3-0c1b-30db-b931-c03595e8158d", "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: set_page_extent_mapped after read_folio in btrfs_cont_expand\n\nWhile trying to get the subpage blocksize tests running, I hit the\nfollowing panic on generic/476\n\n  assertion failed: PagePrivate(page) && page->private, in fs/btrfs/subpage.c:229\n  kernel BUG at fs/btrfs/subpage.c:229!\n  Internal error: Oops - BUG: 00000000f2000800 [#1] SMP\n  CPU: 1 PID: 1453 Comm: fsstress Not tainted 6.4.0-rc7+ #12\n  Hardware name: QEMU KVM Virtual Machine, BIOS edk2-20230301gitf80f052277c8-26.fc38 03/01/2023\n  pstate: 61400005 (nZCv daif +PAN -UAO -TCO +DIT -SSBS BTYPE=--)\n  pc : btrfs_subpage_assert+0xbc/0xf0\n  lr : btrfs_subpage_assert+0xbc/0xf0\n  Call trace:\n   btrfs_subpage_assert+0xbc/0xf0\n   btrfs_subpage_clear_checked+0x38/0xc0\n   btrfs_page_clear_checked+0x48/0x98\n   btrfs_truncate_block+0x5d0/0x6a8\n   btrfs_cont_expand+0x5c/0x528\n   btrfs_write_check.isra.0+0xf8/0x150\n   btrfs_buffered_write+0xb4/0x760\n   btrfs_do_write_iter+0x2f8/0x4b0\n   btrfs_file_write_iter+0x1c/0x30\n   do_iter_readv_writev+0xc8/0x158\n   do_iter_write+0x9c/0x210\n   vfs_iter_write+0x24/0x40\n   iter_file_splice_write+0x224/0x390\n   direct_splice_actor+0x38/0x68\n   splice_direct_to_actor+0x12c/0x260\n   do_splice_direct+0x90/0xe8\n   generic_copy_file_range+0x50/0x90\n   vfs_copy_file_range+0x29c/0x470\n   __arm64_sys_copy_file_range+0xcc/0x498\n   invoke_syscall.constprop.0+0x80/0xd8\n   do_el0_svc+0x6c/0x168\n   el0_svc+0x50/0x1b0\n   el0t_64_sync_handler+0x114/0x120\n   el0t_64_sync+0x194/0x198\n\nThis happens because during btrfs_cont_expand we'll get a page, set it\nas mapped, and if it's not Uptodate we'll read it.  However between the\nread and re-locking the page we could have called release_folio() on the\npage, but left the page in the file mapping.  release_folio() can clear\nthe page private, and thus further down we blow up when we go to modify\nthe subpage bits.\n\nFix this by putting the set_page_extent_mapped() after the read.  This\nis safe because read_folio() will call set_page_extent_mapped() before\nit does the read, and then if we clear page private but leave it on the\nmapping we're completely safe re-setting set_page_extent_mapped().  With\nthis patch I can now run generic/476 without panicing.", "datePublished": "2025-09-15T15:31:29", "dateUpdated": "2025-12-03T21:31:00", "baseScore": 0.0, "references": ["https://git.kernel.org/stable/c/0a5e0bc8e8618e32a6ca64450867628eb0a627bf", "https://git.kernel.org/stable/c/a5880e69cf7fe4a0bb1eabae02205352d1b59b7b", "https://git.kernel.org/stable/c/17b17fcd6d446b95904a6929c40012ee7f0afc0c", "https://nvd.nist.gov/vuln/detail/CVE-2023-53247"], "aliases": ["CVE-2023-53247"], "assigner": "Linux", "epss": 0.02, "enisaIdProduct": [{"id": "01bd93e5-954d-3adb-a690-dbff4fbddd76", "product": {"name": "Linux"}, "product_version": "patch: 6.4.7"}, {"id": "1b1e262e-ece3-3a1d-a1a4-6dacb6d70b1f", "product": {"name": "Linux"}, "product_version": "patch: 6.1.42"}, {"id": "8010d91a-52fb-3668-9562-906682bd7b64", "product": {"name": "Linux"}, "product_version": "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2 <17b17fcd6d446b95904a6929c40012ee7f0afc0c"}, {"id": "ab83dbbe-bcf2-343a-98b6-820e029a8dc3", "product": {"name": "Linux"}, "product_version": "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2 <a5880e69cf7fe4a0bb1eabae02205352d1b59b7b"}, {"id": "d09eeda1-089f-3d28-8e5a-507823b9f640", "product": {"name": "Linux"}, "product_version": "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2 <0a5e0bc8e8618e32a6ca64450867628eb0a627bf"}, {"id": "f1b8f196-3f71-3ed7-adf8-5c244d4ea968", "product": {"name": "Linux"}, "product_version": "patch: 6.5"}], "enisaIdVendor": [{"id": "09e93e2c-4582-31a1-8b9e-d66d89e50d86", "vendor": {"name": "Linux"}}], "isExploited": false}