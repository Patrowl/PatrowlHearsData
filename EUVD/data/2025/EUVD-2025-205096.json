{"id": "EUVD-2025-205096", "enisaUuid": "725cbfdb-c229-3266-93f2-89738b31aa77", "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbtrfs: fix racy bitfield write in btrfs_clear_space_info_full()\n\nFrom the memory-barriers.txt document regarding memory barrier ordering\nguarantees:\n\n (*) These guarantees do not apply to bitfields, because compilers often\n     generate code to modify these using non-atomic read-modify-write\n     sequences.  Do not attempt to use bitfields to synchronize parallel\n     algorithms.\n\n (*) Even in cases where bitfields are protected by locks, all fields\n     in a given bitfield must be protected by one lock.  If two fields\n     in a given bitfield are protected by different locks, the compiler's\n     non-atomic read-modify-write sequences can cause an update to one\n     field to corrupt the value of an adjacent field.\n\nbtrfs_space_info has a bitfield sharing an underlying word consisting of\nthe fields full, chunk_alloc, and flush:\n\nstruct btrfs_space_info {\n        struct btrfs_fs_info *     fs_info;              /*     0     8 */\n        struct btrfs_space_info *  parent;               /*     8     8 */\n        ...\n        int                        clamp;                /*   172     4 */\n        unsigned int               full:1;               /*   176: 0  4 */\n        unsigned int               chunk_alloc:1;        /*   176: 1  4 */\n        unsigned int               flush:1;              /*   176: 2  4 */\n        ...\n\nTherefore, to be safe from parallel read-modify-writes losing a write to\none of the bitfield members protected by a lock, all writes to all the\nbitfields must use the lock. They almost universally do, except for\nbtrfs_clear_space_info_full() which iterates over the space_infos and\nwrites out found->full = 0 without a lock.\n\nImagine that we have one thread completing a transaction in which we\nfinished deleting a block_group and are thus calling\nbtrfs_clear_space_info_full() while simultaneously the data reclaim\nticket infrastructure is running do_async_reclaim_data_space():\n\n          T1                                             T2\nbtrfs_commit_transaction\n  btrfs_clear_space_info_full\n  data_sinfo->full = 0\n  READ: full:0, chunk_alloc:0, flush:1\n                                              do_async_reclaim_data_space(data_sinfo)\n                                              spin_lock(&space_info->lock);\n                                              if(list_empty(tickets))\n                                                space_info->flush = 0;\n                                                READ: full: 0, chunk_alloc:0, flush:1\n                                                MOD/WRITE: full: 0, chunk_alloc:0, flush:0\n                                                spin_unlock(&space_info->lock);\n                                                return;\n  MOD/WRITE: full:0, chunk_alloc:0, flush:1\n\nand now data_sinfo->flush is 1 but the reclaim worker has exited. This\nbreaks the invariant that flush is 0 iff there is no work queued or\nrunning. Once this invariant is violated, future allocations that go\ninto __reserve_bytes() will add tickets to space_info->tickets but will\nsee space_info->flush is set to 1 and not queue the work. After this,\nthey will block forever on the resulting ticket, as it is now impossible\nto kick the worker again.\n\nI also confirmed by looking at the assembly of the affected kernel that\nit is doing RMW operations. For example, to set the flush (3rd) bit to 0,\nthe assembly is:\n  andb    $0xfb,0x60(%rbx)\nand similarly for setting the full (1st) bit to 0:\n  andb    $0xfe,-0x20(%rax)\n\nSo I think this is really a bug on practical systems.  I have observed\na number of systems in this exact state, but am currently unable to\nreproduce it.\n\nRather than leaving this footgun lying around for the future, take\nadvantage of the fact that there is room in the struct anyway, and that\nit is already quite large and simply change the three bitfield members to\nbools. This avoids writes to space_info->full having any effect on\n---truncated---", "datePublished": "2025-12-24T12:30:29", "dateUpdated": "2025-12-24T12:30:29", "baseScore": 0.0, "references": ["https://git.kernel.org/stable/c/6f442808a86eef847ee10afa9e6459494ed85bb3", "https://git.kernel.org/stable/c/742b90eaf394f0018352c0e10dc89763b2dd5267", "https://git.kernel.org/stable/c/38e818718c5e04961eea0fa8feff3f100ce40408", "https://nvd.nist.gov/vuln/detail/CVE-2025-68358"], "aliases": ["CVE-2025-68358"], "assigner": "Linux", "epss": 0.02, "enisaIdProduct": [{"id": "0b587c36-e227-3e97-ab31-297fc98a134b", "product": {"name": "Linux"}, "product_version": "957780eb2788d8c218d539e19a85653f51a96dc1 <742b90eaf394f0018352c0e10dc89763b2dd5267"}, {"id": "1f034c09-2089-3b8c-8c19-0c5d8a6cc951", "product": {"name": "Linux"}, "product_version": "4.8"}, {"id": "2e66acfa-3fd2-3424-b678-537730ffaa60", "product": {"name": "Linux"}, "product_version": "patch: 6.18.2"}, {"id": "3fb883fb-7bbe-3652-a0a6-685e24aafb89", "product": {"name": "Linux"}, "product_version": "957780eb2788d8c218d539e19a85653f51a96dc1 <6f442808a86eef847ee10afa9e6459494ed85bb3"}, {"id": "5f04ac9c-04b4-3aa4-945a-64f3ade62a8c", "product": {"name": "Linux"}, "product_version": "patch: 6.19-rc1"}, {"id": "85bd2538-4066-367f-b59c-f65b98501aac", "product": {"name": "Linux"}, "product_version": "957780eb2788d8c218d539e19a85653f51a96dc1 <38e818718c5e04961eea0fa8feff3f100ce40408"}, {"id": "8e9a212c-807a-32d8-a90f-dedee61b52e4", "product": {"name": "Linux"}, "product_version": "patch: 0"}, {"id": "cf7eb1d1-cc80-3618-977f-0b193ed3acde", "product": {"name": "Linux"}, "product_version": "patch: 6.17.13"}], "enisaIdVendor": [{"id": "8abc3fde-933a-3df7-b56e-43b6df40027a", "vendor": {"name": "Linux"}}], "isExploited": false}