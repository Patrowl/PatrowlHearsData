{"id": "EUVD-2025-22890", "enisaUuid": "ac4134d0-c2da-3764-a4e8-58b6957c4732", "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnetfilter: nf_conntrack: fix crash due to removal of uninitialised entry\n\nA crash in conntrack was reported while trying to unlink the conntrack\nentry from the hash bucket list:\n    [exception RIP: __nf_ct_delete_from_lists+172]\n    [..]\n #7 [ff539b5a2b043aa0] nf_ct_delete at ffffffffc124d421 [nf_conntrack]\n #8 [ff539b5a2b043ad0] nf_ct_gc_expired at ffffffffc124d999 [nf_conntrack]\n #9 [ff539b5a2b043ae0] __nf_conntrack_find_get at ffffffffc124efbc [nf_conntrack]\n    [..]\n\nThe nf_conn struct is marked as allocated from slab but appears to be in\na partially initialised state:\n\n ct hlist pointer is garbage; looks like the ct hash value\n (hence crash).\n ct->status is equal to IPS_CONFIRMED|IPS_DYING, which is expected\n ct->timeout is 30000 (=30s), which is unexpected.\n\nEverything else looks like normal udp conntrack entry.  If we ignore\nct->status and pretend its 0, the entry matches those that are newly\nallocated but not yet inserted into the hash:\n  - ct hlist pointers are overloaded and store/cache the raw tuple hash\n  - ct->timeout matches the relative time expected for a new udp flow\n    rather than the absolute 'jiffies' value.\n\nIf it were not for the presence of IPS_CONFIRMED,\n__nf_conntrack_find_get() would have skipped the entry.\n\nTheory is that we did hit following race:\n\ncpu x \t\t\tcpu y\t\t\tcpu z\n found entry E\t\tfound entry E\n E is expired\t\t<preemption>\n nf_ct_delete()\n return E to rcu slab\n\t\t\t\t\tinit_conntrack\n\t\t\t\t\tE is re-inited,\n\t\t\t\t\tct->status set to 0\n\t\t\t\t\treply tuplehash hnnode.pprev\n\t\t\t\t\tstores hash value.\n\ncpu y found E right before it was deleted on cpu x.\nE is now re-inited on cpu z.  cpu y was preempted before\nchecking for expiry and/or confirm bit.\n\n\t\t\t\t\t->refcnt set to 1\n\t\t\t\t\tE now owned by skb\n\t\t\t\t\t->timeout set to 30000\n\nIf cpu y were to resume now, it would observe E as\nexpired but would skip E due to missing CONFIRMED bit.\n\n\t\t\t\t\tnf_conntrack_confirm gets called\n\t\t\t\t\tsets: ct->status |= CONFIRMED\n\t\t\t\t\tThis is wrong: E is not yet added\n\t\t\t\t\tto hashtable.\n\ncpu y resumes, it observes E as expired but CONFIRMED:\n\t\t\t<resumes>\n\t\t\tnf_ct_expired()\n\t\t\t -> yes (ct->timeout is 30s)\n\t\t\tconfirmed bit set.\n\ncpu y will try to delete E from the hashtable:\n\t\t\tnf_ct_delete() -> set DYING bit\n\t\t\t__nf_ct_delete_from_lists\n\nEven this scenario doesn't guarantee a crash:\ncpu z still holds the table bucket lock(s) so y blocks:\n\n\t\t\twait for spinlock held by z\n\n\t\t\t\t\tCONFIRMED is set but there is no\n\t\t\t\t\tguarantee ct will be added to hash:\n\t\t\t\t\t\"chaintoolong\" or \"clash resolution\"\n\t\t\t\t\tlogic both skip the insert step.\n\t\t\t\t\treply hnnode.pprev still stores the\n\t\t\t\t\thash value.\n\n\t\t\t\t\tunlocks spinlock\n\t\t\t\t\treturn NF_DROP\n\t\t\t<unblocks, then\n\t\t\t crashes on hlist_nulls_del_rcu pprev>\n\nIn case CPU z does insert the entry into the hashtable, cpu y will unlink\nE again right away but no crash occurs.\n\nWithout 'cpu y' race, 'garbage' hlist is of no consequence:\nct refcnt remains at 1, eventually skb will be free'd and E gets\ndestroyed via: nf_conntrack_put -> nf_conntrack_destroy -> nf_ct_destroy.\n\nTo resolve this, move the IPS_CONFIRMED assignment after the table\ninsertion but before the unlock.\n\nPablo points out that the confirm-bit-store could be reordered to happen\nbefore hlist add resp. the timeout fixup, so switch to set_bit and\nbefore_atomic memory barrier to prevent this.\n\nIt doesn't matter if other CPUs can observe a newly inserted entry right\nbefore the CONFIRMED bit was set:\n\nSuch event cannot be distinguished from above \"E is the old incarnation\"\ncase: the entry will be skipped.\n\nAlso change nf_ct_should_gc() to first check the confirmed bit.\n\nThe gc sequence is:\n 1. Check if entry has expired, if not skip to next entry\n 2. Obtain a reference to the expired entry.\n 3. Call nf_ct_should_gc() to double-check step 1.\n\nnf_ct_should_gc() is thus called only for entries that already failed an\nexpiry check. After this patch, once the confirmed bit check pas\n---truncated---", "datePublished": "2025-07-28T12:30:34", "dateUpdated": "2025-12-22T21:30:31", "baseScore": 0.0, "references": ["https://git.kernel.org/stable/c/a47ef874189d47f934d0809ae738886307c0ea22", "https://git.kernel.org/stable/c/76179961c423cd698080b5e4d5583cf7f4fcdde9", "https://git.kernel.org/stable/c/fc38c249c622ff5e3011b8845fd49dbfd9289afc", "https://git.kernel.org/stable/c/938ce0e8422d3793fe30df2ed0e37f6bc0598379", "https://git.kernel.org/stable/c/2d72afb340657f03f7261e9243b44457a9228ac7", "https://nvd.nist.gov/vuln/detail/CVE-2025-38472", "https://lists.debian.org/debian-lts-announce/2025/10/msg00008.html"], "aliases": ["CVE-2025-38472"], "assigner": "Linux", "epss": 0.01, "enisaIdProduct": [{"id": "1d148ba0-23cc-3704-a18f-317ca206446c", "product": {"name": "Linux"}, "product_version": "patch: 6.15.8"}, {"id": "2f2c27d3-344f-3513-81c8-d68ea51f3d02", "product": {"name": "Linux"}, "product_version": "1397af5bfd7d32b0cf2adb70a78c9a9e8f11d912 <fc38c249c622ff5e3011b8845fd49dbfd9289afc"}, {"id": "3336463b-c78f-31c4-856d-15e5d22458df", "product": {"name": "Linux"}, "product_version": "5.19"}, {"id": "51ee03aa-a66a-3fbf-95ba-4405167e81e3", "product": {"name": "Linux"}, "product_version": "patch: 6.16"}, {"id": "77e28753-2fbc-30ea-a16b-20ab55ecad19", "product": {"name": "Linux"}, "product_version": "patch: 6.1.147"}, {"id": "82103a48-f573-3b2e-ae1c-a1deaa8d1249", "product": {"name": "Linux"}, "product_version": "1397af5bfd7d32b0cf2adb70a78c9a9e8f11d912 <938ce0e8422d3793fe30df2ed0e37f6bc0598379"}, {"id": "8f66fd1b-0197-3a13-ba8e-dc113e250bc8", "product": {"name": "Linux"}, "product_version": "1397af5bfd7d32b0cf2adb70a78c9a9e8f11d912 <76179961c423cd698080b5e4d5583cf7f4fcdde9"}, {"id": "9a6b4ab5-6b43-31eb-afc6-e4af07f10340", "product": {"name": "Linux"}, "product_version": "patch: 0"}, {"id": "9dd2fc68-b55c-3a24-bf5f-24048f2f9353", "product": {"name": "Linux"}, "product_version": "1397af5bfd7d32b0cf2adb70a78c9a9e8f11d912 <a47ef874189d47f934d0809ae738886307c0ea22"}, {"id": "cc86909a-08fa-3d5c-b37f-131a9bb683a8", "product": {"name": "Linux"}, "product_version": "patch: 6.6.100"}, {"id": "dacf4764-3475-3d55-94f5-22e69be0c9b6", "product": {"name": "Linux"}, "product_version": "594cea2c09f7cd440d1ee1c4547d5bc6a646b0e4"}, {"id": "e3be6983-6e72-3855-bda1-4d3377275261", "product": {"name": "Linux"}, "product_version": "1397af5bfd7d32b0cf2adb70a78c9a9e8f11d912 <2d72afb340657f03f7261e9243b44457a9228ac7"}, {"id": "fff34781-f766-3958-ba3d-3c004c8214d4", "product": {"name": "Linux"}, "product_version": "patch: 6.12.40"}], "enisaIdVendor": [{"id": "96055df2-bf90-325a-9258-b2e2987b283f", "vendor": {"name": "Linux"}}], "isExploited": false}