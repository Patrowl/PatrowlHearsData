{"id": "EUVD-2025-19778", "enisaUuid": "227ed9bc-e137-36e0-aed7-ba05003c372e", "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: fix ktls panic with sockmap\n\n[ 2172.936997] ------------[ cut here ]------------\n[ 2172.936999] kernel BUG at lib/iov_iter.c:629!\n......\n[ 2172.944996] PKRU: 55555554\n[ 2172.945155] Call Trace:\n[ 2172.945299]  <TASK>\n[ 2172.945428]  ? die+0x36/0x90\n[ 2172.945601]  ? do_trap+0xdd/0x100\n[ 2172.945795]  ? iov_iter_revert+0x178/0x180\n[ 2172.946031]  ? iov_iter_revert+0x178/0x180\n[ 2172.946267]  ? do_error_trap+0x7d/0x110\n[ 2172.946499]  ? iov_iter_revert+0x178/0x180\n[ 2172.946736]  ? exc_invalid_op+0x50/0x70\n[ 2172.946961]  ? iov_iter_revert+0x178/0x180\n[ 2172.947197]  ? asm_exc_invalid_op+0x1a/0x20\n[ 2172.947446]  ? iov_iter_revert+0x178/0x180\n[ 2172.947683]  ? iov_iter_revert+0x5c/0x180\n[ 2172.947913]  tls_sw_sendmsg_locked.isra.0+0x794/0x840\n[ 2172.948206]  tls_sw_sendmsg+0x52/0x80\n[ 2172.948420]  ? inet_sendmsg+0x1f/0x70\n[ 2172.948634]  __sys_sendto+0x1cd/0x200\n[ 2172.948848]  ? find_held_lock+0x2b/0x80\n[ 2172.949072]  ? syscall_trace_enter+0x140/0x270\n[ 2172.949330]  ? __lock_release.isra.0+0x5e/0x170\n[ 2172.949595]  ? find_held_lock+0x2b/0x80\n[ 2172.949817]  ? syscall_trace_enter+0x140/0x270\n[ 2172.950211]  ? lockdep_hardirqs_on_prepare+0xda/0x190\n[ 2172.950632]  ? ktime_get_coarse_real_ts64+0xc2/0xd0\n[ 2172.951036]  __x64_sys_sendto+0x24/0x30\n[ 2172.951382]  do_syscall_64+0x90/0x170\n......\n\nAfter calling bpf_exec_tx_verdict(), the size of msg_pl->sg may increase,\ne.g., when the BPF program executes bpf_msg_push_data().\n\nIf the BPF program sets cork_bytes and sg.size is smaller than cork_bytes,\nit will return -ENOSPC and attempt to roll back to the non-zero copy\nlogic. However, during rollback, msg->msg_iter is reset, but since\nmsg_pl->sg.size has been increased, subsequent executions will exceed the\nactual size of msg_iter.\n'''\niov_iter_revert(&msg->msg_iter, msg_pl->sg.size - orig_size);\n'''\n\nThe changes in this commit are based on the following considerations:\n\n1. When cork_bytes is set, rolling back to non-zero copy logic is\npointless and can directly go to zero-copy logic.\n\n2. We can not calculate the correct number of bytes to revert msg_iter.\n\nAssume the original data is \"abcdefgh\" (8 bytes), and after 3 pushes\nby the BPF program, it becomes 11-byte data: \"abc?de?fgh?\".\nThen, we set cork_bytes to 6, which means the first 6 bytes have been\nprocessed, and the remaining 5 bytes \"?fgh?\" will be cached until the\nlength meets the cork_bytes requirement.\n\nHowever, some data in \"?fgh?\" is not within 'sg->msg_iter'\n(but in msg_pl instead), especially the data \"?\" we pushed.\n\nSo it doesn't seem as simple as just reverting through an offset of\nmsg_iter.\n\n3. For non-TLS sockets in tcp_bpf_sendmsg, when a \"cork\" situation occurs,\nthe user-space send() doesn't return an error, and the returned length is\nthe same as the input length parameter, even if some data is cached.\n\nAdditionally, I saw that the current non-zero-copy logic for handling\ncorking is written as:\n'''\nline 1177\nelse if (ret != -EAGAIN) {\n\tif (ret == -ENOSPC)\n\t\tret = 0;\n\tgoto send_end;\n'''\n\nSo it's ok to just return 'copied' without error when a \"cork\" situation\noccurs.", "datePublished": "2025-07-03T09:30:35", "dateUpdated": "2025-12-18T21:31:33", "baseScore": 0.0, "references": ["https://git.kernel.org/stable/c/328cac3f9f8ae394748485e769a527518a9137c8", "https://git.kernel.org/stable/c/2e36a81d388ec9c3f78b6223f7eda2088cd40adb", "https://git.kernel.org/stable/c/57fbbe29e86042bbaa31c1a30d2afa16c427e3f7", "https://git.kernel.org/stable/c/603943f022a7fe5cc83ca7005faf34798fb7853f", "https://git.kernel.org/stable/c/54a3ecaeeeae8176da8badbd7d72af1017032c39", "https://nvd.nist.gov/vuln/detail/CVE-2025-38166", "https://lists.debian.org/debian-lts-announce/2025/10/msg00008.html"], "aliases": ["CVE-2025-38166"], "assigner": "Linux", "epss": 0.04, "enisaIdProduct": [{"id": "0ab62a3d-5c4f-3db4-a106-ba7098d67ac6", "product": {"name": "Linux"}, "product_version": "d3b18ad31f93d0b6bae105c679018a1ba7daa9ca <328cac3f9f8ae394748485e769a527518a9137c8"}, {"id": "16ca3981-6d0a-3c71-acb0-b65b93adf975", "product": {"name": "Linux"}, "product_version": "4.20"}, {"id": "1e28aafd-51a3-39e4-a38a-2bc938dad6cb", "product": {"name": "Linux"}, "product_version": "patch: 6.15.3"}, {"id": "44d69eb6-abf3-3879-9318-95ad30423a04", "product": {"name": "Linux"}, "product_version": "patch: 6.6.94"}, {"id": "69a731fd-949c-3c18-8845-59ed84faf1de", "product": {"name": "Linux"}, "product_version": "patch: 0"}, {"id": "6b5918e6-2e6e-3743-b2fa-e015a1d082a1", "product": {"name": "Linux"}, "product_version": "patch: 6.1.142"}, {"id": "925e4861-52ee-38b2-8062-8fe465d44696", "product": {"name": "Linux"}, "product_version": "patch: 6.16"}, {"id": "938acd1f-af3e-30b3-9563-e7ac4130fd5f", "product": {"name": "Linux"}, "product_version": "d3b18ad31f93d0b6bae105c679018a1ba7daa9ca <54a3ecaeeeae8176da8badbd7d72af1017032c39"}, {"id": "bba4f005-00b1-3b33-a2fd-002368fec608", "product": {"name": "Linux"}, "product_version": "d3b18ad31f93d0b6bae105c679018a1ba7daa9ca <603943f022a7fe5cc83ca7005faf34798fb7853f"}, {"id": "ca597b56-4aca-359d-8537-1570132a3a51", "product": {"name": "Linux"}, "product_version": "d3b18ad31f93d0b6bae105c679018a1ba7daa9ca <57fbbe29e86042bbaa31c1a30d2afa16c427e3f7"}, {"id": "d0b2e3de-3beb-3949-8d37-cac7946b295b", "product": {"name": "Linux"}, "product_version": "d3b18ad31f93d0b6bae105c679018a1ba7daa9ca <2e36a81d388ec9c3f78b6223f7eda2088cd40adb"}, {"id": "d4a03716-f2f2-31f6-a2a3-b56e0e7e6340", "product": {"name": "Linux"}, "product_version": "patch: 6.16-rc1"}, {"id": "ea09a881-b538-31e2-a21c-c52f56dcbfcc", "product": {"name": "Linux"}, "product_version": "patch: 6.12.34"}], "enisaIdVendor": [{"id": "eee76512-fa22-30c4-9a9a-38177bbfda64", "vendor": {"name": "Linux"}}], "isExploited": false}