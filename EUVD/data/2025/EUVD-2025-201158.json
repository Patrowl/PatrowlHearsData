{"id": "EUVD-2025-201158", "enisaUuid": "9a6fd42a-b38d-3344-809a-4879a189ac21", "description": "In the Linux kernel, the following vulnerability has been resolved:\n\naf_unix: Initialise scc_index in unix_add_edge().\n\nQuang Le reported that the AF_UNIX GC could garbage-collect a\nreceive queue of an alive in-flight socket, with a nice repro.\n\nThe repro consists of three stages.\n\n  1)\n    1-a. Create a single cyclic reference with many sockets\n    1-b. close() all sockets\n    1-c. Trigger GC\n\n  2)\n    2-a. Pass sk-A to an embryo sk-B\n    2-b. Pass sk-X to sk-X\n    2-c. Trigger GC\n\n  3)\n    3-a. accept() the embryo sk-B\n    3-b. Pass sk-B to sk-C\n    3-c. close() the in-flight sk-A\n    3-d. Trigger GC\n\nAs of 2-c, sk-A and sk-X are linked to unix_unvisited_vertices,\nand unix_walk_scc() groups them into two different SCCs:\n\n  unix_sk(sk-A)->vertex->scc_index = 2 (UNIX_VERTEX_INDEX_START)\n  unix_sk(sk-X)->vertex->scc_index = 3\n\nOnce GC completes, unix_graph_grouped is set to true.\nAlso, unix_graph_maybe_cyclic is set to true due to sk-X's\ncyclic self-reference, which makes close() trigger GC.\n\nAt 3-b, unix_add_edge() allocates unix_sk(sk-B)->vertex and\nlinks it to unix_unvisited_vertices.\n\nunix_update_graph() is called at 3-a. and 3-b., but neither\nunix_graph_grouped nor unix_graph_maybe_cyclic is changed\nbecause both sk-B's listener and sk-C are not in-flight.\n\n3-c decrements sk-A's file refcnt to 1.\n\nSince unix_graph_grouped is true at 3-d, unix_walk_scc_fast()\nis finally called and iterates 3 sockets sk-A, sk-B, and sk-X:\n\n  sk-A -> sk-B (-> sk-C)\n  sk-X -> sk-X\n\nThis is totally fine.  All of them are not yet close()d and\nshould be grouped into different SCCs.\n\nHowever, unix_vertex_dead() misjudges that sk-A and sk-B are\nin the same SCC and sk-A is dead.\n\n  unix_sk(sk-A)->scc_index == unix_sk(sk-B)->scc_index <-- Wrong!\n  &&\n  sk-A's file refcnt == unix_sk(sk-A)->vertex->out_degree\n                                       ^-- 1 in-flight count for sk-B\n  -> sk-A is dead !?\n\nThe problem is that unix_add_edge() does not initialise scc_index.\n\nStage 1) is used for heap spraying, making a newly allocated\nvertex have vertex->scc_index == 2 (UNIX_VERTEX_INDEX_START)\nset by unix_walk_scc() at 1-c.\n\nLet's track the max SCC index from the previous unix_walk_scc()\ncall and assign the max + 1 to a new vertex's scc_index.\n\nThis way, we can continue to avoid Tarjan's algorithm while\npreventing misjudgments.", "datePublished": "2025-12-04T15:30:32", "dateUpdated": "2025-12-07T00:30:56", "baseScore": 0.0, "references": ["https://git.kernel.org/stable/c/4cd8d755c7d4f515dd9abf483316aca2f1b7b0f3", "https://git.kernel.org/stable/c/db81ad20fd8aef7cc7d536c52ee5ea4c1f979128", "https://git.kernel.org/stable/c/1aa7e40ee850c9053e769957ce6541173891204d", "https://git.kernel.org/stable/c/60e6489f8e3b086bd1130ad4450a2c112e863791", "https://nvd.nist.gov/vuln/detail/CVE-2025-40214", "https://git.kernel.org/stable/c/20003fbb9174121b27bd1da6ebe61542ac4c327d"], "aliases": ["CVE-2025-40214"], "assigner": "Linux", "epss": 0.02, "enisaIdProduct": [{"id": "011b61f7-2ed5-30f6-a583-e64f47e571cc", "product": {"name": "Linux"}, "product_version": "d23802221f6755e104606864067c71af8cdb6788 <4cd8d755c7d4f515dd9abf483316aca2f1b7b0f3"}, {"id": "0f246220-3f77-3dfc-9144-18a9c8eb3a90", "product": {"name": "Linux"}, "product_version": "patch: 6.6.117"}, {"id": "11db8d7e-82fc-3c7b-8e31-480b105decd8", "product": {"name": "Linux"}, "product_version": "ad081928a8b0f57f269df999a28087fce6f2b6ce <60e6489f8e3b086bd1130ad4450a2c112e863791"}, {"id": "22ce57bb-a339-3c3e-879a-f05c6b91cf6a", "product": {"name": "Linux"}, "product_version": "adfb68b39b39767d6bfb53e48c4f19c183765686"}, {"id": "2815493f-bc2a-3ee8-915b-6b13db86affc", "product": {"name": "Linux"}, "product_version": "patch: 6.18"}, {"id": "3fbf32e8-2d3f-3195-aff1-3e119eaaa5d2", "product": {"name": "Linux"}, "product_version": "patch: 6.12.59"}, {"id": "4c92b900-4061-3d70-85f3-011a69df78e0", "product": {"name": "Linux"}, "product_version": "patch: 6.17.9"}, {"id": "709b6b26-6c01-3e24-83ea-3ea70fac5c5f", "product": {"name": "Linux"}, "product_version": "6.10"}, {"id": "729dbf1f-e7e7-3a93-ad73-02e77c12cad7", "product": {"name": "Linux"}, "product_version": "ad081928a8b0f57f269df999a28087fce6f2b6ce <db81ad20fd8aef7cc7d536c52ee5ea4c1f979128"}, {"id": "75a58d74-292b-38bd-863f-8eb36b082eed", "product": {"name": "Linux"}, "product_version": "ad081928a8b0f57f269df999a28087fce6f2b6ce <1aa7e40ee850c9053e769957ce6541173891204d"}, {"id": "c3358332-247e-31e8-9ae0-52401da397a3", "product": {"name": "Linux"}, "product_version": "patch: 6.1.159"}, {"id": "cf7b804b-36a7-365a-8c88-66339c483554", "product": {"name": "Linux"}, "product_version": "patch: 0"}, {"id": "fb75e480-8479-3ac3-b90d-c64fa6929622", "product": {"name": "Linux"}, "product_version": "adfb68b39b39767d6bfb53e48c4f19c183765686 <20003fbb9174121b27bd1da6ebe61542ac4c327d"}], "enisaIdVendor": [{"id": "e5c04586-6491-39b4-86c4-eb091a918957", "vendor": {"name": "Linux"}}], "isExploited": false}