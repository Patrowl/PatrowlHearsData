{"id": "EUVD-2025-32395", "enisaUuid": "51b74448-0a6f-3049-b73d-1816b5deee1f", "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nice: fix Rx page leak on multi-buffer frames\n\nThe ice_put_rx_mbuf() function handles calling ice_put_rx_buf() for each\nbuffer in the current frame. This function was introduced as part of\nhandling multi-buffer XDP support in the ice driver.\n\nIt works by iterating over the buffers from first_desc up to 1 plus the\ntotal number of fragments in the frame, cached from before the XDP program\nwas executed.\n\nIf the hardware posts a descriptor with a size of 0, the logic used in\nice_put_rx_mbuf() breaks. Such descriptors get skipped and don't get added\nas fragments in ice_add_xdp_frag. Since the buffer isn't counted as a\nfragment, we do not iterate over it in ice_put_rx_mbuf(), and thus we don't\ncall ice_put_rx_buf().\n\nBecause we don't call ice_put_rx_buf(), we don't attempt to re-use the\npage or free it. This leaves a stale page in the ring, as we don't\nincrement next_to_alloc.\n\nThe ice_reuse_rx_page() assumes that the next_to_alloc has been incremented\nproperly, and that it always points to a buffer with a NULL page. Since\nthis function doesn't check, it will happily recycle a page over the top\nof the next_to_alloc buffer, losing track of the old page.\n\nNote that this leak only occurs for multi-buffer frames. The\nice_put_rx_mbuf() function always handles at least one buffer, so a\nsingle-buffer frame will always get handled correctly. It is not clear\nprecisely why the hardware hands us descriptors with a size of 0 sometimes,\nbut it happens somewhat regularly with \"jumbo frames\" used by 9K MTU.\n\nTo fix ice_put_rx_mbuf(), we need to make sure to call ice_put_rx_buf() on\nall buffers between first_desc and next_to_clean. Borrow the logic of a\nsimilar function in i40e used for this same purpose. Use the same logic\nalso in ice_get_pgcnts().\n\nInstead of iterating over just the number of fragments, use a loop which\niterates until the current index reaches to the next_to_clean element just\npast the current frame. Unlike i40e, the ice_put_rx_mbuf() function does\ncall ice_put_rx_buf() on the last buffer of the frame indicating the end of\npacket.\n\nFor non-linear (multi-buffer) frames, we need to take care when adjusting\nthe pagecnt_bias. An XDP program might release fragments from the tail of\nthe frame, in which case that fragment page is already released. Only\nupdate the pagecnt_bias for the first descriptor and fragments still\nremaining post-XDP program. Take care to only access the shared info for\nfragmented buffers, as this avoids a significant cache miss.\n\nThe xdp_xmit value only needs to be updated if an XDP program is run, and\nonly once per packet. Drop the xdp_xmit pointer argument from\nice_put_rx_mbuf(). Instead, set xdp_xmit in the ice_clean_rx_irq() function\ndirectly. This avoids needing to pass the argument and avoids an extra\nbit-wise OR for each buffer in the frame.\n\nMove the increment of the ntc local variable to ensure its updated *before*\nall calls to ice_get_pgcnts() or ice_put_rx_mbuf(), as the loop logic\nrequires the index of the element just after the current frame.\n\nNow that we use an index pointer in the ring to identify the packet, we no\nlonger need to track or cache the number of fragments in the rx_ring.", "datePublished": "2025-10-04T07:31:09", "dateUpdated": "2025-10-04T07:31:09", "baseScore": 0.0, "references": ["https://nvd.nist.gov/vuln/detail/CVE-2025-39948", "https://git.kernel.org/stable/c/80555adb5c892f0e21d243ae96ed997ee520aea9", "https://git.kernel.org/stable/c/84bf1ac85af84d354c7a2fdbdc0d4efc8aaec34b", "https://git.kernel.org/stable/c/fcb5718ebfe7fd64144e3399280440cce361a3ae"], "aliases": ["CVE-2025-39948", "GHSA-7v58-mp27-j7rx"], "assigner": "Linux", "epss": 0.02, "enisaIdProduct": [{"id": "1b5c143d-747e-3695-af91-ee4d9eb3e04c", "product": {"name": "Linux"}, "product_version": "patch: 0"}, {"id": "2a206255-0207-35ad-8b1e-5bb69708d71d", "product": {"name": "Linux"}, "product_version": "743bbd93cf29f653fae0e1416a31f03231689911 <fcb5718ebfe7fd64144e3399280440cce361a3ae"}, {"id": "39c50727-057d-35cb-b7ad-2f465544e522", "product": {"name": "Linux"}, "product_version": "ac1728cf370bec2e74fe6a2adf05b4629980d2b3"}, {"id": "41b3d5e6-8b95-3a72-8406-0aa031567a37", "product": {"name": "Linux"}, "product_version": "d445b59d30415bb56f4803f622d566bca06e0abc"}, {"id": "5b55e55d-e4ea-3e47-ba23-418689c611a7", "product": {"name": "Linux"}, "product_version": "patch: 6.12.49"}, {"id": "5edc5239-fe40-3610-a1a2-c755e574da0a", "product": {"name": "Linux"}, "product_version": "patch: 6.16.9"}, {"id": "6a68c8c0-bde5-3a4b-aed3-1695b212b0e7", "product": {"name": "Linux"}, "product_version": "6.14"}, {"id": "826cbd9e-9def-3985-abf9-ea3902a4c9f0", "product": {"name": "Linux"}, "product_version": "311813ed013c016d4b0b0985a9ee41f778489077 <80555adb5c892f0e21d243ae96ed997ee520aea9"}, {"id": "87f0acc1-806c-3b9b-a733-3b642e86a694", "product": {"name": "Linux"}, "product_version": "patch: 6.17"}, {"id": "ac3d4fab-8068-39f9-b6c4-d3d7745d9d86", "product": {"name": "Linux"}, "product_version": "743bbd93cf29f653fae0e1416a31f03231689911 <84bf1ac85af84d354c7a2fdbdc0d4efc8aaec34b"}], "enisaIdVendor": [{"id": "e40c60e4-f1ec-3b55-907d-edd99e682873", "vendor": {"name": "Linux"}}], "isExploited": false}