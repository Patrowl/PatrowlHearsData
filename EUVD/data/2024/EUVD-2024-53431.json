{"id": "EUVD-2024-53431", "enisaUuid": "39765275-dd1d-34c5-b43c-946ebcbdc6b6", "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nnet: ethernet: oa_tc6: fix tx skb race condition between reference pointers\n\nThere are two skb pointers to manage tx skb's enqueued from n/w stack.\nwaiting_tx_skb pointer points to the tx skb which needs to be processed\nand ongoing_tx_skb pointer points to the tx skb which is being processed.\n\nSPI thread prepares the tx data chunks from the tx skb pointed by the\nongoing_tx_skb pointer. When the tx skb pointed by the ongoing_tx_skb is\nprocessed, the tx skb pointed by the waiting_tx_skb is assigned to\nongoing_tx_skb and the waiting_tx_skb pointer is assigned with NULL.\nWhenever there is a new tx skb from n/w stack, it will be assigned to\nwaiting_tx_skb pointer if it is NULL. Enqueuing and processing of a tx skb\nhandled in two different threads.\n\nConsider a scenario where the SPI thread processed an ongoing_tx_skb and\nit moves next tx skb from waiting_tx_skb pointer to ongoing_tx_skb pointer\nwithout doing any NULL check. At this time, if the waiting_tx_skb pointer\nis NULL then ongoing_tx_skb pointer is also assigned with NULL. After\nthat, if a new tx skb is assigned to waiting_tx_skb pointer by the n/w\nstack and there is a chance to overwrite the tx skb pointer with NULL in\nthe SPI thread. Finally one of the tx skb will be left as unhandled,\nresulting packet missing and memory leak.\n\n- Consider the below scenario where the TXC reported from the previous\ntransfer is 10 and ongoing_tx_skb holds an tx ethernet frame which can be\ntransported in 20 TXCs and waiting_tx_skb is still NULL.\n\ttx_credits = 10; /* 21 are filled in the previous transfer */\n\tongoing_tx_skb = 20;\n\twaiting_tx_skb = NULL; /* Still NULL */\n- So, (tc6->ongoing_tx_skb || tc6->waiting_tx_skb) becomes true.\n- After oa_tc6_prepare_spi_tx_buf_for_tx_skbs()\n\tongoing_tx_skb = 10;\n\twaiting_tx_skb = NULL; /* Still NULL */\n- Perform SPI transfer.\n- Process SPI rx buffer to get the TXC from footers.\n- Now let's assume previously filled 21 TXCs are freed so we are good to\ntransport the next remaining 10 tx chunks from ongoing_tx_skb.\n\ttx_credits = 21;\n\tongoing_tx_skb = 10;\n\twaiting_tx_skb = NULL;\n- So, (tc6->ongoing_tx_skb || tc6->waiting_tx_skb) becomes true again.\n- In the oa_tc6_prepare_spi_tx_buf_for_tx_skbs()\n\tongoing_tx_skb = NULL;\n\twaiting_tx_skb = NULL;\n\n- Now the below bad case might happen,\n\nThread1 (oa_tc6_start_xmit)\tThread2 (oa_tc6_spi_thread_handler)\n---------------------------\t-----------------------------------\n- if waiting_tx_skb is NULL\n\t\t\t\t- if ongoing_tx_skb is NULL\n\t\t\t\t- ongoing_tx_skb = waiting_tx_skb\n- waiting_tx_skb = skb\n\t\t\t\t- waiting_tx_skb = NULL\n\t\t\t\t...\n\t\t\t\t- ongoing_tx_skb = NULL\n- if waiting_tx_skb is NULL\n- waiting_tx_skb = skb\n\nTo overcome the above issue, protect the moving of tx skb reference from\nwaiting_tx_skb pointer to ongoing_tx_skb pointer and assigning new tx skb\nto waiting_tx_skb pointer, so that the other thread can't access the\nwaiting_tx_skb pointer until the current thread completes moving the tx\nskb reference safely.", "datePublished": "2025-01-11T15:30:29", "dateUpdated": "2025-09-24T21:30:31", "baseScore": 0.0, "references": ["https://git.kernel.org/stable/c/1f2eb6c32bae04b375bb7a0aedbeefb6dbbcb775", "https://git.kernel.org/stable/c/e592b5110b3e9393881b0a019d86832bbf71a47f", "https://nvd.nist.gov/vuln/detail/CVE-2024-56788"], "aliases": ["CVE-2024-56788"], "assigner": "Linux", "epss": 0.02, "enisaIdProduct": [{"id": "22234f8b-e6c1-3536-a899-30ae580d103d", "product": {"name": "Linux"}, "product_version": "6.12"}, {"id": "250d0499-6b6f-38b0-b658-7ab6a68dc667", "product": {"name": "Linux"}, "product_version": "patch: 6.13"}, {"id": "a55edc7f-4570-3fdf-8af1-c8487f67c4e3", "product": {"name": "Linux"}, "product_version": "patch: 6.12.7"}, {"id": "c9e86caa-7aff-3279-9b8d-d3a121862567", "product": {"name": "Linux"}, "product_version": "patch: 0"}, {"id": "ec10c6b9-411c-31cc-98bf-1c025a3b2706", "product": {"name": "Linux"}, "product_version": "53fbde8ab21e8c2c6187159cc17fc10cbf20900a <e592b5110b3e9393881b0a019d86832bbf71a47f"}, {"id": "fb9b4968-9064-3b40-814f-51bf2e3bbf2f", "product": {"name": "Linux"}, "product_version": "53fbde8ab21e8c2c6187159cc17fc10cbf20900a <1f2eb6c32bae04b375bb7a0aedbeefb6dbbcb775"}], "enisaIdVendor": [{"id": "d3b57648-a765-3b5e-a8fa-40ad0c05a1b8", "vendor": {"name": "Linux"}}], "isExploited": false}