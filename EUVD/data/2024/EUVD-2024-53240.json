{"id": "EUVD-2024-53240", "enisaUuid": "186f0a4c-8f1c-3133-94b0-b65a372aeceb", "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Call free_htab_elem() after htab_unlock_bucket()\n\nFor htab of maps, when the map is removed from the htab, it may hold the\nlast reference of the map. bpf_map_fd_put_ptr() will invoke\nbpf_map_free_id() to free the id of the removed map element. However,\nbpf_map_fd_put_ptr() is invoked while holding a bucket lock\n(raw_spin_lock_t), and bpf_map_free_id() attempts to acquire map_idr_lock\n(spinlock_t), triggering the following lockdep warning:\n\n  =============================\n  [ BUG: Invalid wait context ]\n  6.11.0-rc4+ #49 Not tainted\n  -----------------------------\n  test_maps/4881 is trying to lock:\n  ffffffff84884578 (map_idr_lock){+...}-{3:3}, at: bpf_map_free_id.part.0+0x21/0x70\n  other info that might help us debug this:\n  context-{5:5}\n  2 locks held by test_maps/4881:\n   #0: ffffffff846caf60 (rcu_read_lock){....}-{1:3}, at: bpf_fd_htab_map_update_elem+0xf9/0x270\n   #1: ffff888149ced148 (&htab->lockdep_key#2){....}-{2:2}, at: htab_map_update_elem+0x178/0xa80\n  stack backtrace:\n  CPU: 0 UID: 0 PID: 4881 Comm: test_maps Not tainted 6.11.0-rc4+ #49\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), ...\n  Call Trace:\n   <TASK>\n   dump_stack_lvl+0x6e/0xb0\n   dump_stack+0x10/0x20\n   __lock_acquire+0x73e/0x36c0\n   lock_acquire+0x182/0x450\n   _raw_spin_lock_irqsave+0x43/0x70\n   bpf_map_free_id.part.0+0x21/0x70\n   bpf_map_put+0xcf/0x110\n   bpf_map_fd_put_ptr+0x9a/0xb0\n   free_htab_elem+0x69/0xe0\n   htab_map_update_elem+0x50f/0xa80\n   bpf_fd_htab_map_update_elem+0x131/0x270\n   htab_map_update_elem+0x50f/0xa80\n   bpf_fd_htab_map_update_elem+0x131/0x270\n   bpf_map_update_value+0x266/0x380\n   __sys_bpf+0x21bb/0x36b0\n   __x64_sys_bpf+0x45/0x60\n   x64_sys_call+0x1b2a/0x20d0\n   do_syscall_64+0x5d/0x100\n   entry_SYSCALL_64_after_hwframe+0x76/0x7e\n\nOne way to fix the lockdep warning is using raw_spinlock_t for\nmap_idr_lock as well. However, bpf_map_alloc_id() invokes\nidr_alloc_cyclic() after acquiring map_idr_lock, it will trigger a\nsimilar lockdep warning because the slab's lock (s->cpu_slab->lock) is\nstill a spinlock.\n\nInstead of changing map_idr_lock's type, fix the issue by invoking\nhtab_put_fd_value() after htab_unlock_bucket(). However, only deferring\nthe invocation of htab_put_fd_value() is not enough, because the old map\npointers in htab of maps can not be saved during batched deletion.\nTherefore, also defer the invocation of free_htab_elem(), so these\nto-be-freed elements could be linked together similar to lru map.\n\nThere are four callers for ->map_fd_put_ptr:\n\n(1) alloc_htab_elem() (through htab_put_fd_value())\nIt invokes ->map_fd_put_ptr() under a raw_spinlock_t. The invocation of\nhtab_put_fd_value() can not simply move after htab_unlock_bucket(),\nbecause the old element has already been stashed in htab->extra_elems.\nIt may be reused immediately after htab_unlock_bucket() and the\ninvocation of htab_put_fd_value() after htab_unlock_bucket() may release\nthe newly-added element incorrectly. Therefore, saving the map pointer\nof the old element for htab of maps before unlocking the bucket and\nreleasing the map_ptr after unlock. Beside the map pointer in the old\nelement, should do the same thing for the special fields in the old\nelement as well.\n\n(2) free_htab_elem() (through htab_put_fd_value())\nIts caller includes __htab_map_lookup_and_delete_elem(),\nhtab_map_delete_elem() and __htab_map_lookup_and_delete_batch().\n\nFor htab_map_delete_elem(), simply invoke free_htab_elem() after\nhtab_unlock_bucket(). For __htab_map_lookup_and_delete_batch(), just\nlike lru map, linking the to-be-freed element into node_to_free list\nand invoking free_htab_elem() for these element after unlock. It is safe\nto reuse batch_flink as the link for node_to_free, because these\nelements have been removed from the hash llist.\n\nBecause htab of maps doesn't support lookup_and_delete operation,\n__htab_map_lookup_and_delete_elem() doesn't have the problem, so kept\nit as\n---truncated---", "datePublished": "2024-12-27T15:31:54", "dateUpdated": "2025-10-08T15:32:25", "baseScore": 0.0, "references": ["https://git.kernel.org/stable/c/10e8a2dec9ff1b81de8e892b0850924038adbc6d", "https://git.kernel.org/stable/c/a50b4aa3007e63a590d501341f304676ebc74b3b", "https://git.kernel.org/stable/c/b9e9ed90b10c82a4e9d4d70a2890f06bfcdd3b78", "https://nvd.nist.gov/vuln/detail/CVE-2024-56592"], "aliases": ["CVE-2024-56592"], "assigner": "Linux", "epss": 0.03, "enisaIdProduct": [{"id": "18774dea-aa18-3b54-98d2-fe8f03c570f1", "product": {"name": "Linux"}, "product_version": "f3f1c054c288bb6e503005e6d73611151ed20e91 <a50b4aa3007e63a590d501341f304676ebc74b3b"}, {"id": "1af895a0-c7c4-3889-b878-989677372448", "product": {"name": "Linux"}, "product_version": "patch: 6.12.5"}, {"id": "4f7cbd29-adf7-37a1-ad62-6a966086f0ce", "product": {"name": "Linux"}, "product_version": "f3f1c054c288bb6e503005e6d73611151ed20e91 <b9e9ed90b10c82a4e9d4d70a2890f06bfcdd3b78"}, {"id": "6a2577a5-5e47-369c-ada9-aa54d69c69a0", "product": {"name": "Linux"}, "product_version": "4.13"}, {"id": "a44939aa-9a83-3394-a26d-900f975e65aa", "product": {"name": "Linux"}, "product_version": "f3f1c054c288bb6e503005e6d73611151ed20e91 <10e8a2dec9ff1b81de8e892b0850924038adbc6d"}, {"id": "a98efc1b-4abe-3a67-9799-88bcbafed8f3", "product": {"name": "Linux"}, "product_version": "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2 <10e8a2dec9ff1b81de8e892b0850924038adbc6d"}, {"id": "bda8482a-6c0e-36f1-b936-f25f14277094", "product": {"name": "Linux"}, "product_version": "patch: 6.13"}, {"id": "beb4fb9b-a309-3364-acbb-c94fffd672fa", "product": {"name": "Linux"}, "product_version": "patch: 6.6.66"}, {"id": "e4d48f1a-806a-32dc-8a11-d5acc0953f70", "product": {"name": "Linux"}, "product_version": "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2 <b9e9ed90b10c82a4e9d4d70a2890f06bfcdd3b78"}, {"id": "e8bca97c-c32f-316a-b3b8-b9ec9604142b", "product": {"name": "Linux"}, "product_version": "1da177e4c3f41524e886b7f1b8a0c1fc7321cac2 <a50b4aa3007e63a590d501341f304676ebc74b3b"}, {"id": "fe20ca01-eb31-3ea6-adbb-a2e8f696de1b", "product": {"name": "Linux"}, "product_version": "patch: 0"}], "enisaIdVendor": [{"id": "d7153cb8-b332-3261-814a-2ac7ba32db78", "vendor": {"name": "Linux"}}], "isExploited": false}