{"id": "EUVD-2022-55706", "enisaUuid": "1c6def00-00ff-3e6f-8e1f-07c5b1f12219", "description": "In the Linux kernel, the following vulnerability has been resolved:\n\nbpf: Fix reference state management for synchronous callbacks\n\nCurrently, verifier verifies callback functions (sync and async) as if\nthey will be executed once, (i.e. it explores execution state as if the\nfunction was being called once). The next insn to explore is set to\nstart of subprog and the exit from nested frame is handled using\ncurframe > 0 and prepare_func_exit. In case of async callback it uses a\ncustomized variant of push_stack simulating a kind of branch to set up\ncustom state and execution context for the async callback.\n\nWhile this approach is simple and works when callback really will be\nexecuted only once, it is unsafe for all of our current helpers which\nare for_each style, i.e. they execute the callback multiple times.\n\nA callback releasing acquired references of the caller may do so\nmultiple times, but currently verifier sees it as one call inside the\nframe, which then returns to caller. Hence, it thinks it released some\nreference that the cb e.g. got access through callback_ctx (register\nfilled inside cb from spilled typed register on stack).\n\nSimilarly, it may see that an acquire call is unpaired inside the\ncallback, so the caller will copy the reference state of callback and\nthen will have to release the register with new ref_obj_ids. But again,\nthe callback may execute multiple times, but the verifier will only\naccount for acquired references for a single symbolic execution of the\ncallback, which will cause leaks.\n\nNote that for async callback case, things are different. While currently\nwe have bpf_timer_set_callback which only executes it once, even for\nmultiple executions it would be safe, as reference state is NULL and\ncheck_reference_leak would force program to release state before\nBPF_EXIT. The state is also unaffected by analysis for the caller frame.\nHence async callback is safe.\n\nSince we want the reference state to be accessible, e.g. for pointers\nloaded from stack through callback_ctx's PTR_TO_STACK, we still have to\ncopy caller's reference_state to callback's bpf_func_state, but we\nenforce that whatever references it adds to that reference_state has\nbeen released before it hits BPF_EXIT. This requires introducing a new\ncallback_ref member in the reference state to distinguish between caller\nvs callee references. Hence, check_reference_leak now errors out if it\nsees we are in callback_fn and we have not released callback_ref refs.\nSince there can be multiple nested callbacks, like frame 0 -> cb1 -> cb2\netc. we need to also distinguish between whether this particular ref\nbelongs to this callback frame or parent, and only error for our own, so\nwe store state->frameno (which is always non-zero for callbacks).\n\nIn short, callbacks can read parent reference_state, but cannot mutate\nit, to be able to use pointers acquired by the caller. They must only\nundo their changes (by releasing their own acquired_refs before\nBPF_EXIT) on top of caller reference_state before returning (at which\npoint the caller and callback state will match anyway, so no need to\ncopy it back to caller).", "datePublished": "2025-12-09T03:31:09", "dateUpdated": "2025-12-09T03:31:09", "baseScore": 0.0, "references": ["https://git.kernel.org/stable/c/4ed5155043c97ac8912bcf67331df87c833fb067", "https://git.kernel.org/stable/c/caa176c0953cdfd5ce500fb517ce1ea924a8bc4c", "https://git.kernel.org/stable/c/aed931fd3b6e28f19cc140ff90aa5046ee2aa4e1", "https://git.kernel.org/stable/c/9d9d00ac29d0ef7ce426964de46fa6b380357d0a", "https://nvd.nist.gov/vuln/detail/CVE-2022-50650"], "aliases": ["CVE-2022-50650"], "assigner": "Linux", "epss": 0.02, "enisaIdProduct": [{"id": "2c253068-a979-37ca-93ae-ea678ef253e8", "product": {"name": "Linux"}, "product_version": "patch: 5.15.75"}, {"id": "363e0b2b-bd89-311b-8669-fc825387f6ad", "product": {"name": "Linux"}, "product_version": "69c087ba6225b574afb6e505b72cb75242a3d844 <caa176c0953cdfd5ce500fb517ce1ea924a8bc4c"}, {"id": "6230d4d1-8383-3845-98d4-68f9c1ba1960", "product": {"name": "Linux"}, "product_version": "patch: 6.1"}, {"id": "623e1c9d-b155-3877-a7ff-e0e5ef57bd07", "product": {"name": "Linux"}, "product_version": "patch: 5.19.17"}, {"id": "99f6fbfc-b549-3893-a399-93781a40c1f6", "product": {"name": "Linux"}, "product_version": "5.13"}, {"id": "ae937840-5081-36c9-915b-607a2ce69c62", "product": {"name": "Linux"}, "product_version": "patch: 0"}, {"id": "b987eef1-842c-3570-94b4-f88cd5be7494", "product": {"name": "Linux"}, "product_version": "69c087ba6225b574afb6e505b72cb75242a3d844 <9d9d00ac29d0ef7ce426964de46fa6b380357d0a"}, {"id": "e17aeae0-03fb-3ebf-8b21-f77de2dbefd2", "product": {"name": "Linux"}, "product_version": "patch: 6.0.3"}, {"id": "f08e284b-881c-3f25-a355-baea4b74d947", "product": {"name": "Linux"}, "product_version": "69c087ba6225b574afb6e505b72cb75242a3d844 <4ed5155043c97ac8912bcf67331df87c833fb067"}, {"id": "f694306b-c53b-3f53-a7c8-d36b03f637e0", "product": {"name": "Linux"}, "product_version": "69c087ba6225b574afb6e505b72cb75242a3d844 <aed931fd3b6e28f19cc140ff90aa5046ee2aa4e1"}], "enisaIdVendor": [{"id": "10de21f7-911b-3684-adc2-2e2b90e29d24", "vendor": {"name": "Linux"}}], "isExploited": false}